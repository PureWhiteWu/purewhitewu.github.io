<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0"><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="https://static.purewhite.io/favicon.jpg"><link rel="icon" type="image/png" sizes="32x32" href="https://static.purewhite.io/favicon.jpg"><link rel="icon" type="image/png" sizes="16x16" href="https://static.purewhite.io/favicon.jpg"><link rel="mask-icon" href="https://static.purewhite.io/favicon.jpg" color="#222"><meta name="google-site-verification" content="Xg_Hnp9ie-Rq7-zLPdd3c9dQtR_0N845ue4QaK8jvL4"><meta name="baidu-site-verification" content="c3b074df19d33f893845b6d092bc9169"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.purewhite.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":true,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"ZP9482CZD3","apiKey":"d26207a3ce8de9fe98e7af4215425c93","indexName":"Blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="缘起这几天在重构某段代码后，做了一次性能测试，火焰图中发现了一个十分奇怪的runtime.newobject的调用，大致占用2%，而找遍了整段代码都没有发现有新建对象相关的逻辑。于是迫不得已，祭出了汇编大法，终于定位到了问题所在。这篇文章会使用一段最小可复现的代码来分享这个问题以及背后的原因。"><meta property="og:type" content="article"><meta property="og:title" content="为什么 Golang 函数赋值会产生内存分配？"><meta property="og:url" content="https://www.purewhite.io/2020/06/30/golang-indirect-function-allocate/index.html"><meta property="og:site_name" content="Pure White"><meta property="og:description" content="缘起这几天在重构某段代码后，做了一次性能测试，火焰图中发现了一个十分奇怪的runtime.newobject的调用，大致占用2%，而找遍了整段代码都没有发现有新建对象相关的逻辑。于是迫不得已，祭出了汇编大法，终于定位到了问题所在。这篇文章会使用一段最小可复现的代码来分享这个问题以及背后的原因。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://static.purewhite.io/uPic/2020-06-30/u4KRrc-006Cmetyly1ff16b3zxvxj308408caa8.jpg!webp_90"><meta property="og:image" content="https://static.purewhite.io/uPic/2020-06-30/LMj4f9-image.png!webp_90"><meta property="og:image" content="https://static.purewhite.io/uPic/2020-06-30/dkSyuM-image-20200630183251856.png!webp_90"><meta property="article:published_time" content="2020-06-30T03:05:51.000Z"><meta property="article:modified_time" content="2021-12-02T12:51:07.226Z"><meta property="article:author" content="Pure White"><meta property="article:tag" content="后端"><meta property="article:tag" content="go"><meta property="article:tag" content="asm"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://static.purewhite.io/uPic/2020-06-30/u4KRrc-006Cmetyly1ff16b3zxvxj308408caa8.jpg!webp_90"><link rel="canonical" href="https://www.purewhite.io/2020/06/30/golang-indirect-function-allocate/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.purewhite.io/2020/06/30/golang-indirect-function-allocate/","path":"2020/06/30/golang-indirect-function-allocate/","title":"为什么 Golang 函数赋值会产生内存分配？"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>为什么 Golang 函数赋值会产生内存分配？ | Pure White</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98194081-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-98194081-1","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?587d2548655f9855727225afb0e4d708"></script><script async src="//assets.growingio.com/2.1/gio.js"></script><script class="next-config" data-name="growingio_analytics" type="application/json">"8a8c3a537a0132ac"</script><script src="/js/third-party/analytics/growingio.js"></script><script type="text/javascript">!function(t,e,n,a,c,s,i){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(s=e.createElement(a)).async=1,s.src="https://www.clarity.ms/tag/8mh5xasia9",(i=e.getElementsByTagName(a)[0]).parentNode.insertBefore(s,i)}(window,document,"clarity","script")</script><script>!function(){var e=document.createElement("script");e.src="https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?c75fd468cb92e13256468f9ae3917db97049a5a91566914dbb6ab879288745b8bc434964556b7d7129e9b750ed197d397efd7b0c6c715c1701396e1af40cec962b8d7c8c6655c9b00211740aa8a98e2e",e.id="ttzz";var c=document.getElementsByTagName("script")[0];c.parentNode.insertBefore(e,c)}(window)</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Pure White" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="Pure White" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Pure White</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">主业写bug，副业debug</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%98%E8%B5%B7"><span class="nav-number">1.</span> <span class="nav-text">缘起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Show-me-the-code"><span class="nav-number">2.</span> <span class="nav-text">Show me the code</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%98%E8%83%BD%E9%80%83%E9%80%B8%E5%88%B0%E5%A0%86%E4%B8%8A%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">函数还能逃逸到堆上？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%94%A4%E4%BA%86"><span class="nav-number">4.</span> <span class="nav-text">实锤了</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Golang-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">Golang 函数调用机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%88%86%E7%B1%BB"><span class="nav-number">5.1.</span> <span class="nav-text">函数调用分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%97%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.</span> <span class="nav-text">函数间接调用实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%95%A5%E8%A6%81%E8%BF%99%E4%B9%88%E5%B9%B2%E5%91%A2%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">为啥要这么干呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%BA%86%E9%82%A3%E4%B9%88%E5%A4%9A%EF%BC%8C%E5%88%B0%E5%BA%95%E4%B8%BA%E5%95%A5%E5%91%A2%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">说了那么多，到底为啥呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Pure White" src="https://static.purewhite.io/avatar.jpg!webp_90"><p class="site-author-name" itemprop="name">Pure White</p><div class="site-description" itemprop="description">青春不是年华，是心境；<br>青春不是桃面、丹唇、柔膝，<br>而是深沉的意志、恢弘的想象、<br>炽热的感情。</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">29</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/PureWhiteWu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PureWhiteWu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:me@purewhite.io" title="E-Mail → mailto:me@purewhite.io" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://twitter.com/PureWhite_Wu" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;PureWhite_Wu" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i> Twitter</a></span><span class="links-of-author-item"><a href="https://www.linkedin.com/in/%E8%BF%AA-%E5%90%B4-846051106/" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;%E8%BF%AA-%E5%90%B4-846051106&#x2F;" rel="noopener me" target="_blank"><i class="fa fa-linkedin fa-fw"></i> LinkedIn</a></span><span class="links-of-author-item"><a href="https://telegram.me/PureWhiteWu" title="Telegram → https:&#x2F;&#x2F;telegram.me&#x2F;PureWhiteWu" rel="noopener me" target="_blank"><i class="fa fa-telegram fa-fw"></i> Telegram</a></span><span class="links-of-author-item"><a href="http://weibo.com/purewhitewu" title="微博 → http:&#x2F;&#x2F;weibo.com&#x2F;purewhitewu" rel="noopener me" target="_blank"><i class="fa fa-weibo fa-fw"></i> 微博</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/PureWhite_Wu" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;PureWhite_Wu" rel="noopener me" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://static.purewhite.io/wechat_channel.jpg" title="微信 → https:&#x2F;&#x2F;static.purewhite.io&#x2F;wechat_channel.jpg" rel="noopener me" target="_blank"><i class="fa fa-weixin fa-fw"></i> 微信</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://blog.didispace.com/" title="http:&#x2F;&#x2F;blog.didispace.com&#x2F;" rel="noopener" target="_blank">程序猿DD</a></li><li class="links-of-blogroll-item"> <a href="http://www.v2ex.com/?r=PureWhiteWu" title="http:&#x2F;&#x2F;www.v2ex.com&#x2F;?r&#x3D;PureWhiteWu" rel="noopener" target="_blank">v2ex</a></li><li class="links-of-blogroll-item"> <a href="https://yuzhouwan.com/" title="https:&#x2F;&#x2F;yuzhouwan.com&#x2F;" rel="noopener" target="_blank">宇宙湾</a></li><li class="links-of-blogroll-item"> <a href="https://pengrl.com/" title="https:&#x2F;&#x2F;pengrl.com&#x2F;" rel="noopener" target="_blank">yoko blog</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.purewhite.io/2020/06/30/golang-indirect-function-allocate/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://static.purewhite.io/avatar.jpg!webp_90"><meta itemprop="name" content="Pure White"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Pure White"><meta itemprop="description" content="青春不是年华，是心境；<br />青春不是桃面、丹唇、柔膝，<br />而是深沉的意志、恢弘的想象、<br />炽热的感情。"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="为什么 Golang 函数赋值会产生内存分配？ | Pure White"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 为什么 Golang 函数赋值会产生内存分配？</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-06-30 11:05:51" itemprop="dateCreated datePublished" datetime="2020-06-30T11:05:51+08:00">2020-06-30</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-12-02 20:51:07" itemprop="dateModified" datetime="2021-12-02T20:51:07+08:00">2021-12-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a></span></span><span id="/2020/06/30/golang-indirect-function-allocate/" class="post-meta-item leancloud_visitors" data-flag-title="为什么 Golang 函数赋值会产生内存分配？" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Disqus：</span><a title="disqus" href="/2020/06/30/golang-indirect-function-allocate/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/30/golang-indirect-function-allocate/" itemprop="commentCount"></span></a></span><span class="post-meta-break"></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>2.4k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>这几天在重构某段代码后，做了一次性能测试，火焰图中发现了一个十分奇怪的<code>runtime.newobject</code>的调用，大致占用2%，而找遍了整段代码都没有发现有新建对象相关的逻辑。于是迫不得已，祭出了汇编大法，终于定位到了问题所在。这篇文章会使用一段最小可复现的代码来分享这个问题以及背后的原因。</p><span id="more"></span><h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myFuncImplStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myFuncImplStruct)</span></span> myFunc() &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m myFuncImplStruct)</span></span> myFunc2() &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myFuncContainer <span class="keyword">struct</span> &#123;</span><br><span class="line">	f MyFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFuncContainer</span><span class="params">(f MyFunc)</span></span> *myFuncContainer &#123;</span><br><span class="line">	n := &amp;myFuncContainer&#123;&#125;</span><br><span class="line">	n.f = f</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := &amp;myFuncImplStruct&#123;&#125;</span><br><span class="line">	m2 := myFuncImplStruct&#123;&#125;</span><br><span class="line">	c1 := newFuncContainer(myFunc)</span><br><span class="line">	c2 := newFuncContainer(m.myFunc)</span><br><span class="line">	c3 := newFuncContainer(m2.myFunc2)</span><br><span class="line"></span><br><span class="line">	_, _, _ = c1, c2, c3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，初看起来貌似在 main 函数中（不考虑 newFuncContainer 函数中导致的内存分配）没有运行时内存分配（m 会被优化成全局区，所以不会真的导致运行时内存分配），但是实际上在 main 中是有两次运行时内存分配的，这是怎么回事呢？</p><h2 id="函数还能逃逸到堆上？"><a href="#函数还能逃逸到堆上？" class="headerlink" title="函数还能逃逸到堆上？"></a>函数还能逃逸到堆上？</h2><p>我们用<code>-gcflags=&quot;-m&quot;</code>来打印一下编译器的优化信息，可以看到：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">13</span>:<span class="number">7</span>: m does not escape</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">32</span>:<span class="number">23</span>: leaking param: f</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">33</span>:<span class="number">7</span>: &amp;myFuncContainer literal escapes to heap</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">39</span>:<span class="number">7</span>: &amp;myFuncImplStruct literal escapes to heap</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">42</span>:<span class="number">26</span>: m<span class="selector-class">.myFunc</span> escapes to heap</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">43</span>:<span class="number">27</span>: m2<span class="selector-class">.myFunc2</span> escapes to heap</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: <span class="selector-class">.this</span> does not escape</span><br></pre></td></tr></table></figure><p>竟然说 42、43 两行中的<code>m.myFunc</code>和<code>m2.myFunc2</code>“逃逸到了堆上”？一个函数还能逃逸到堆上？？？</p><p><img data-src="https://static.purewhite.io/uPic/2020-06-30/u4KRrc-006Cmetyly1ff16b3zxvxj308408caa8.jpg!webp_90"></p><h2 id="实锤了"><a href="#实锤了" class="headerlink" title="实锤了"></a>实锤了</h2><p>虽然看起来貌似真的是这里导致的，但是我们说话做事要有证据，于是祭出汇编大法（<code>-gcflags=&quot;-S&quot;</code>），看一下生成的汇编代码是啥样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.main STEXT size=160 args=0x0 locals=0x18</span><br><span class="line">	……</span><br><span class="line">	0x0031 00049 (main.go:42)	PCDATA	$0, $1</span><br><span class="line">	0x0031 00049 (main.go:42)	LEAQ	type.noalg.struct &#123; F uintptr; R *&quot;&quot;.myFuncImplStruct &#125;(SB), AX</span><br><span class="line">	0x0038 00056 (main.go:42)	PCDATA	$0, $0</span><br><span class="line">	0x0038 00056 (main.go:42)	MOVQ	AX, (SP)</span><br><span class="line">	0x003c 00060 (main.go:42)	CALL	runtime.newobject(SB)</span><br><span class="line">	0x0041 00065 (main.go:42)	PCDATA	$0, $1</span><br><span class="line">	0x0041 00065 (main.go:42)	MOVQ	8(SP), AX</span><br><span class="line">	0x0046 00070 (main.go:42)	LEAQ	&quot;&quot;.(*myFuncImplStruct).myFunc-fm(SB), CX</span><br><span class="line">	0x004d 00077 (main.go:42)	MOVQ	CX, (AX)</span><br><span class="line">	0x0050 00080 (main.go:42)	PCDATA	$0, $2</span><br><span class="line">	0x0050 00080 (main.go:42)	LEAQ	runtime.zerobase(SB), CX</span><br><span class="line">	0x0057 00087 (main.go:42)	PCDATA	$0, $1</span><br><span class="line">	0x0057 00087 (main.go:42)	MOVQ	CX, 8(AX)</span><br><span class="line">	0x005b 00091 (main.go:42)	PCDATA	$0, $0</span><br><span class="line">	0x005b 00091 (main.go:42)	MOVQ	AX, (SP)</span><br><span class="line">	0x005f 00095 (main.go:42)	CALL	&quot;&quot;.newFuncContainer(SB)</span><br><span class="line">	0x0064 00100 (main.go:43)	PCDATA	$0, $1</span><br><span class="line">	0x0064 00100 (main.go:43)	LEAQ	type.noalg.struct &#123; F uintptr; R &quot;&quot;.myFuncImplStruct &#125;(SB), AX</span><br><span class="line">	0x006b 00107 (main.go:43)	PCDATA	$0, $0</span><br><span class="line">	0x006b 00107 (main.go:43)	MOVQ	AX, (SP)</span><br><span class="line">	0x006f 00111 (main.go:43)	CALL	runtime.newobject(SB)</span><br><span class="line">	0x0074 00116 (main.go:43)	PCDATA	$0, $1</span><br><span class="line">	0x0074 00116 (main.go:43)	MOVQ	8(SP), AX</span><br><span class="line">	0x0079 00121 (main.go:43)	LEAQ	&quot;&quot;.myFuncImplStruct.myFunc2-fm(SB), CX</span><br><span class="line">	0x0080 00128 (main.go:43)	MOVQ	CX, (AX)</span><br><span class="line">	0x0083 00131 (main.go:43)	PCDATA	$0, $0</span><br><span class="line">	0x0083 00131 (main.go:43)	MOVQ	AX, (SP)</span><br><span class="line">	0x0087 00135 (main.go:43)	CALL	&quot;&quot;.newFuncContainer(SB)</span><br><span class="line">	……</span><br></pre></td></tr></table></figure><p>这下子实锤了，真的是这里导致的，但是为啥呢？我把一个函数赋值给某个变量，为什么会导致一次内存分配呢？函数名不是一个指针，指向函数所在的代码地址么？</p><h2 id="Golang-函数调用机制"><a href="#Golang-函数调用机制" class="headerlink" title="Golang 函数调用机制"></a>Golang 函数调用机制</h2><p>在 Golang 中，函数调用其实并不像 C 那么简单，有一定的分类：</p><h3 id="函数调用分类"><a href="#函数调用分类" class="headerlink" title="函数调用分类"></a>函数调用分类</h3><p>在 Go 中，一共有 4 种类型的函数：</p><ol><li>顶层函数（普通的函数）</li><li>有值接收者的函数</li><li>有指针接收者的函数</li><li>函数字面量</li></ol><p>有 5 种类型的函数调用：</p><ol><li>直接调用顶层函数</li><li>直接调用有值接收者的函数</li><li>直接调用有指针接收者的函数</li><li>间接调用函数值（func value）</li><li>间接调用 interface 中函数</li></ol><p>以下的示例程序展示了所有可能的函数调用方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TopLevel</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pointer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Pointer)</span></span> M(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Value)</span></span> M(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span>&#123; M(<span class="type">int</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> literal = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// direct call of top-level func</span></span><br><span class="line">	TopLevel(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// direct call of method with value receiver (two spellings, but same)</span></span><br><span class="line">	<span class="keyword">var</span> v Value</span><br><span class="line">	v.M(<span class="number">1</span>)</span><br><span class="line">	Value.M(v, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// direct call of method with pointer receiver (two spellings, but same)</span></span><br><span class="line">	<span class="keyword">var</span> p Pointer</span><br><span class="line">	(&amp;p).M(<span class="number">1</span>)</span><br><span class="line">	(*Pointer).M(&amp;p, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// indirect call of func value (×4)</span></span><br><span class="line">	f1 := TopLevel</span><br><span class="line">	f1(<span class="number">1</span>)</span><br><span class="line">	f2 := Value.M</span><br><span class="line">	f2(v, <span class="number">1</span>)</span><br><span class="line">	f3 := (*Pointer).M</span><br><span class="line">	f3(&amp;p, <span class="number">1</span>)</span><br><span class="line">	f4 := literal</span><br><span class="line">	f4(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// indirect call of method on interface (×3)</span></span><br><span class="line">	<span class="keyword">var</span> i Interface</span><br><span class="line">	i = v</span><br><span class="line">	i.M(<span class="number">1</span>)</span><br><span class="line">	i = &amp;v</span><br><span class="line">	i.M(<span class="number">1</span>)</span><br><span class="line">	i = &amp;p</span><br><span class="line">	i.M(<span class="number">1</span>)</span><br><span class="line">	Interface.M(i, <span class="number">1</span>)</span><br><span class="line">	Interface.M(v, <span class="number">1</span>)</span><br><span class="line">	Interface.M(&amp;p, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上程序所示，一共有 10 种可能的调用组合：</p><ol><li>直接调用顶层函数 &#x2F;</li><li>直接调用值接收者函数 &#x2F;</li><li>直接调用指针接收者函数 &#x2F;</li><li>间接调用函数值（func value） &#x2F; 函数值为顶层函数</li><li>间接调用函数值 &#x2F; 函数值为值接收者函数</li><li>间接调用函数值 &#x2F; 函数值为指针接收者函数</li><li>间接调用函数值 &#x2F; 函数值函数字面量</li><li>间接调用 interface 中函数 &#x2F; interface 为值，调用值接收者函数</li><li>间接调用 interface 中函数 &#x2F; interface 为指针，调用值接收者函数</li><li>间接调用 interface 中函数 &#x2F; interface 为指针，调用指针接收者函数</li></ol><p>以上列表中，斜杠 &#x2F; 左侧是在编译时就已知的信息，右侧是在运行时才知道的信息。在编译时生成的代码是不知道运行时的信息的，所以在运行时需要生成一些额外的适配器函数（adapter functions）来达成间接调用。</p><h3 id="函数间接调用实现"><a href="#函数间接调用实现" class="headerlink" title="函数间接调用实现"></a>函数间接调用实现</h3><p>看到这里，大家应该能隐约猜测到原因了，正如你所猜测，在我们开头的程序中，存在着间接调用，Go 分配的这个对象和间接调用脱不了关系。由于直接调用没啥可说的，所以我们略过不谈，只说间接调用。</p><p>在 Go 里面，间接调用的实现如下图：</p><p><img data-src="https://static.purewhite.io/uPic/2020-06-30/LMj4f9-image.png!webp_90"></p><p>实际上，Go 分配了一个额外的对象，其第一个字段是一个指向我们真实函数的指针，第二个对象是与函数强相关的一些数据（对，没错，说的就是接收者 receiver）。于是，一次函数调用实际上会生成类似如下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV …, R0</span><br><span class="line">MOV 0(R0), R1</span><br><span class="line">CALL R1  # called code can access “data” using R0</span><br></pre></td></tr></table></figure><p>有一个例外，就是当一个函数并没有相关数据，如仅仅会捕获外部的局部变量的函数字面量，那么这个函数就不会有相关联的数据，于是内存布局如下：</p><p><img data-src="https://static.purewhite.io/uPic/2020-06-30/dkSyuM-image-20200630183251856.png!webp_90"></p><p>在这个场景下，Go 会将这个变量的分配优化在只读区，不会在每次调用时都进行分配，也就是生成如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV $MyFunc·f(SB), f1</span><br><span class="line"></span><br><span class="line">DATA MyFunc·f(SB)/8, $MyFunc(SB)</span><br><span class="line">GLOBL MyFunc·f(SB), 10, $8</span><br></pre></td></tr></table></figure><p>所以我们其实不必太过担心这种场景下的性能损耗，在这种场景下是 0 损耗的。</p><p>对于非例外的场景，一个适配器函数生成的代码类似下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> funcValue <span class="keyword">struct</span> &#123;</span><br><span class="line">	f <span class="type">uintptr</span> <span class="comment">// 指向函数的指针</span></span><br><span class="line">	r associatedType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里为实际函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcAdapter</span><span class="params">(...)</span></span> (...) &#123;</span><br><span class="line">	r := (associatedType)(R0 + <span class="number">8</span>)</span><br><span class="line">	<span class="keyword">return</span> r.f(...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := &amp;funcValue&#123;funcAdapter, r&#125;</span><br></pre></td></tr></table></figure><p>在调用时，调用的实际上是适配器函数，适配器函数随后去调用真实的函数。</p><h3 id="为啥要这么干呢？"><a href="#为啥要这么干呢？" class="headerlink" title="为啥要这么干呢？"></a>为啥要这么干呢？</h3><p>其实想想也很简单，对于值接收者和指针接收者函数，调用时第一个参数为 self，那么如果我现在是需要把某个关联在特定值 &#x2F; 指针上的函数作为一个函数值赋值给某个函数变量时，我也需要一起把对应的值 &#x2F; 指针信息一起带上，不然等我真正调用的时候，我怎么知道应该调用的是哪个值 &#x2F; 指针上的方法呢？也就是说，传入函数的 self 值应该是多少呢？</p><h2 id="说了那么多，到底为啥呢？"><a href="#说了那么多，到底为啥呢？" class="headerlink" title="说了那么多，到底为啥呢？"></a>说了那么多，到底为啥呢？</h2><p>回到我们开头的问题，可以看到造成两次内存分配的罪魁祸首已然找到，在汇编代码里面其实也已经能看出端倪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 0x0031 00049 (main.go:42)	PCDATA	$0, $1</span><br><span class="line">0x0031 00049 (main.go:42)	LEAQ	type.noalg.struct &#123; F uintptr; R *&quot;&quot;.myFuncImplStruct &#125;(SB), AX</span><br><span class="line">0x0038 00056 (main.go:42)	PCDATA	$0, $0</span><br><span class="line">0x0038 00056 (main.go:42)	MOVQ	AX, (SP)</span><br><span class="line">0x003c 00060 (main.go:42)	CALL	runtime.newobject(SB)</span><br><span class="line">0x0041 00065 (main.go:42)	PCDATA	$0, $1</span><br><span class="line">0x0041 00065 (main.go:42)	MOVQ	8(SP), AX</span><br><span class="line">0x0046 00070 (main.go:42)	LEAQ	&quot;&quot;.(*myFuncImplStruct).myFunc-fm(SB), CX</span><br><span class="line">0x004d 00077 (main.go:42)	MOVQ	CX, (AX)</span><br><span class="line">0x0050 00080 (main.go:42)	PCDATA	$0, $2</span><br><span class="line">0x0050 00080 (main.go:42)	LEAQ	runtime.zerobase(SB), CX</span><br><span class="line">0x0057 00087 (main.go:42)	PCDATA	$0, $1</span><br><span class="line">0x0057 00087 (main.go:42)	MOVQ	CX, 8(AX)</span><br><span class="line">0x005b 00091 (main.go:42)	PCDATA	$0, $0</span><br><span class="line">0x005b 00091 (main.go:42)	MOVQ	AX, (SP)</span><br><span class="line">0x005f 00095 (main.go:42)	CALL	&quot;&quot;.newFuncContainer(SB)</span><br><span class="line">0x0064 00100 (main.go:43)	PCDATA	$0, $1</span><br><span class="line">0x0064 00100 (main.go:43)	LEAQ	type.noalg.struct &#123; F uintptr; R &quot;&quot;.myFuncImplStruct &#125;(SB), AX</span><br><span class="line">0x006b 00107 (main.go:43)	PCDATA	$0, $0</span><br><span class="line">0x006b 00107 (main.go:43)	MOVQ	AX, (SP)</span><br><span class="line">0x006f 00111 (main.go:43)	CALL	runtime.newobject(SB)</span><br><span class="line">0x0074 00116 (main.go:43)	PCDATA	$0, $1</span><br><span class="line">0x0074 00116 (main.go:43)	MOVQ	8(SP), AX</span><br><span class="line">0x0079 00121 (main.go:43)	LEAQ	&quot;&quot;.myFuncImplStruct.myFunc2-fm(SB), CX</span><br><span class="line">0x0080 00128 (main.go:43)	MOVQ	CX, (AX)</span><br><span class="line">0x0083 00131 (main.go:43)	PCDATA	$0, $0</span><br><span class="line">0x0083 00131 (main.go:43)	MOVQ	AX, (SP)</span><br><span class="line">0x0087 00135 (main.go:43)	CALL	&quot;&quot;.newFuncContainer(SB)</span><br></pre></td></tr></table></figure><p>注意上述 <code>LEAQ type.noalg.struct &#123; F uintptr; R *&quot;&quot;.myFuncImplStruct &#125;(SB), AX</code>这段代码，咱也别管啥意思，反正看到了一个和之前说的适配器很像的一个 struct，这个 struct 有两个字段，第一个是<code>F uintptr</code>，第二个是<code>R *myFuncImplStruct</code>；下面还有一个<code>LEAQ type.noalg.struct &#123; F uintptr; R &quot;&quot;.myFuncImplStruct &#125;(SB), AX</code>，只不过这里的 R 是<code>myFuncImplStruct</code>的值而不是指针，这正好和我们代码吻合。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这基本上这个问题清楚了，要优化的话也很简单，只要把实际上并不需要有值接收者或者指针接收者的函数改为顶层函数即可，或者尽可能不要将一个值接收者 &#x2F; 指针接收者函数进行间接调用。</p><p>由此可以看出，有接收者的函数是有代价的，不能乱用啊，代码设计还是要合理，否则是会引入额外的性能开销的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1bMwCey-gmqZVTpRax-ESeVuZGmjwbocYs1iHplK-cjo/pub">https://docs.google.com/document/d/1bMwCey-gmqZVTpRax-ESeVuZGmjwbocYs1iHplK-cjo/pub</a></li></ol></div><footer class="post-footer"><div class="reward-container"><div>请博主喝杯咖啡~</div> <button> 赞赏</button><div class="post-reward"><div> <img src="https://static.purewhite.io/wechat_pay.jpeg" alt="Pure White 微信"> <span>微信</span></div><div> <img src="https://static.purewhite.io/alipay.jpeg" alt="Pure White 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Pure White</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.purewhite.io/2020/06/30/golang-indirect-function-allocate/" title="为什么 Golang 函数赋值会产生内存分配？">https://www.purewhite.io/2020/06/30/golang-indirect-function-allocate/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"> <span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://static.purewhite.io/wechat_channel.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-tags"> <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a> <a href="/tags/go/" rel="tag"># go</a> <a href="/tags/asm/" rel="tag"># asm</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2019/11/28/runtime-hacking-translate/" rel="prev" title="golang 在 runtime 中的一些骚东西"><i class="fa fa-chevron-left"></i> golang 在 runtime 中的一些骚东西</a></div><div class="post-nav-item"> <a href="/2020/08/24/golang-sync-map-keys-never-delete/" rel="next" title="踩了 Golang sync.Map 的一个坑">踩了 Golang sync.Map 的一个坑<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">沪ICP备15051443号-3</a> <img src="https://static.purewhite.io/images/2019-10-30-%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31010602004105" rel="noopener" target="_blank">沪公网安备 31010602004105号</a></div><div class="copyright"> &copy; 2017 – <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Pure White</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span title="站点总字数">92k</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">5:34</span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/PureWhiteWu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.17.1/algoliasearch-lite.umd.js" integrity="sha256-F7emIId74fYoGrHzsnu3iClRHIbBMhMCbxDoA1cfMAY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.56.1/instantsearch.production.min.js" integrity="sha256-lz9C+x8+6w2rh56x5TrH5iYmE4Js2FiJS5h0tuMz7hQ=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.2.0/wavedrom.min.js","integrity":"sha256-cOqJCt2rKQA4GNjlL0tODFHnWd0CRLKLFqYhO6TCtAE="}}</script><script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.2.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script><script src="/js/third-party/tags/wavedrom.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"GnBUFiou8SXNzMY8SKVSPw6z-9Nh9j0Va","app_key":"SHesuNBbuyni9gG2gJlHAd6E","server_url":"https://leancloud.purewhite.io","security":true}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"ignores":null,"url":"https://www.purewhite.io/2020/06/30/golang-indirect-function-allocate/"}</script><script src="/js/third-party/quicklink.js"></script><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"blog-zr0zqnlt9p","count":true,"i18n":{"disqus":"disqus"}}</script><script src="/js/third-party/comments/disqus.js"></script></body></html>
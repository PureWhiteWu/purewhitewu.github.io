<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pure White</title>
  
  <subtitle>主业写bug，副业debug</subtitle>
  <link href="https://www.purewhite.io/atom.xml" rel="self"/>
  
  <link href="https://www.purewhite.io/"/>
  <updated>2022-03-15T17:33:07.693Z</updated>
  <id>https://www.purewhite.io/</id>
  
  <author>
    <name>Pure White</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给大家推荐一个 B 站宝藏 up 主 —— BiBiPiano</title>
    <link href="https://www.purewhite.io/2022/03/16/bibipiano-recommend/"/>
    <id>https://www.purewhite.io/2022/03/16/bibipiano-recommend/</id>
    <published>2022-03-15T17:23:00.000Z</published>
    <updated>2022-03-15T17:33:07.693Z</updated>
    
    <content type="html"><![CDATA[<p>今天想发一点和技术无关的内容，毕竟生活中也不全是工作嘛😊。</p><p>关注这个 up 主已经很久了，已经经过了很长时间的检验，在这里也推荐给大家。</p><p>这个 up 主发的所有曲子我都会第一时间听。</p><p>另外，记得一定要看简介，一定要看简介，一定要看简介！</p><span id="more"></span><p>这里我尝试使用嵌入代码给大家推荐三首曲子，不过推荐大家跳转到原页面，一边看简介一边听。</p><h1 id="卡农（必听）"><a href="#卡农（必听）" class="headerlink" title="卡农（必听）"></a>卡农（必听）</h1><iframe src="//player.bilibili.com/player.html?aid=63771647&bvid=BV1L4411U7Fj&cid=110717051&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="风居住的街道"><a href="#风居住的街道" class="headerlink" title="风居住的街道"></a>风居住的街道</h1><iframe src="//player.bilibili.com/player.html?aid=68436693&bvid=BV1xJ411u76b&cid=118609878&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="可惜不是你"><a href="#可惜不是你" class="headerlink" title="可惜不是你"></a>可惜不是你</h1><iframe src="//player.bilibili.com/player.html?aid=371290548&bvid=BV1VZ4y1u7qy&cid=212569521&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天想发一点和技术无关的内容，毕竟生活中也不全是工作嘛😊。&lt;/p&gt;
&lt;p&gt;关注这个 up 主已经很久了，已经经过了很长时间的检验，在这里也推荐给大家。&lt;/p&gt;
&lt;p&gt;这个 up 主发的所有曲子我都会第一时间听。&lt;/p&gt;
&lt;p&gt;另外，记得一定要看简介，一定要看简介，一定要看简介！&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://www.purewhite.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.purewhite.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="心得" scheme="https://www.purewhite.io/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>Rustc Reading Club：从一个错误出发学习 rustc_resolve</title>
    <link href="https://www.purewhite.io/2021/11/07/rustc-resolve-reading-defined-multiple-times/"/>
    <id>https://www.purewhite.io/2021/11/07/rustc-resolve-reading-defined-multiple-times/</id>
    <published>2021-11-07T07:38:31.000Z</published>
    <updated>2021-12-02T12:51:07.230Z</updated>
    
    <content type="html"><![CDATA[<p>最近 Rust 官方社区搞了个 Rustc Reading Club 的活动，由编译器 team 的 Leader Niko 发起，具体网址在这里：<a href="https://rust-lang.github.io/rustc-reading-club/">https://rust-lang.github.io/rustc-reading-club/</a></p><p>很可惜的是，11 月 4 日的第一期，由于太过火爆并且 Zoom 人数限制 100 人，导致主持人 Niko 自己进不来所以取消了……等待看看官方后续会怎么搞吧，还是很期待官方组织的活动的。</p><p>Rust 中文社群的张汉东大佬也紧跟着官方的活动，在社群里面组织了 Rustc 源码阅读的活动，今天（11 月 7 日）举办了第一期，在这期中我跟着吴翱翔大佬的思路，从一个错误出发，学习了一部分 rustc_resolve 的逻辑，于是想着写一篇博客总结一下。</p><p>【小广告】下一期 11 月 14 日下午会由刘翼飞大佬带领大家一起去阅读类型推导相关的代码，有兴趣的同学可以下载<a href="https://www.feishu.cn/">飞书</a>，注册一个个人账号，然后扫描二维码加入：</p><span id="more"></span><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107173520665-Xcw2lU.png!webp_90" alt="Rust 中文社群" style="zoom: 25%;" /><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>言归正传，在阅读 Rustc 源代码之前，我们需要先做一些准备工作，主要是先 clone 下来 Rust 的代码，然后配置好 IDE（虽然但是，Clion 到现在正式版还不支持远程，EAP 又各种 bug……），具体可以参考官方的 guide：<a href="https://rustc-dev-guide.rust-lang.org/getting-started.html%E3%80%82%E8%B7%9F%E7%9D%80%E8%BF%99%E7%AB%A0%E5%81%9A%E5%AE%8C%E5%B0%B1%E8%A1%8C%EF%BC%9Ahttps://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html%E3%80%82">https://rustc-dev-guide.rust-lang.org/getting-started.html。跟着这章做完就行：https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html。</a></p><h1 id="从错误出发"><a href="#从错误出发" class="headerlink" title="从错误出发"></a>从错误出发</h1><p>这次我们的阅读主要的对象是<code>rustc_resolve</code>，顾名思义应该是做名称解析的，更加详细的信息可以来这瞅一眼：<a href="https://rustc-dev-guide.rust-lang.org/name-resolution.html%E3%80%82">https://rustc-dev-guide.rust-lang.org/name-resolution.html。</a></p><p>我们打开<code>rustc_resolve</code>的<code>lib.rs</code>一看，妈呀，光这个文件就接近 4000 行代码，直接这么硬看肯定不现实；不过吴翱翔大佬提出了一个思路：从一个我们最常见的错误<code>the name xx is defined multiple times</code>出发，顺着这条路去学习一下相关的代码。</p><p>这是一个很好的办法，当你不知道从哪入手的时候，你可以构造一个场景，由点切入，最终由点及面看完所有代码。</p><p>废话少说，我们先祭出搜索大法，在<code>rustc_resolve</code>里面搜一下这个错误是在哪出现的：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107184148779-Rk3CR3.png!webp_90" alt="查找这个错误" style="zoom:50%;" /><p>非常巧，正好就在<code>rustc_resolve</code>的<code>lib.rs</code>中，于是我们跳转过去，发现确实是这个我们想找的错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="built_in">format!</span>(<span class="string">&quot;the name `&#123;&#125;` is defined multiple times&quot;</span>, name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> err = <span class="keyword">match</span> (old_binding.is_extern_crate(), new_binding.is_extern_crate()) &#123;</span><br><span class="line">    (<span class="literal">true</span>, <span class="literal">true</span>) =&gt; struct_span_err!(<span class="keyword">self</span>.session, span, E0259, <span class="string">&quot;&#123;&#125;&quot;</span>, msg),</span><br><span class="line">    (<span class="literal">true</span>, _) | (_, <span class="literal">true</span>) =&gt; <span class="keyword">match</span> new_binding.is_import() &amp;&amp; old_binding.is_import() &#123;</span><br><span class="line">        <span class="literal">true</span> =&gt; struct_span_err!(<span class="keyword">self</span>.session, span, E0254, <span class="string">&quot;&#123;&#125;&quot;</span>, msg),</span><br><span class="line">        <span class="literal">false</span> =&gt; struct_span_err!(<span class="keyword">self</span>.session, span, E0260, <span class="string">&quot;&#123;&#125;&quot;</span>, msg),</span><br><span class="line">    &#125;,</span><br><span class="line">    _ =&gt; <span class="keyword">match</span> (old_binding.is_import(), new_binding.is_import()) &#123;</span><br><span class="line">        (<span class="literal">false</span>, <span class="literal">false</span>) =&gt; struct_span_err!(<span class="keyword">self</span>.session, span, E0428, <span class="string">&quot;&#123;&#125;&quot;</span>, msg),</span><br><span class="line">        (<span class="literal">true</span>, <span class="literal">true</span>) =&gt; struct_span_err!(<span class="keyword">self</span>.session, span, E0252, <span class="string">&quot;&#123;&#125;&quot;</span>, msg),</span><br><span class="line">        _ =&gt; struct_span_err!(<span class="keyword">self</span>.session, span, E0255, <span class="string">&quot;&#123;&#125;&quot;</span>, msg),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所在的这个函数名也正好是<code>report_conflict</code>，完美！</p><p>让我们接着看看这个函数在哪被调用到了：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107184650136-uds41e.png!webp_90" alt="report_conflict" style="zoom:67%;" /><p>这个函数除了定义外，被调用到了两次，其中下面这次是在自己函数内部递归调用，我们直接无视掉；还有一次是在<code>build_reduced_graph.rs</code>中，让我们跟着去看看：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107184758563-03lWsz.png!webp_90" alt="build_reduced_graph.rs" style="zoom:67%;" /><p>在这里是被<code>define</code>方法调用到，看着很符合预期，看来我们找对地方了。</p><p>这段代码先通过<code>to_name_binding</code>方法把传入的<code>def</code>转换成一个<code>NameBinding</code>，让我们看看这段干了啥：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107185222063-iGSng1.png!webp_90" alt="NameBinding" style="zoom:67%;" /><p><code>NameBinding</code>是一个记录了一个值、类型或者模块定义的结构体，其中<code>kind</code>我们大胆猜测是类型，<code>ambiguity</code>看不懂先放着，<code>expansion</code>也是（如果看过 rustc-dev-guide 能大致知道是和卫生宏展开有关，这里我们也先无视），然后是<code>span</code>也不知道干啥的，点进去研究下感觉和增量编译有关，也先放着，最后<code>vis</code>估摸着应该表示的是可见性。</p><p>然后我们再点<code>ResolverArenas</code>看看是干啥的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Nothing really interesting here; it just provides memory for the rest of the crate.</span></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ResolverArenas</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，好，没啥值得关注的，只是用来提供内存的，直接无视。</p><p>我们再接着回到上面的<code>define</code>方法中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Resolver&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;</span></span><br><span class="line">    <span class="comment">/// otherwise, reports an error.</span></span><br><span class="line">    <span class="keyword">crate</span> <span class="function"><span class="keyword">fn</span> <span class="title">define</span></span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, parent: Module&lt;<span class="symbol">&#x27;a</span>&gt;, ident: Ident, ns: Namespace, def: T)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: ToNameBinding&lt;<span class="symbol">&#x27;a</span>&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> binding = def.to_name_binding(<span class="keyword">self</span>.arenas);</span><br><span class="line">        <span class="keyword">let</span> key = <span class="keyword">self</span>.new_key(ident, ns);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(old_binding) = <span class="keyword">self</span>.try_define(parent, key, binding) &#123;</span><br><span class="line">            <span class="keyword">self</span>.report_conflict(parent, ident, ns, old_binding, &amp;binding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二句<code>let key = self.new_key(ident, ns);</code>看着也没啥特殊的，就是根据当前所在的<code>namespace</code>给<code>ident</code>（表示标识符）新建一个<code>key</code>，那么 value 应该就是上面的<code>binding</code>了。</p><p>然后这里调用了<code>try_define</code>，如果返回了 Err 就调用<code>report_conflict</code>，让我们接着进入<code>try_define</code>看看（先不用仔细看）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define the name or return the existing binding if there is a collision.</span></span><br><span class="line"><span class="keyword">crate</span> <span class="function"><span class="keyword">fn</span> <span class="title">try_define</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    module: Module&lt;<span class="symbol">&#x27;a</span>&gt;,</span><br><span class="line">    key: BindingKey,</span><br><span class="line">    binding: &amp;<span class="symbol">&#x27;a</span> NameBinding&lt;<span class="symbol">&#x27;a</span>&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;(), &amp;<span class="symbol">&#x27;a</span> NameBinding&lt;<span class="symbol">&#x27;a</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> res = binding.res();</span><br><span class="line">    <span class="keyword">self</span>.check_reserved_macro_name(key.ident, res);</span><br><span class="line">    <span class="keyword">self</span>.set_binding_parent_module(binding, module);</span><br><span class="line">    <span class="keyword">self</span>.update_resolution(module, key, |this, resolution| &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_binding) = resolution.binding &#123;</span><br><span class="line">            <span class="keyword">if</span> res == Res::<span class="literal">Err</span> &#123;</span><br><span class="line">                <span class="comment">// Do not override real bindings with `Res::Err`s from error recovery.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Ok</span>(());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">match</span> (old_binding.is_glob_import(), binding.is_glob_import()) &#123;</span><br><span class="line">                (<span class="literal">true</span>, <span class="literal">true</span>) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> res != old_binding.res() &#123;</span><br><span class="line">                        resolution.binding = <span class="literal">Some</span>(this.ambiguity(</span><br><span class="line">                            AmbiguityKind::GlobVsGlob,</span><br><span class="line">                            old_binding,</span><br><span class="line">                            binding,</span><br><span class="line">                        ));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !old_binding.vis.is_at_least(binding.vis, &amp;*this) &#123;</span><br><span class="line">                        <span class="comment">// We are glob-importing the same item but with greater visibility.</span></span><br><span class="line">                        resolution.binding = <span class="literal">Some</span>(binding);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                (old_glob @ <span class="literal">true</span>, <span class="literal">false</span>) | (old_glob @ <span class="literal">false</span>, <span class="literal">true</span>) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> (glob_binding, nonglob_binding) =</span><br><span class="line">                        <span class="keyword">if</span> old_glob &#123; (old_binding, binding) &#125; <span class="keyword">else</span> &#123; (binding, old_binding) &#125;;</span><br><span class="line">                    <span class="keyword">if</span> glob_binding.res() != nonglob_binding.res()</span><br><span class="line">                        &amp;&amp; key.ns == MacroNS</span><br><span class="line">                        &amp;&amp; nonglob_binding.expansion != LocalExpnId::ROOT</span><br><span class="line">                    &#123;</span><br><span class="line">                        resolution.binding = <span class="literal">Some</span>(this.ambiguity(</span><br><span class="line">                            AmbiguityKind::GlobVsExpanded,</span><br><span class="line">                            nonglob_binding,</span><br><span class="line">                            glob_binding,</span><br><span class="line">                        ));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        resolution.binding = <span class="literal">Some</span>(nonglob_binding);</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolution.shadowed_glob = <span class="literal">Some</span>(glob_binding);</span><br><span class="line">                &#125;</span><br><span class="line">                (<span class="literal">false</span>, <span class="literal">false</span>) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">Err</span>(old_binding);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolution.binding = <span class="literal">Some</span>(binding);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着比较长，让我们一点一点来。</p><p>第一句<code>let res = binding.res();</code>就有点懵了，<code>res</code>是啥？result？response？其实都不是，我们点进去看看，一直点到底，会发现其实是<code>resolution</code>的缩写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The resolution of a path or export.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// For every path or identifier in Rust, the compiler must determine</span></span><br><span class="line"><span class="comment">/// what the path refers to. This process is called name resolution,</span></span><br><span class="line"><span class="comment">/// and `Res` is the primary result of name resolution.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// For example, everything prefixed with `/* Res */` in this example has</span></span><br><span class="line"><span class="comment">/// an associated `Res`:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// fn str_to_string(s: &amp; /* Res */ str) -&gt; /* Res */ String &#123;</span></span><br><span class="line"><span class="comment">///     /* Res */ String::from(/* Res */ s)</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// /* Res */ str_to_string(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The associated `Res`s will be:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - `str` will resolve to [`Res::PrimTy`];</span></span><br><span class="line"><span class="comment">/// - `String` will resolve to [`Res::Def`], and the `Res` will include the [`DefId`]</span></span><br><span class="line"><span class="comment">///   for `String` as defined in the standard library;</span></span><br><span class="line"><span class="comment">/// - `String::from` will also resolve to [`Res::Def`], with the [`DefId`]</span></span><br><span class="line"><span class="comment">///   pointing to `String::from`;</span></span><br><span class="line"><span class="comment">/// - `s` will resolve to [`Res::Local`];</span></span><br><span class="line"><span class="comment">/// - the call to `str_to_string` will resolve to [`Res::Def`], with the [`DefId`]</span></span><br><span class="line"><span class="comment">///   pointing to the definition of `str_to_string` in the current crate.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]</span></span><br><span class="line"><span class="meta">#[derive(HashStable_Generic)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Res</span></span>&lt;Id = hir::HirId&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，这条语句就是获得了我们刚才初始化的<code>binding</code>的<code>resolution</code>，我们接着看：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.check_reserved_macro_name(key.ident, res);</span><br><span class="line"><span class="keyword">self</span>.set_binding_parent_module(binding, module);</span><br></pre></td></tr></table></figure><p>先看第一行的<code>check_reserved_macro_name</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">crate</span> <span class="function"><span class="keyword">fn</span> <span class="title">check_reserved_macro_name</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ident: Ident, res: Res) &#123;</span><br><span class="line">    <span class="comment">// Reserve some names that are not quite covered by the general check</span></span><br><span class="line">    <span class="comment">// performed on `Resolver::builtin_attrs`.</span></span><br><span class="line">    <span class="keyword">if</span> ident.name == sym::cfg || ident.name == sym::cfg_attr &#123;</span><br><span class="line">        <span class="keyword">let</span> macro_kind = <span class="keyword">self</span>.get_macro(res).map(|ext| ext.macro_kind());</span><br><span class="line">        <span class="keyword">if</span> macro_kind.is_some() &amp;&amp; sub_namespace_match(macro_kind, <span class="literal">Some</span>(MacroKind::Attr)) &#123;</span><br><span class="line">            <span class="keyword">self</span>.session.span_err(</span><br><span class="line">                ident.span,</span><br><span class="line">                &amp;<span class="built_in">format!</span>(<span class="string">&quot;name `&#123;&#125;` is reserved in attribute namespace&quot;</span>, ident),</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像也没啥特殊的，就是看看有没有用到保留关键字，先无视掉吧；</p><p>再看看第二行<code>set_binding_parent_module</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">set_binding_parent_module</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, binding: &amp;<span class="symbol">&#x27;a</span> NameBinding&lt;<span class="symbol">&#x27;a</span>&gt;, module: Module&lt;<span class="symbol">&#x27;a</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_module) = <span class="keyword">self</span>.binding_parent_modules.insert(PtrKey(binding), module) &#123;</span><br><span class="line">        <span class="keyword">if</span> !ptr::eq(module, old_module) &#123;</span><br><span class="line">            span_bug!(binding.span, <span class="string">&quot;parent module is reset for binding&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hmmm……好像是绑定了所在的 module，看着也没啥特殊的，也跳过吧。</p><p>接着往下看，这一段是重头戏了，让我们先进入<code>update_resolution</code>看看：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107191451777-uOrrh7.png!webp_90" alt="update_resolution" style="zoom:67%;" /><p>这里我们只关注：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resolution = &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.resolution(module, key).borrow_mut();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = f(<span class="keyword">self</span>, resolution);</span><br></pre></td></tr></table></figure><p>这两行，这两行应该是主要逻辑。</p><p>首先，我们调用了<code>self.resolution</code>，我们进去看看：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107191616859-Q69Ns3.png!webp_90" alt="resolution" style="zoom:67%;" /><p>这里又调用了<code>resolutions</code>：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107191702182-edhbmZ.png!webp_90" alt="resolutions" style="zoom:67%;" /><p>这里我们发现又有一段新的逻辑，我们看下字段的注释：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107191746171-295pM4.png!webp_90" alt="module populate" style="zoom:67%;" /><p>会发现其实 module 的 resolution 是 lazy 计算的，ok，具体的<code>build_reduced_graph_external</code>想必就是计算的部分，我们在这里先跳过，作为一个黑盒，之后再去探究。</p><p>好了，现在回过头继续看刚才的代码：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107191616859-Q69Ns3.png!webp_90" alt="resolution" style="zoom:67%;" /><p>在<code>resolution</code>方法中，我们获取到了当前模块的所有<code>resolutions</code>，然后看看<code>key</code>是否存在，不存在就创建一个新的，并返回这个<code>resolution</code>。</p><p>再回到上层代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resolution = &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.resolution(module, key).borrow_mut();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = f(<span class="keyword">self</span>, resolution);</span><br></pre></td></tr></table></figure><p>这里我们拿到了<code>resolution</code>后调用了传入的 f，让我们回到<code>try_define</code>中，先看 else 部分：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.update_resolution(module, key, |this, resolution| &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_binding) = resolution.binding &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolution.binding = <span class="literal">Some</span>(binding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里如果返回的<code>resolution</code>的<code>binding</code>是<code>None</code>（对应上面<code>resolution</code>方法中新建的<code>resolution</code>，之前不存在），那么就把<code>resolution</code>的<code>binding</code>设为当前的<code>binding</code>然后返回<code>Ok</code>，逻辑还是比较简单的。</p><p>好了，让我们再接着看看如果原来已经有了一个<code>binding</code>，rustc 会如何处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = binding.res();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.update_resolution(module, key, |this, resolution| &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_binding) = resolution.binding &#123;</span><br><span class="line">        <span class="keyword">if</span> res == Res::<span class="literal">Err</span> &#123;</span><br><span class="line">            <span class="comment">// Do not override real bindings with `Res::Err`s from error recovery.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Ok</span>(());</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这里如果之前返回的 res 本身就是 Err 的话，就直接返回，我们看一下 Err 的注释：</p><img data-src="https://static.purewhite.io/uPic/2021-11-07/image-20211107192704528-TJIrs5.png!webp_90" alt="Res::Err" style="zoom:67%;" /><p>嗯，这部分直接无视吧，我们接着看：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = binding.res();</span><br><span class="line"><span class="keyword">self</span>.update_resolution(module, key, |this, resolution| &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_binding) = resolution.binding &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">match</span> (old_binding.is_glob_import(), binding.is_glob_import()) &#123;</span><br><span class="line">            (<span class="literal">true</span>, <span class="literal">true</span>) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> res != old_binding.res() &#123;</span><br><span class="line">                    resolution.binding = <span class="literal">Some</span>(this.ambiguity(</span><br><span class="line">                        AmbiguityKind::GlobVsGlob,</span><br><span class="line">                        old_binding,</span><br><span class="line">                        binding,</span><br><span class="line">                    ));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> !old_binding.vis.is_at_least(binding.vis, &amp;*this) &#123;</span><br><span class="line">                    <span class="comment">// We are glob-importing the same item but with greater visibility.</span></span><br><span class="line">                    resolution.binding = <span class="literal">Some</span>(binding);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>如果说新的和旧的都是<code>glob_import</code>，那么我们判断一下当前的<code>res</code>和之前的<code>res</code>是否是同一个，如果不是就说明出现了模糊性，我们把<code>resolution</code>的<code>binding</code>设置成<code>ambiguity</code>（模糊的意思）；如果两个<code>res</code>是同一个，那我们再判断一下可见性，如果说新的可见性更大，那我们就直接替换。</p><p>这里大家就会疑惑了，<code>glob_import</code>是啥？我们来插入一个小插曲：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">import_kind_to_string</span></span>(import_kind: &amp;ImportKind&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> import_kind &#123;</span><br><span class="line">        ImportKind::Single &#123; source, .. &#125; =&gt; source.to_string(),</span><br><span class="line">        ImportKind::Glob &#123; .. &#125; =&gt; <span class="string">&quot;*&quot;</span>.to_string(),</span><br><span class="line">        ImportKind::ExternCrate &#123; .. &#125; =&gt; <span class="string">&quot;&lt;extern crate&gt;&quot;</span>.to_string(),</span><br><span class="line">        ImportKind::MacroUse =&gt; <span class="string">&quot;#[macro_use]&quot;</span>.to_string(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这大家应该都知道了吧，我就不过多解释了。</p><p>好的，回归正题，看起来这段是处理<code>use</code>相关的，我们可以简单略过，接着往下看：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = binding.res();</span><br><span class="line"><span class="keyword">self</span>.update_resolution(module, key, |this, resolution| &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_binding) = resolution.binding &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">match</span> (old_binding.is_glob_import(), binding.is_glob_import()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            (old_glob @ <span class="literal">true</span>, <span class="literal">false</span>) | (old_glob @ <span class="literal">false</span>, <span class="literal">true</span>) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> (glob_binding, nonglob_binding) =</span><br><span class="line">                    <span class="keyword">if</span> old_glob &#123; (old_binding, binding) &#125; <span class="keyword">else</span> &#123; (binding, old_binding) &#125;;</span><br><span class="line">                <span class="keyword">if</span> glob_binding.res() != nonglob_binding.res()</span><br><span class="line">                    &amp;&amp; key.ns == MacroNS</span><br><span class="line">                    &amp;&amp; nonglob_binding.expansion != LocalExpnId::ROOT</span><br><span class="line">                &#123;</span><br><span class="line">                    resolution.binding = <span class="literal">Some</span>(this.ambiguity(</span><br><span class="line">                        AmbiguityKind::GlobVsExpanded,</span><br><span class="line">                        nonglob_binding,</span><br><span class="line">                        glob_binding,</span><br><span class="line">                    ));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolution.binding = <span class="literal">Some</span>(nonglob_binding);</span><br><span class="line">                &#125;</span><br><span class="line">                resolution.shadowed_glob = <span class="literal">Some</span>(glob_binding);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>这一段我们处理了一个<code>glob_import</code>和一个非<code>glob_import</code>的情况，简单来说原则就是，非<code>glob</code>的优先，但是有个例外：如果非<code>glob</code>的是在宏中的，那么这里就会导致“模糊”（Rust 是卫生宏），这里会像上文一样把<code>binding</code>设为<code>ambiguity</code>。</p><p>这部分的逻辑涉及到宏的相关知识，我们先作为一个黑盒跳过，反正大概了解到了非<code>glob</code>优先，会<code>shadow</code>掉<code>glob</code>就完事，这也符合我们的编码经验和人体工程学。</p><p>好，我们最后看最简单的一部分：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = binding.res();</span><br><span class="line"><span class="keyword">self</span>.update_resolution(module, key, |this, resolution| &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_binding) = resolution.binding &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">match</span> (old_binding.is_glob_import(), binding.is_glob_import()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            (<span class="literal">false</span>, <span class="literal">false</span>) =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(old_binding);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>如果两个名字都不是<code>glob</code>引入的，那么就说明在当前的命名空间中我们出现了俩一样的名字（要注意在这里解析的不是变量名，所以不允许有一样的），那么就说明出错了，返回错误抛给上层，也就是我们的<code>define</code>方法中，并报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;</span></span><br><span class="line"><span class="comment">/// otherwise, reports an error.</span></span><br><span class="line"><span class="keyword">crate</span> <span class="function"><span class="keyword">fn</span> <span class="title">define</span></span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, parent: Module&lt;<span class="symbol">&#x27;a</span>&gt;, ident: Ident, ns: Namespace, def: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: ToNameBinding&lt;<span class="symbol">&#x27;a</span>&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> binding = def.to_name_binding(<span class="keyword">self</span>.arenas);</span><br><span class="line">    <span class="keyword">let</span> key = <span class="keyword">self</span>.new_key(ident, ns);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(old_binding) = <span class="keyword">self</span>.try_define(parent, key, binding) &#123;</span><br><span class="line">        <span class="keyword">self</span>.report_conflict(parent, ident, ns, old_binding, &amp;binding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，至此，我们看完了我们开头所说的<code>the name xx is defined multiple times</code>相关的逻辑啦。</p><p>不过我们仍然遗留了一些问题，大家可以继续深入探究一下：</p><ol><li><code>binding</code>被标记为<code>ambiguity</code>后，会发生什么？</li><li><code>module</code>的<code>resolution</code>是怎么被解析出来的？也就是我们略过的<code>build_reduced_graph_external</code>干了啥？</li><li>宏展开导致的冲突为什么要特殊对待？</li></ol><p>大家可以顺着以上的问题继续探究，欢迎大家留言评论或者加入 Rust 中文社群一起讨论学习 Rust~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近 Rust 官方社区搞了个 Rustc Reading Club 的活动，由编译器 team 的 Leader Niko 发起，具体网址在这里：&lt;a href=&quot;https://rust-lang.github.io/rustc-reading-club/&quot;&gt;https://rust-lang.github.io/rustc-reading-club/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很可惜的是，11 月 4 日的第一期，由于太过火爆并且 Zoom 人数限制 100 人，导致主持人 Niko 自己进不来所以取消了……等待看看官方后续会怎么搞吧，还是很期待官方组织的活动的。&lt;/p&gt;
&lt;p&gt;Rust 中文社群的张汉东大佬也紧跟着官方的活动，在社群里面组织了 Rustc 源码阅读的活动，今天（11 月 7 日）举办了第一期，在这期中我跟着吴翱翔大佬的思路，从一个错误出发，学习了一部分 rustc_resolve 的逻辑，于是想着写一篇博客总结一下。&lt;/p&gt;
&lt;p&gt;【小广告】下一期 11 月 14 日下午会由刘翼飞大佬带领大家一起去阅读类型推导相关的代码，有兴趣的同学可以下载&lt;a href=&quot;https://www.feishu.cn/&quot;&gt;飞书&lt;/a&gt;，注册一个个人账号，然后扫描二维码加入：&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="https://www.purewhite.io/categories/rust/"/>
    
    
    <category term="rust" scheme="https://www.purewhite.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>The Rustonomicon 的中文翻译</title>
    <link href="https://www.purewhite.io/2021/09/23/rust-nomicon-translate/"/>
    <id>https://www.purewhite.io/2021/09/23/rust-nomicon-translate/</id>
    <published>2021-09-23T09:50:56.000Z</published>
    <updated>2021-12-02T12:51:07.229Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习 Rust，发现 Rust 社区真的是有非常丰富的资源，从社区中学到了很多有用的东西。与此同时，也一直想着能够为社区做点什么。</p><p>正好发现<a href="https://doc.rust-lang.org/nomicon/">《The Rustonomicon》</a>（也称为 Rust 秘典、死灵书）之前的一版中文翻译（感谢@tjxing）是更新到了 2018 年，之后就再也没再更新维护过了；而这三年官方也对于这本书进行了大量的迭代升级，于是想着重新翻译一版，并尽可能持续跟进迭代，贡献给社区，也算是尽一份绵薄之力。</p><p>在线阅读地址：<a href="https://nomicon.purewhite.io/">https://nomicon.purewhite.io/</a></p><p>github 地址：<a href="https://github.com/PureWhiteWu/nomicon-zh-Hans">https://github.com/PureWhiteWu/nomicon-zh-Hans</a></p><span id="more"></span><h1 id="一些想说的话"><a href="#一些想说的话" class="headerlink" title="一些想说的话"></a>一些想说的话</h1><p>首先，限于译者自身姿势水平，翻译有可能无法做到完全信达雅，并且有一些专业术语不知道如何翻译到中文，在这里先向大家道歉，请多包涵。</p><p>不过，译者保证所有翻译的内容都是译者阅读并调整过多次的，并且译者会努力将内容调整到满足<strong>能看懂</strong>的要求，并且做到不遗漏原文内容。</p><p>如果大家对于翻译有更好的建议或者想法，欢迎直接 PR~</p><p>目前翻译基于 commit：2747c4bb2cbc0639b733793ddb0bf4e9daa2634e，基于时间：2021/9/19</p><p>Q：为什么不基于之前已有的中文版进行改进？</p><p>A：因为翻译成中文版后，很难再回过头去看和现在的英文版原文到底差了啥，所以还不如完全重新翻译一遍。</p><p>Q：那会不会有一天你的这个版本也过期了？</p><p>A：希望没有那一天。我 watch 了英文原版的所有 PR，如果有变更（希望）能及时更新。当然，也欢迎大家一起贡献 PR。</p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input disabled="" type="checkbox"> github 增加 action，合入 master 后自动更新线上版本</li><li><input disabled="" type="checkbox"> 思考是否把英文原版和中文翻译按段落放在一起，方便查阅原版</li></ul><p>也欢迎大家集思广益，一起建设 Rust 社区。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习 Rust，发现 Rust 社区真的是有非常丰富的资源，从社区中学到了很多有用的东西。与此同时，也一直想着能够为社区做点什么。&lt;/p&gt;
&lt;p&gt;正好发现&lt;a href=&quot;https://doc.rust-lang.org/nomicon/&quot;&gt;《The Rustonomicon》&lt;/a&gt;（也称为 Rust 秘典、死灵书）之前的一版中文翻译（感谢@tjxing）是更新到了 2018 年，之后就再也没再更新维护过了；而这三年官方也对于这本书进行了大量的迭代升级，于是想着重新翻译一版，并尽可能持续跟进迭代，贡献给社区，也算是尽一份绵薄之力。&lt;/p&gt;
&lt;p&gt;在线阅读地址：&lt;a href=&quot;https://nomicon.purewhite.io/&quot;&gt;https://nomicon.purewhite.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github 地址：&lt;a href=&quot;https://github.com/PureWhiteWu/nomicon-zh-Hans&quot;&gt;https://github.com/PureWhiteWu/nomicon-zh-Hans&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="https://www.purewhite.io/categories/rust/"/>
    
    
    <category term="rust" scheme="https://www.purewhite.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】Rust 常见的问题</title>
    <link href="https://www.purewhite.io/2021/09/01/rust-faq/"/>
    <id>https://www.purewhite.io/2021/09/01/rust-faq/</id>
    <published>2021-09-01T08:24:08.000Z</published>
    <updated>2021-12-02T12:51:07.229Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://github.com/dtolnay/rust-faq">https://github.com/dtolnay/rust-faq</a></p><p>本文档的存在是为了回答有关 Rust 编程语言的常见问题。它不是一个完整的语言指南，也不是一个教授该语言的工具。它只是一个参考，用来回答 Rust 社区中人们经常遇到的问题，并澄清 Rust 的一些设计决定背后的原因。</p><span id="more"></span><p>如果你觉得有一些常见的或重要的问题在这里没有得到解答，请在 GitHub 上针对<a href="https://github.com/dtolnay/rust-faq">这个 repo</a>提一个 issue!</p><p><em>这些内容大部分以前都在 rust-lang/rust 库中，并且在网站上有一个专门的 FAQ 页面。但是在 2018 年的网站重新设计中，它被删除了。我在这里把它恢复了，因为这些问题中的许多问题仍然被频繁询问。</em></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#The-Rust-Project">The Rust Project</a></li><li><a href="#%E6%80%A7%E8%83%BD">性能</a></li><li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li><li><a href="#%E6%95%B0%E5%AD%97">数字</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li><li><a href="#%E9%9B%86%E5%90%88">集合</a></li><li><a href="#%E6%80%9D%E6%99%AE%E8%84%BE%E6%B0%94am">所有权</a></li><li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a></li><li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></li><li><a href="#%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA">输入/输出</a></li><li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></li><li><a href="#%E5%B9%B6%E5%8F%91">并发</a></li><li><a href="#%E5%AE%8F">宏</a></li><li><a href="#Debugging-and-Tooling">Debugging and Tooling</a></li><li><a href="#Low-Level">Low-Level</a></li><li><a href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台</a></li><li><a href="#mod-%E5%92%8C-crate">mod 和 crate</a></li><li><a href="#%E5%BA%93">库</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80">其他语言</a></li><li><a href="#Documentation">Documentation</a></li></ul><h1 id="The-Rust-Project"><a href="#The-Rust-Project" class="headerlink" title="The Rust Project"></a>The Rust Project</h1><h2 id="这个项目的目标是什么？"><a href="#这个项目的目标是什么？" class="headerlink" title="这个项目的目标是什么？"></a>这个项目的目标是什么？</h2><p>设计并实现一种安全的、并发的、实用的系统级语言。</p><p>Rust 之所以存在，是因为在这个抽象和效率水平上的其他语言并不令人满意。特别是：</p><ol><li>对安全性的关注太少。</li><li>他们对并发性的支持很差。</li><li>缺乏实际的承受力。</li><li>它们对资源的控制有限。</li></ol><p>Rust 作为一种替代方案存在，它既能提供高效的代码，又能提供舒适的抽象水平，同时在上述四点上都有改进。</p><h2 id="这个项目是由-Mozilla-控制的吗？"><a href="#这个项目是由-Mozilla-控制的吗？" class="headerlink" title="这个项目是由 Mozilla 控制的吗？"></a>这个项目是由 Mozilla 控制的吗？</h2><p>Rust 在 2006 年作为 Graydon Hoare 的兼职项目开始，并保持了 3 年多。2009 年，当该语言成熟到可以运行基本测试并展示其核心概念时，Mozilla 参与其中。虽然它仍然由 Mozilla 赞助，但 Rust 是由来自世界各地不同地方的爱好者组成的一个多样化社区开发的。<a href="https://www.rust-lang.org/governance">Rust 团队</a>由 Mozilla 和非 Mozilla 成员组成，GitHub 上的<code>rust</code>到目前为止已经有超过<a href="https://github.com/rust-lang/rust/">2300 个独特的贡献者</a>。</p><p>就<a href="https://github.com/rust-lang/rfcs/blob/master/text/1068-rust-governance.md">项目管理</a>而言，Rust 由一个核心团队管理，为项目设定愿景和优先级。从全球角度来指导它。还有一些子团队来指导和促进特定兴趣领域的发展，包括核心语言、编译器、Rust 库、Rust 工具和 Rust 官方社区的管理。这些领域的设计都是通过[RFC]（<a href="https://github.com/rust-lang/rfcs%EF%BC%89%E6%9D%A5%E6%8E%A8%E8%BF%9B%E7%9A%84%E3%80%82%E5%AF%B9%E4%BA%8E%E4%B8%8D%E9%9C%80%E8%A6%81">https://github.com/rust-lang/rfcs）来推进的。对于不需要</a> RFC 的变化，通过<a href="https://github.com/rust-lang/rust"><code>rustc</code>仓库</a>的 PR 来决定。</p><h2 id="Rust的一些非目标是什么？"><a href="#Rust的一些非目标是什么？" class="headerlink" title="Rust的一些非目标是什么？"></a>Rust的一些非目标是什么？</h2><ol><li>我们不采用任何特别前沿的技术。旧的、成熟的技术会更好。</li><li>我们并不把表现力、极简主义或优雅性置于其他目标之上。这些都是可取的，但是从属的目标。</li><li>我们不打算涵盖 C++ 或任何其他语言的完整功能集。Rust 应该提供大多数情况下的功能。</li><li>我们不打算做到 100% 的静态，100% 的安全，100% 的反射，或在任何其他意义上过于教条化。存在权衡。</li><li>我们不要求 Rust 在“所有可能的平台”上运行。它最终必须在广泛使用的硬件和软件平台上没有不必要的妥协地运行。</li></ol><h2 id="Mozilla-在哪些项目中使用-Rust？"><a href="#Mozilla-在哪些项目中使用-Rust？" class="headerlink" title="Mozilla 在哪些项目中使用 Rust？"></a>Mozilla 在哪些项目中使用 Rust？</h2><p>主要的项目是<a href="https://github.com/servo/servo">Servo</a>，这是 Mozilla 正在进行的实验性浏览器引擎。他们也在努力将<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1135640">Rust 组件</a>整合到 Firefox 中。</p><h2 id="有哪些大型-Rust-项目的例子？"><a href="#有哪些大型-Rust-项目的例子？" class="headerlink" title="有哪些大型 Rust 项目的例子？"></a>有哪些大型 Rust 项目的例子？</h2><p>现在最大的两个 Rust 开源项目是<a href="https://github.com/servo/servo">Servo</a>和<a href="https://github.com/rust-lang/rust">Rust 编译器</a>本身。</p><h2 id="还有谁在使用-Rust？"><a href="#还有谁在使用-Rust？" class="headerlink" title="还有谁在使用 Rust？"></a>还有谁在使用 Rust？</h2><p><a href="https://www.rust-lang.org/production/users">越来越多的组织！</a></p><h2 id="我怎样才能轻松地尝试-Rust？"><a href="#我怎样才能轻松地尝试-Rust？" class="headerlink" title="我怎样才能轻松地尝试 Rust？"></a>我怎样才能轻松地尝试 Rust？</h2><p>尝试Rust的最简单方法是通过<a href="https://play.rust-lang.org/">playpen</a>，这是一个用于编写和运行 Rust 代码的在线应用程序。如果你想在你的系统上尝试 Rust，<a href="https://www.rust-lang.org/tools/install">安装它</a>并通过书中的<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">猜谜游戏</a>教程。</p><h2 id="我怎样才能得到-Rust-问题的帮助？"><a href="#我怎样才能得到-Rust-问题的帮助？" class="headerlink" title="我怎样才能得到 Rust 问题的帮助？"></a>我怎样才能得到 Rust 问题的帮助？</h2><p>有几种方法。你可以。</p><ul><li>在<a href="https://users.rust-lang.org/">users.rust-lang.org</a>，即 Rust 官方用户论坛上发帖</li><li>在官方的<a href="https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust">Rust IRC channel</a> (#rust on irc.mozilla.org)中提问。</li><li>在<a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>上用“rust”标签提问。</li><li>在<a href="https://www.reddit.com/r/rust">/r/rust</a>，非官方的 Rust 子论坛上发帖</li></ul><h2 id="为什么-Rust-随着时间的推移发生了如此大的变化？"><a href="#为什么-Rust-随着时间的推移发生了如此大的变化？" class="headerlink" title="为什么 Rust 随着时间的推移发生了如此大的变化？"></a>为什么 Rust 随着时间的推移发生了如此大的变化？</h2><p>Rust 最初的目标是创造一种安全但可用的系统编程语言。在追求这一目标的过程中，它探索了很多想法，其中一些被保留了下来（生命周期，Trait），而另一些则被抛弃了（类型状态系统，绿色线程）。另外，在 1.0 之前，很多标准库都被重写了，因为早期的设计被更新以最好地使用 Rust 的特性，并提供高质量的、一致的跨平台 API。现在 Rust 已经达到了 1.0，该语言被保证是“稳定的”；虽然它可能继续发展，但在当前 Rust 上运行的代码应该继续在未来的版本上运行。</p><h2 id="Rust语言的版本管理是如何进行的？"><a href="#Rust语言的版本管理是如何进行的？" class="headerlink" title="Rust语言的版本管理是如何进行的？"></a>Rust语言的版本管理是如何进行的？</h2><p>Rust 的语言版本管理遵循<a href="http://semver.org/">SemVer</a>，只有当需要进行编译器错误的修复、安全漏洞的修补或者需要更多注释以改变类型推断和分发的时候，才允许在小版本中对稳定的 API 进行向后不兼容的修改。更详细的小版本修改指南可参考<a href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md">语言</a>和<a href="https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md">标准库</a>的 RFC。</p><p>Rust 有三个“发布 channel”：稳定版、测试版和 nightly 版。稳定版和测试版每六周更新一次，当前的 nightly 版成为新的测试版，而当前的 nightly 版成为新的稳定版。标记为不稳定的语言和标准库功能或隐藏在特性开关后面的功能只能在 nightly 中使用。新功能以不稳定的形式出现，一旦被核心团队和相关的子团队批准，就会被“解禁”。这种方法允许实验，同时为稳定频道提供强大的向后兼容性保证。</p><p>更多的细节，请阅读 Rust 的博文<a href="http://blog.rust-lang.org/2014/10/30/Stability.html">“Stability as a Deliverable”</a>。</p><h2 id="我可以在测试版或稳定版频道上使用不稳定的功能吗？"><a href="#我可以在测试版或稳定版频道上使用不稳定的功能吗？" class="headerlink" title="我可以在测试版或稳定版频道上使用不稳定的功能吗？"></a>我可以在测试版或稳定版频道上使用不稳定的功能吗？</h2><p>不，你不能。Rust 努力为测试版和稳定版频道上提供的功能的稳定性提供强有力的保证。当某项功能不稳定时，这意味着我们还不能为它提供这些保证，并且不希望人们依赖它保持不变。这使我们有机会在 nightly 上尝试改变，同时仍然为寻求稳定的人保持强有力的保证。</p><p>事情一直在变稳定，测试版和稳定版频道每六周更新一次，其他时候偶尔也会接受测试版的修复。如果你在等待一个功能，而不使用 nightly，你可以通过检查问题追踪器上的<a href="https://github.com/rust-lang/rust/issues?q=is:issue+is:open+tracking+label:B-unstable"><code>B-unstable</code></a>标签来定位其追踪问题。</p><h2 id="什么是“特性开关”"><a href="#什么是“特性开关”" class="headerlink" title="什么是“特性开关”?"></a>什么是“特性开关”?</h2><p>“特性开关”是 Rust 用来稳定编译器、语言和标准库的特性的机制。一个被“开关控制”的特性只有在 nightly 上才能访问，而且只有在通过<code>#[feature]</code>属性或<code>-Z unstable-options</code>命令行参数明确启用后才能访问。当一个特性被稳定化后，它就可以在稳定发布通道上使用，并且不需要明确启用，这时候这个特性就被认为是稳定的。特性开关允许开发者在开发中的实验性功能在它们在稳定语言中可用之前进行测试。</p><h2 id="为什么要采用-MIT-ASL2-双许可证？"><a href="#为什么要采用-MIT-ASL2-双许可证？" class="headerlink" title="为什么要采用 MIT/ASL2 双许可证？"></a>为什么要采用 MIT/ASL2 双许可证？</h2><p>Apache 许可证包括对专利侵犯的重要保护，但它与 GPL 第 2 版不兼容。为了避免 Rust 与 GPL2 的使用出现问题，Rust 采用了 MIT 许可。</p><h2 id="为什么是-BSD-风格的许可，而不是-MPL-或三合一许可？"><a href="#为什么是-BSD-风格的许可，而不是-MPL-或三合一许可？" class="headerlink" title="为什么是 BSD 风格的许可，而不是 MPL 或三合一许可？"></a>为什么是 BSD 风格的许可，而不是 MPL 或三合一许可？</h2><p>这一方面是由于原始开发者（Graydon）的偏好，另一方面是由于语言往往比网络浏览器等产品有更广泛的受众和更多样化的可能嵌入和最终用途。我们希望尽可能多地吸引这些潜在的贡献者。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><h2 id="Rust有多快？"><a href="#Rust有多快？" class="headerlink" title="Rust有多快？"></a>Rust有多快？</h2><p>非常快! 在许多基准测试中，Rust 已经可以与 C 和 C++ 竞争（比如<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html">基准游戏</a>和<a href="https://github.com/kostya/benchmarks">其他</a>）。</p><p>像 C++ 一样，Rust 把<a href="http://blog.rust-lang.org/2015/05/11/traits.html">零成本抽象</a>作为它的核心原则之一：Rust 的抽象没有一个施加全局性能惩罚，也没有传统意义上的任何运行时系统的开销。</p><p>鉴于 Rust 是建立在 LLVM 之上的，并努力从 LLVM 的角度类似于 Clang，任何 LLVM 的性能改进也有助于 Rust。从长远来看，Rust 的类型系统中更丰富的信息也应该能够实现 C/C++ 代码难以实现或无法实现的优化。</p><h2 id="Rust-有垃圾收集吗？"><a href="#Rust-有垃圾收集吗？" class="headerlink" title="Rust 有垃圾收集吗？"></a>Rust 有垃圾收集吗？</h2><p>不，Rust 的关键创新之一是在<em>不需要</em>垃圾收集的同时保证内存安全（无 segfault）。</p><p>通过避免 GC，Rust 可以提供许多好处：可预测的资源清理，较低的内存管理开销，以及基本上没有运行时系统。所有这些特征都使 Rust 变得精干，并且容易嵌入到任意的上下文中，并使其更容易<a href="http://calculist.org/blog/2015/12/23/neon-node-rust/">将 Rust 代码与有 GC 的语言集成</a>。</p><p>Rust 通过其所有权和借用系统避免了对 GC 的需求，但同样的系统也有助于解决一系列其他问题，包括<br><a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">一般的资源管理</a>和<a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">并发性</a>。</p><p>当单一所有权不够用时，Rust 程序依靠标准的引用计数智能指针类型<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>，以及它的线程安全对应类型<a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>，而不是 GC。</p><p>然而，我们正在研究<em>可选的</em>垃圾收集作为未来的扩展。我们的目标是使其能够顺利地与垃圾收集的运行时，例如那些由<a href="https://spidermonkey.dev/">Spidermonkey</a>和<a href="https://developers.google.com/v8/?hl=en">V8</a>的 JavaScript 引擎提供的。最后，一些人已经在没有编译器的支持情况下研究了实现<a href="https://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/">纯 Rust 垃圾收集器</a>。</p><h2 id="为什么我的程序很慢？"><a href="#为什么我的程序很慢？" class="headerlink" title="为什么我的程序很慢？"></a>为什么我的程序很慢？</h2><p>Rust 编译器不会用优化来编译，除非被要求这样做，<a href="https://users.rust-lang.org/t/why-does-cargo-build-not-optimise-by-default/4150/3">因为优化会降低编译速度，而且在开发过程中通常是不可取的</a>。</p><p>如果你用<code>cargo</code>编译，请使用<code>--release</code>标志。如果你直接用<code>rustc</code>编译，使用<code>-O</code>标志。这两个标志中的任何一个都会打开优化功能。</p><h2 id="Rust的编译似乎很慢。这是为什么呢？"><a href="#Rust的编译似乎很慢。这是为什么呢？" class="headerlink" title="Rust的编译似乎很慢。这是为什么呢？"></a>Rust的编译似乎很慢。这是为什么呢？</h2><p>代码翻译和优化。Rust 提供了高水平的抽象，可以编译成高效的机器代码，这些翻译需要时间来运行，特别是在优化时。</p><p>但是 Rust 的编译时间并不像看起来那么糟糕，而且有理由相信它会有所改善。当比较 C++ 和 Rust 之间类似规模的项目时，一般认为整个项目的编译时间是相当的。人们普遍认为 Rust 的编译速度很慢，这在很大程度上是由于 C++ 和 Rust 的<em>编译模型</em>的不同。C++ 的编译单元是文件，而 Rust 的编译单元是由许多文件组成的 crate。因此，在开发过程中，修改一个 C++ 文件可能会导致比 Rust 少得多的重新编译。目前正在努力重构编译器以引入<a href="https://github.com/rust-lang/rfcs/blob/master/text/1298-incremental-compilation.md">增量编译</a>，这将为 Rust 提供 C++ 模型的编译时间优势。</p><p>除了编译模型之外，Rust 的语言设计和编译器实现还有其他几个方面会影响编译时的性能。</p><p>首先，Rust 有一个适度复杂的类型系统，必须花费不可忽视的编译时间来执行约束，使 Rust 在运行时安全。</p><p>其次，Rust 编译器有长期的技术债务，特别是产生了质量很差的 LLVM IR，LLVM 必须花时间“修复”。在 Rust 编译器中加入一个新的内部表示法，称为<a href="https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md">MIR</a>，有可能进行更多的优化，提高生成的 LLVM IR 的质量，但这项工作还没有发生过。</p><p>第三，Rust 使用 LLVM 来生成代码是一把双刃剑：虽然它使 Rust 拥有世界一流的运行时性能，但 LLVM 是一个大型框架，不注重编译时的性能，特别是在处理质量差的输入时。</p><p>最后，虽然 Rust 的首选策略是单态泛型（类似于 C++），但它要求生成的代码比其他翻译策略多得多。Rust 的程序员可以使用特征对象，通过使用动态调度来换取这种代码的膨胀。</p><h2 id="为什么-Rust-的HashMap很慢？"><a href="#为什么-Rust-的HashMap很慢？" class="headerlink" title="为什么 Rust 的HashMap很慢？"></a>为什么 Rust 的<code>HashMap</code>很慢？</h2><p>默认情况下，Rust 的<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>使用 <a href="https://en.wikipedia.org/wiki/SipHash">SipHash</a> 散列算法，该算法旨在防止<a href="http://programmingisterrible.com/post/40620375793/hash-table-denial-of-service-attacks-revisited">散列表碰撞攻击</a>，同时提供<a href="https://www.reddit.com/r/rust/comments/3hw9zf/rust_hasher_comparisons/cub4oh6">各种工作负载下的合理性能</a>。</p><p>虽然 SipHash <a href="http://cglab.ca/%7Eabeinges/blah/hash-rs/">在许多情况下表现出有竞争力的性能</a>，但它比其他散列算法明显慢的一种情况是在短键，如整数。这就是为什么 Rust 程序员经常观察到<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>的性能缓慢。在这种情况下，经常推荐使用 <a href="https://crates.io/crates/fnv">FNV hasher</a>，但要注意它不具备与 SipHash 一样的抗碰撞特性。</p><h2 id="为什么没有集成的基准测试基础设施"><a href="#为什么没有集成的基准测试基础设施" class="headerlink" title="为什么没有集成的基准测试基础设施?"></a>为什么没有集成的基准测试基础设施?</h2><p>有，但它只在 nightly 上可用。我们最终计划建立一个可插拔的系统来进行综合基准测试，但与此同时，目前的系统<a href="https://github.com/rust-lang/rust/issues/29553">被认为是不稳定的</a>。</p><h2 id="Rust-是否做了尾调用优化？"><a href="#Rust-是否做了尾调用优化？" class="headerlink" title="Rust 是否做了尾调用优化？"></a>Rust 是否做了尾调用优化？</h2><p>一般来说，不会。在<a href="http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization">有限的情况下</a>可能会进行尾部调用优化，但<a href="https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html">不保证</a>。由于这个功能一直是人们所希望的，Rust 保留了一个关键字（<code>become</code>），尽管目前还不清楚它在技术上是否可行，也不清楚它是否会被实现。曾经有一个<a href="https://github.com/rust-lang/rfcs/pull/81">拟议的扩展</a>，允许在某些情况下消除尾随调用，但目前被推迟了。</p><h2 id="Rust-有-runtime-吗？"><a href="#Rust-有-runtime-吗？" class="headerlink" title="Rust 有 runtime 吗？"></a>Rust 有 runtime 吗？</h2><p>不是 Java 等语言所使用的典型意义上的运行时，但是 Rust 标准库的一部分可以被认为是“运行时”，它提供了一个堆、回溯、解开和堆栈守护。有一个<a href="https://github.com/rust-lang/rust/blob/master/library/std/src/rt.rs">少量的初始化代码</a>，在用户的<code>main</code>函数之前运行。Rust 标准库还链接了 C 标准库，它也做了类似的<a href="http://www.embecosm.com/appnotes/ean9/html/ch05s02.html">运行时初始化</a>。Rust 代码可以在没有标准库的情况下进行编译，在这种情况下，运行时与 C 语言大致相当。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="为什么要用大括号-为什么-Rust-的语法不能像-Haskell-或-Python-那样？"><a href="#为什么要用大括号-为什么-Rust-的语法不能像-Haskell-或-Python-那样？" class="headerlink" title="为什么要用大括号? 为什么 Rust 的语法不能像 Haskell 或 Python 那样？"></a>为什么要用大括号? 为什么 Rust 的语法不能像 Haskell 或 Python 那样？</h2><p>使用大括号来表示块是各种编程语言中常见的设计选择，而 Rust 的一致性对于已经熟悉这种风格的人来说是很有用的。</p><p>大括号还可以为程序员提供更灵活的语法，并在编译器中提供更简单的解析器。</p><h2 id="我可以在if条件上不加小括号，那么为什么我必须在单行块周围加上大括号？为什么不允许使用-C-语言的风格"><a href="#我可以在if条件上不加小括号，那么为什么我必须在单行块周围加上大括号？为什么不允许使用-C-语言的风格" class="headerlink" title="我可以在if条件上不加小括号，那么为什么我必须在单行块周围加上大括号？为什么不允许使用 C 语言的风格?"></a>我可以在<code>if</code>条件上不加小括号，那么为什么我必须在单行块周围加上大括号？为什么不允许使用 C 语言的风格?</h2><p>C 语言要求“if”语句的条件必须有小括号，但大括号是可选的，而 Rust 对其“if”表达式做出了相反的选择。这使得条件语句与语句主体明确分开，并避免了可选大括号的危害，这可能导致在重构过程中出现容易被忽略的错误，比如苹果的 <a href="https://gotofail.com/">goto fail</a> 错误。</p><h2 id="为什么没有字典的字面语法？"><a href="#为什么没有字典的字面语法？" class="headerlink" title="为什么没有字典的字面语法？"></a>为什么没有字典的字面语法？</h2><p>Rust 的整体设计倾向于限制<em>语言</em>的大小，同时启用强大的<em>库</em>。虽然 Rust 确实为数组和字符串字面提供了初始化语法，但这是语言中唯一的集合类型。其他库定义的类型，包括无处不在的<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>集合类型，都使用宏进行初始化，如<a href="https://doc.rust-lang.org/std/macro.vec!.html"><code>vec!</code></a>宏。</p><p>这种使用 Rust 的宏设施来初始化集合的设计选择在未来可能会被通用地扩展到其他集合，不仅可以简单地初始化<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>和<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>，还可以初始化其他集合类型，如<a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a>。同时, 如果你想要一个更方便的初始化集合的语法, 你可以<a href="https://stackoverflow.com/questions/27582739/how-do-i-create-a-hashmap-literal">创建你自己的宏</a>来提供它.</p><h2 id="我应该在什么时候使用隐式返回？"><a href="#我应该在什么时候使用隐式返回？" class="headerlink" title="我应该在什么时候使用隐式返回？"></a>我应该在什么时候使用隐式返回？</h2><p>Rust 是一种非常面向表达式的语言，而“隐式返回”是这种设计的一部分。像<code>if</code>s, <code>match</code>es, 和普通块这样的结构在 Rust 中都是表达式。例如，下面的代码检查一个<a href="https://doc.rust-lang.org/std/primitive.i64.html"><code>i64</code></a>是否为奇数，通过简单地将其作为一个值来返回结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_odd</span></span>(x: <span class="built_in">i64</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> &#123; <span class="literal">true</span> &#125; <span class="keyword">else</span> &#123; <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然它可以进一步简化，比如说。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_odd</span></span>(x: <span class="built_in">i64</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    x % <span class="number">2</span> != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个例子中，函数的最后一行是该函数的返回值。需要注意的是，如果一个函数以分号结束，其返回类型将是<code>()</code>，表示没有返回值。隐式返回必须省略分号，才能发挥作用。</p><p>显式返回只有在隐式返回不可能时才会使用，因为你要在函数主体结束前返回。虽然上面的每个函数都可以用<code>return</code>关键字和分号来写，但这样做是不必要的冗长，而且与 Rust 代码的惯例不一致。</p><h2 id="为什么不推断出函数的签名？"><a href="#为什么不推断出函数的签名？" class="headerlink" title="为什么不推断出函数的签名？"></a>为什么不推断出函数的签名？</h2><p>在 Rust 中，声明往往带有明确的类型，而实际代码的类型是推断出来的。这种设计有几个原因：</p><ul><li>强制性的声明签名有助于在模块和板块层面上执行接口的稳定性。</li><li>签名提高了程序员对代码的理解，消除了 IDE 在整个板块中运行推理算法来猜测一个函数的参数类型的需要；它总是显式的，就在附近。</li><li>在机制上，它简化了推理算法，因为推理只需要一次看一个函数。</li></ul><h2 id="为什么match必须是详尽的"><a href="#为什么match必须是详尽的" class="headerlink" title="为什么match必须是详尽的?"></a>为什么<code>match</code>必须是详尽的?</h2><p>为了帮助重构和清晰化。</p><p>首先，如果每一种可能性都被<code>match</code>所覆盖，那么将来在<code>enum</code>中增加变体将导致编译失败，而不是在运行时出错。这种类型的编译器帮助使得 Rust 中的无畏重构成为可能。</p><p>其次，穷举式检查使默认情况的语义变得明确：一般来说，非穷举式<code>match</code>的唯一安全方式是在没有匹配到任何东西时让线程恐慌。Rust 的早期版本并不要求<code>match</code>情况是详尽的，而且发现它是一个很大的 bug 来源。</p><p>通过使用<code>_</code>通配符，可以很容易地忽略所有未指定的情况。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> val.do_something() &#123;</span><br><span class="line">    Cat(a) =&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    _ =&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Numerics"><a href="#Numerics" class="headerlink" title="Numerics"></a>Numerics</h1><h2 id="对于浮点运算，我应该选择f32和f64中的哪一个"><a href="#对于浮点运算，我应该选择f32和f64中的哪一个" class="headerlink" title="对于浮点运算，我应该选择f32和f64中的哪一个?"></a>对于浮点运算，我应该选择<code>f32</code>和<code>f64</code>中的哪一个?</h2><p>选择哪种方式取决于程序的目的。</p><p>如果你对浮点数的最大精度感兴趣, 那么就选择<a href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>. 如果你对保持数值的大小或最大的效率更感兴趣，并且不关心每个数值的位数较少所带来的误差，那么<a href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>更好。对<a href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>的操作通常更快，即使是在 64 位硬件上。作为一个常见的例子，图形编程通常使用<a href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>，因为它需要高性能，而 32 位浮点数足以代表屏幕上的像素。</p><p>如果有疑问，可以选择<a href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>以获得更大的精度。</p><h2 id="为什么我不能比较浮点数或用它们作为HashMap或BTreeMap的键"><a href="#为什么我不能比较浮点数或用它们作为HashMap或BTreeMap的键" class="headerlink" title="为什么我不能比较浮点数或用它们作为HashMap或BTreeMap的键?"></a>为什么我不能比较浮点数或用它们作为<code>HashMap</code>或<code>BTreeMap</code>的键?</h2><p>浮点数可以用<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, 和<code>&gt;=</code>运算符，以及<code>partial_cmp()</code>函数进行比较。<code>==</code>和<code>！=</code>是<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>特性的一部分，而<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>和<code>partial_cmp()</code>是<a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> 特性的一部分。</p><p>浮点数不能用<code>cmp()</code>函数进行比较，它是<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>特性的一部分，因为浮点数没有总排序。此外，浮点数没有全等关系，所以它们也没有实现<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>特性。</p><p>由于浮点数<a href="https://en.wikipedia.org/wiki/NaN"><code>NaN</code></a>不小于、大于或等于任何其他浮点数或其本身，所以浮点数没有总排序或平等关系。</p><p>因为浮点数没有实现<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>或<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>，所以它们不能被用于特质边界需要这些特质的类型，例如<a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a>或[<code>HashMap</code>]。这一点很重要，因为这些类型<em>假设</em>它们的键提供了一个总排序或总等价关系，否则会出现故障。</p><p>有一个<a href="https://crates.io/crates/ordered-float">crate</a>包装了<a href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>和<a href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>以提供<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>和<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>的实现，这在某些情况下可能很有用。</p><h2 id="我如何在数字类型之间进行转换"><a href="#我如何在数字类型之间进行转换" class="headerlink" title="我如何在数字类型之间进行转换?"></a>我如何在数字类型之间进行转换?</h2><p>有两种方法：<code>as</code>关键字，它为原始类型做简单的转换，以及<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>和<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>特性，它们是为一些类型转换而实现的（你也可以为你自己的类型实现）。<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>和<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>特性只在转换无损的情况下实现，所以例如，<code>f64::from(0f32)</code>会被编译，而<code>f32::from(0f64)</code>不会。另一方面，<code>as</code>将在任何两个原始类型之间进行转换，必要时截断数值。</p><h2 id="为什么Rust没有增量和减量运算符"><a href="#为什么Rust没有增量和减量运算符" class="headerlink" title="为什么Rust没有增量和减量运算符?"></a>为什么Rust没有增量和减量运算符?</h2><p>Preincrement 和 Postincrement（以及与之对应的 Decrement）虽然方便，但也相当复杂。它们需要对计算顺序的了解，并经常导致 C 和 C++ 中的微妙错误和未定义行为。和<code>x = x + 1</code>相比<code>x += 1</code>只是稍微长一点，但不明确。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="如何将一个String或Vec-lt-T-gt-转换为一个片断-amp-str和-amp-T"><a href="#如何将一个String或Vec-lt-T-gt-转换为一个片断-amp-str和-amp-T" class="headerlink" title="如何将一个String或Vec&lt;T&gt;转换为一个片断(&amp;str和&amp;[T])?"></a>如何将一个<code>String</code>或<code>Vec&lt;T&gt;</code>转换为一个片断(<code>&amp;str</code>和<code>&amp;[T]</code>)?</h2><p>通常情况下，你可以在期望有片断的地方传递一个对<code>String</code>或<code>Vec&lt;T&gt;</code>的引用。使用<a href="https://doc.rust-lang.org/book/ch15-02-deref.html">Deref coercions</a>，<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code>s</a>和<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code>s</a>在用<code>&amp;</code>或<code>&amp;mut</code>传递引用时，将自动联合到各自的片上。</p><p>在<code>&amp;str</code>和<code>&amp;[T]</code>上实现的方法可以直接访问<code>String</code>和<code>Vec&lt;T&gt;</code>。例如，<code>some_string.trim()</code>可以工作，尽管<code>trim</code>是<code>&amp;str</code>上的方法，而<code>some_string</code>是一个<code>String</code>。</p><p>在某些情况下，例如通用代码，有必要进行手动转换。手动转换可以使用切片操作符来实现，像这样。<code>&amp;my_vec[...]</code>。</p><h2 id="我如何从-amp-str转换到String或反过来？"><a href="#我如何从-amp-str转换到String或反过来？" class="headerlink" title="我如何从&amp;str转换到String或反过来？"></a>我如何从<code>&amp;str</code>转换到<code>String</code>或反过来？</h2><p><a href="https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string"><code>to_string()</code></a>方法可以将<a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a>转换为<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>，当你借用一个引用时，<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>自动转换为<a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a>。这两种情况在下面的例子中都有演示。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;Jane Doe&quot;</span>.to_string();</span><br><span class="line">    say_hello(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">say_hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span> (<span class="string">&quot;Hello &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种不同的字符串类型之间有什么区别？"><a href="#两种不同的字符串类型之间有什么区别？" class="headerlink" title="两种不同的字符串类型之间有什么区别？"></a>两种不同的字符串类型之间有什么区别？</h2><p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>是一个在堆上分配的 UTF-8 字节的自有缓冲区。可变的<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>可以被修改，根据需要增加其容量。<a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a>是在其他地方分配的<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>的一个固定容量的“视图”，如果是从<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>中引用的片断，通常在堆上，如果是字符串字面，在静态内存中。</p><p><a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a>是由 Rust 语言实现的原始类型，而<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>是由标准库实现的。</p><h2 id="我如何在一个String中进行-O-1-的字符访问"><a href="#我如何在一个String中进行-O-1-的字符访问" class="headerlink" title="我如何在一个String中进行 O(1) 的字符访问?"></a>我如何在一个<code>String</code>中进行 O(1) 的字符访问?</h2><p>你不能。至少在你不清楚“字符”是什么意思的情况下，以及在对字符串进行预处理以找到所需字符的索引的情况下是不行的。</p><p>Rust 字符串是 UTF-8 编码的。UTF-8 中的单个视觉字符不一定是一个字节，因为它在 ASCII 编码的字符串中是一个字节。每个字节被称为“代码单元”（在 UTF-16 中，代码单元是 2 个字节；在 UTF-32 中是4个字节）。“代码点”由一个或多个代码单元组成，并组合成最接近于字符的“字素群”。</p><p>因此，即使你可以对 UTF-8 字符串中的字节进行索引，你也无法在恒定时间内访问第 i 个码位或字母群。然而，如果你知道所需的码位或字形群从哪个字节开始，那么你就可以在恒定时间内访问它。包括<a href="https://doc.rust-lang.org/std/primitive.str.html#method.find">str::find()</a>和 regex 匹配在内的函数都会返回字节索引，以方便这种访问。</p><h2 id="为什么字符串默认为-UTF-8？"><a href="#为什么字符串默认为-UTF-8？" class="headerlink" title="为什么字符串默认为 UTF-8？"></a>为什么字符串默认为 UTF-8？</h2><p><a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a>类型是 UTF-8，因为我们在野外观察到更多的文本是用这种编码的–特别是在网络传输中，它是 endian-agnostic 的–而且我们认为最好不要让 I/O 的默认处理涉及到在每个方向重新编码代码点。</p><p>这确实意味着在一个字符串中定位一个特定的 Unicode 编码点是一个 O(n) 操作，尽管如果开始的字节索引已经知道，那么它们可以在 O(1) 中被访问。一方面，这显然是不可取的；另一方面，这个问题充满了权衡，我们想指出几个重要的限定条件。</p><p>扫描一个<a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a>的 ASCII 范围的代码点仍然可以安全地逐个字节地进行。如果你使用<a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>.as_bytes()</code></a>，取出一个<a href="https://doc.rust-lang.org/std/primitive.u8.html"><code>u8</code></a>只需花费<code>O(1)</code>，并产生一个可以被转换并与 ASCII 范围的<a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>比较的值。因此，如果你（比如）在<code>\n</code>上断行，基于字节的处理方法仍然有效。UTF-8 就是这样被精心设计的。</p><p>大多数“面向字符”的文本操作只有在非常有限的语言假设下才能工作，如“仅 ASCII 范围的代码点”。在 ASCII 范围之外，你往往不得不使用复杂的（非恒定时间）算法来确定语言单位（字形、单词、段落）的边界。我们建议使用一种“诚实的”具有语言意识的、经 Unicode 批准的算法。</p><p><a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>类型是 UTF-32。如果你确定你需要做一个代码点的算法，写一个<code>type wstr = [char]</code>，并将一个<a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a>一次性解压到其中，然后用<code>wstr</code>工作，这是非常容易的。换句话说：如果你需要使用这种编码，语言没有<code>默认解码为 UTF32</code>的事实不应该阻止你解码（或以任何其他方式重新编码）。</p><p>关于为什么 UTF-8 通常比 UTF-16 或 UTF-32 更受欢迎，请阅读<a href="http://utf8everywhere.org/"> UTF-8 Everywhere 宣言</a>。</p><h2 id="我应该使用什么字符串类型？"><a href="#我应该使用什么字符串类型？" class="headerlink" title="我应该使用什么字符串类型？"></a>我应该使用什么字符串类型？</h2><p>Rust 有四对字符串类型，每一对都有不同的用途。在每一对中，都有一个“自有”的字符串类型，和一个“分片”的字符串类型。这个组织看起来像这样。</p><table><thead><tr><th align="left"></th><th align="left">“Slice” type</th><th align="left">“Owned” type</th></tr></thead><tbody><tr><td align="left">UTF-8</td><td align="left"><code>str</code></td><td align="left"><code>String</code></td></tr><tr><td align="left">OS-compatible</td><td align="left"><code>OsStr</code></td><td align="left"><code>OsString</code></td></tr><tr><td align="left">C-compatible</td><td align="left"><code>CStr</code></td><td align="left"><code>CString</code></td></tr><tr><td align="left">System path</td><td align="left"><code>Path</code></td><td align="left"><code>PathBuf</code></td></tr></tbody></table><p>Rust 的不同字符串类型有不同的用途。<code>String</code>和<code>str</code>是 UTF-8 编码的通用字符串。<code>OsString</code>和<code>OsStr</code>是根据当前平台编码的，在与操作系统交互时使用。<code>CString</code>和<code>CStr</code>相当于C 语言中的字符串，在 FFI 代码中使用。<code>PathBuf</code>和<code>Path</code>是对<code>OsString</code>和<code>OsStr</code>的方便包装，提供特定于路径操作的方法。</p><h2 id="我怎样才能写一个既接受-amp-str又接受String的函数"><a href="#我怎样才能写一个既接受-amp-str又接受String的函数" class="headerlink" title="我怎样才能写一个既接受&amp;str又接受String的函数?"></a>我怎样才能写一个既接受<code>&amp;str</code>又接受<code>String</code>的函数?</h2><p>有几种选择，取决于函数的需要。</p><ul><li>如果函数需要一个自有的字符串，但又想接受任何类型的字符串，可以使用一个<code>Into&lt;String&gt;</code>绑定。</li><li>如果函数需要一个字符串分片，但希望接受任何类型的字符串，使用<code>AsRef&lt;str&gt;</code>绑定。</li><li>如果函数不关心字符串的类型，而想统一处理这两种可能性，使用<code>Cow&lt;str&gt;</code>作为输入类型。</li></ul><h3 id="使用Into-lt-String-gt"><a href="#使用Into-lt-String-gt" class="headerlink" title="使用Into&lt;String&gt;"></a>使用<code>Into&lt;String&gt;</code></h3><p>在这个例子中，该函数将同时接受自有字符串和字符串片，要么不做任何事情，要么在函数主体内将输入的字符串转换为自有字符串。注意，转换需要明确进行，否则不会发生。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">accepts_both</span></span>&lt;S: <span class="built_in">Into</span>&lt;<span class="built_in">String</span>&gt;&gt;(s: S) &#123;</span><br><span class="line">    <span class="keyword">let</span> s = s.into(); <span class="comment">// 这将把 s 转换成一个`String`。</span></span><br><span class="line">    <span class="comment">// ... 其余的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用AsRef-lt-str-gt"><a href="#使用AsRef-lt-str-gt" class="headerlink" title="使用AsRef&lt;str&gt;"></a>使用<code>AsRef&lt;str&gt;</code></h3><p>在这个例子中，该函数将接受拥有的字符串和字符串片断，要么不做任何事情，要么将输入的字符串片断转换为字符串。这可以通过引用输入来自动完成，像这样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">accepts_both</span></span>&lt;S: <span class="built_in">AsRef</span>&lt;<span class="built_in">str</span>&gt;&gt;(s: &amp;S) &#123;</span><br><span class="line">    <span class="comment">// ... 该函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Cow-lt-str-gt"><a href="#使用Cow-lt-str-gt" class="headerlink" title="使用Cow&lt;str&gt;"></a>使用<code>Cow&lt;str&gt;</code></h3><p>在这个例子中，函数接收了一个<code>Cow&lt;str&gt;</code>，它不是一个通用类型，而是一个容器，根据需要包含一个自有的字符串或字符串片断。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">accepts_cow</span></span>(s: Cow&lt;<span class="built_in">str</span>&gt;) &#123;</span><br><span class="line">    <span class="comment">// ... 该函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="我可以在-Rust-中有效地实现向量和链表等数据结构吗"><a href="#我可以在-Rust-中有效地实现向量和链表等数据结构吗" class="headerlink" title="我可以在 Rust 中有效地实现向量和链表等数据结构吗?"></a>我可以在 Rust 中有效地实现向量和链表等数据结构吗?</h2><p>如果你实现这些数据结构的原因是为了在其他程序中使用它们，那就没有必要了，因为这些数据结构的有效实现已经由标准库提供了。</p><p>然而，如果<a href="book-to-many-lists">你的理由只是为了学习</a>，那么你很可能需要涉足不安全代码。虽然这些数据结构可以完全用安全的 Rust 来实现，但其性能可能会比使用不安全的代码要差。原因很简单，向量和链接列表等数据结构依赖于指针和内存操作，而这些操作在安全 Rust 中是不允许的。</p><p>例如，一个双链接列表需要对每个节点有两个可变引用，但这违反了 Rust 的可变引用别名规则。你可以用<a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a>来解决这个问题，但是性能会比你想要的差。使用不安全的代码，你可以绕过可变引用别名规则的限制，但必须手动验证你的代码是否引入了内存安全违规。</p><h2 id="我怎样才能在不移动-消耗集合的情况下对其进行迭代？"><a href="#我怎样才能在不移动-消耗集合的情况下对其进行迭代？" class="headerlink" title="我怎样才能在不移动/消耗集合的情况下对其进行迭代？"></a>我怎样才能在不移动/消耗集合的情况下对其进行迭代？</h2><p>最简单的方法是通过使用集合的<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>实现。下面是一个关于<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>&amp;Vec</code></a>的例子。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">print!</span> (<span class="string">&quot;&#123;&#125; &quot;</span>, item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span> (<span class="string">&quot;\nLength: &#123;&#125;&quot;</span>, v.len());</span><br></pre></td></tr></table></figure><p>Rust 的<code>for</code>循环对它们要迭代的东西调用<code>into_iter()</code>（定义在<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>trait 上）。任何实现了<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>trait 的东西都可以用<code>for</code>循环进行循环。<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>是为<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>&amp;Vec</code></a>和<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>&amp;mut Vec</code></a>实现的，导致来自<code>into_iter()</code>的迭代器借用集合的内容，而不是移动/消费它们。这对其他标准集合也是如此。</p><p>如果需要一个移动/消耗的迭代器，编写<code>for</code>循环时不要在迭代中使用<code>&amp;</code>或<code>&amp;mut</code>。</p><p>如果你需要直接访问一个借用的迭代器，你通常可以通过调用<code>iter()</code>方法得到它。</p><h2 id="为什么我需要在数组声明中输入数组大小"><a href="#为什么我需要在数组声明中输入数组大小" class="headerlink" title="为什么我需要在数组声明中输入数组大小?"></a>为什么我需要在数组声明中输入数组大小?</h2><p>你不一定要这样做。如果你直接声明一个数组，大小是根据元素的数量推断出来的。但是如果你声明的是一个接收固定大小的数组的函数，编译器就必须知道这个数组有多大。</p><p>有一点需要注意的是，目前 Rust 并没有对不同大小的数组提供泛型。如果你想接受一个连续的可变数量的值的容器，使用<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>或 slice（取决于你是否需要所有权）。</p><h1 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h1><h2 id="我怎样才能实现一个包含环的图或其他数据结构"><a href="#我怎样才能实现一个包含环的图或其他数据结构" class="headerlink" title="我怎样才能实现一个包含环的图或其他数据结构?"></a>我怎样才能实现一个包含环的图或其他数据结构?</h2><p>至少有四种选择（在<a href="https://rust-unofficial.github.io/too-many-lists/">Too Many Linked Lists</a>中详细讨论过）。</p><ul><li>你可以使用<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>和<a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak</code></a>实现它，以允许节点的共享所有权。尽管这种方法需要付出内存管理的代价。</li><li>你可以使用“不安全”的代码实现它，使用原始指针。这将更加高效，但却绕过了 Rust 的安全保证。</li><li>使用向量和这些向量的索引。有<a href="http://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">几个</a><a href="https://featherweightmusings.blogspot.com/2015/04/graphs-in-rust.html">可用</a>这种方法的例子和解释。</li><li>用<a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>使用借用的引用。对于这种方法有<a href="https://github.com/nrc/r4cppp/blob/master/graphs/README.md#node-and-unsafecell">解释和代码</a>。</li></ul><h2 id="我怎样才能定义一个包含对其自身字段之一的引用的结构？"><a href="#我怎样才能定义一个包含对其自身字段之一的引用的结构？" class="headerlink" title="我怎样才能定义一个包含对其自身字段之一的引用的结构？"></a>我怎样才能定义一个包含对其自身字段之一的引用的结构？</h2><p>这是有可能的，但是这样做没有用。该结构会被自己永久借用，因此不能被移动。下面是一些说明这个问题的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Unmovable</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    x: <span class="built_in">u32</span>,</span><br><span class="line">    y: Cell&lt;<span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="built_in">u32</span>&gt;&gt;。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> test = Unmovable &#123; x: <span class="number">42</span>, y: Cell::new(<span class="literal">None</span>) &#125;。</span><br><span class="line">    test.y.set(<span class="literal">Some</span>(&amp;test.x))。</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span> (<span class="string">&quot;&#123;:?&#125;&quot;</span>, test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按值传递、消耗、移动和转移所有权之间有什么区别"><a href="#按值传递、消耗、移动和转移所有权之间有什么区别" class="headerlink" title="按值传递、消耗、移动和转移所有权之间有什么区别?"></a>按值传递、消耗、移动和转移所有权之间有什么区别?</h2><p>这些是同一事物的不同术语。在所有的情况下，这意味着值已经被转移到另一个所有者那里，并且脱离了原所有者的占有，原所有者不能再使用它。如果一个类型实现了<code>Copy</code>特性，那么原所有者的值就不会被废止，仍然可以使用。</p><h2 id="为什么某些类型的值在传递给一个函数后可以使用，而重复使用其他类型的值会导致错误？"><a href="#为什么某些类型的值在传递给一个函数后可以使用，而重复使用其他类型的值会导致错误？" class="headerlink" title="为什么某些类型的值在传递给一个函数后可以使用，而重复使用其他类型的值会导致错误？"></a>为什么某些类型的值在传递给一个函数后可以使用，而重复使用其他类型的值会导致错误？</h2><p>如果一个类型实现了<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>特性，那么它在传递给函数时就会被复制。Rust 中的所有数字类型都实现了<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>，但结构类型默认不实现<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>，所以它们被移动。这意味着该结构不能再被用于其他地方，除非通过返回将其移回函数之外。</p><h2 id="如何处理“use-of-moved-value”的错误？"><a href="#如何处理“use-of-moved-value”的错误？" class="headerlink" title="如何处理“use of moved value”的错误？"></a>如何处理“use of moved value”的错误？</h2><p>这个错误意味着你要使用的值已经被转移到一个新的所有者那里。首先要检查的是有关的移动是否是必要的：如果它移动到一个函数中，也许可以重写该函数以使用一个引用，而不是移动。否则，如果被移动的类型实现了<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>，那么在移动前对其调用<code>clone()</code>将移动它的一个副本，留下原始的仍然可以继续使用。但是请注意，克隆一个值通常应该是最后的手段，因为克隆可能很昂贵，会导致进一步的分配。</p><p>如果移动的值是你自己的自定义类型，考虑实现<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>（用于隐式复制，而不是移动）或<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>（显式复制）。<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>最常用的实现方式是<code>#[derive(Copy, Clone)]</code>（<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>需要<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>），而<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>则是`#[derive(Clone)]。</p><p>如果这些都不可能，你可能想修改获得所有权的函数，以便在函数退出时返回数值的所有权。</p><h2 id="在方法声明中使用self、-amp-self或-amp-mut-self的规则是什么"><a href="#在方法声明中使用self、-amp-self或-amp-mut-self的规则是什么" class="headerlink" title="在方法声明中使用self、&amp;self或&amp;mut self的规则是什么?"></a>在方法声明中使用<code>self</code>、<code>&amp;self</code>或<code>&amp;mut self</code>的规则是什么?</h2><ul><li>当一个函数需要消耗值的时候，使用<code>self</code>。</li><li>当一个函数只需要一个对值的只读引用时，使用<code>&amp;self</code>。</li><li>当一个函数需要在不消耗该值的情况下改变该值时，使用<code>&amp;mut self</code>。</li></ul><h2 id="我怎样才能理解借用检查器？"><a href="#我怎样才能理解借用检查器？" class="headerlink" title="我怎样才能理解借用检查器？"></a>我怎样才能理解借用检查器？</h2><p>借用检查器在评估 Rust 代码时只应用一些规则，这些规则可以在 Rust 书的<a href="https://doc.rust-lang.org/book/ch15-02-deref.html">借用部分</a>中找到。这些规则是：</p><blockquote><p>首先，任何借用必须持续的范围不大于所有者的范围。第二，你可以有这两种借用中的一种或另一种，但不能同时存在：</p><ul><li>对一个资源的一个或多个引用（&amp;T）。</li><li>一个可变的引用（&amp;mut T）。</li></ul></blockquote><p>虽然这些规则本身很简单，但持续地遵守这些规则并不容易，特别是对于那些不习惯推理寿命和所有权的人来说。</p><p>了解借用检查器的第一步是阅读它产生的错误。为了确保借用检查器在解决它所发现的问题方面提供高质量的帮助，我们做了大量的工作。当你遇到借用检查器的问题时，第一步是慢慢地、仔细地阅读所报告的错误，只有在理解了所描述的错误之后，才能接近代码。</p><p>第二步是熟悉 Rust 标准库提供的所有权和可变性相关的容器类型，包括<a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a>、<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>和<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a>。这些都是表达某些所有权和可变性情况的有用和必要的工具，并且被写成性能代价最小。</p><p>理解借用检查器最重要的一个部分是实践。Rust 的强静态分析保证是严格的，与许多程序员之前的工作有很大不同。需要一些时间才能完全适应一切。</p><p>如果你发现自己在借用检查器上挣扎，或者没有耐心了，请随时联系<a href="https://www.rust-lang.org/community"> Rust 社区</a>寻求帮助。</p><h2 id="什么时候Rc有用？"><a href="#什么时候Rc有用？" class="headerlink" title="什么时候Rc有用？"></a>什么时候<code>Rc</code>有用？</h2><p>这在<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>的官方文档中有所涉及，Rust 的非原子引用计算的指针类型。简而言之，<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>和它的线程安全表亲<a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>对于表达共享所有权是很有用的，当没有人访问相关内存时，系统会自动将其取消。</p><h2 id="我如何从一个函数中返回一个闭包？"><a href="#我如何从一个函数中返回一个闭包？" class="headerlink" title="我如何从一个函数中返回一个闭包？"></a>我如何从一个函数中返回一个闭包？</h2><p>要从一个函数中返回一个闭包，它必须是一个“移动闭包”，也就是说，闭包是用<code>move</code>关键字声明的。正如<a href="https://doc.rust-lang.org/book/ch13-01-closures.html"> Rust 书中所解释的</a>，这使得闭包拥有自己的捕获变量的副本，独立于其父级堆栈框架。否则，返回一个闭包将是不安全的，因为它将允许访问不再有效的变量；换句话说：它将允许读取可能无效的内存。闭包还必须被包裹在一个<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>中，这样它就被分配在堆上。阅读更多关于这个的内容<a href="https://doc.rust-lang.org/book/ch13-01-closures.html">在书中</a>。</p><h2 id="什么是-deref-coercion，它是如何工作的？"><a href="#什么是-deref-coercion，它是如何工作的？" class="headerlink" title="什么是 deref coercion，它是如何工作的？"></a>什么是 deref coercion，它是如何工作的？</h2><p><a href="https://doc.rust-lang.org/book/ch15-02-deref.html">deref coercion</a> 是一个很方便的 coercion。自动将对指针的引用(例如, <code>&amp;Rc&lt;T&gt;</code> 或 <code>&amp;Box&lt;T&gt;</code>)转换为对其内容的引用（例如，<code>&amp;T</code>）。Deref coercion 的存在是为了使 Rust 的使用更符合人体工程学，并通过<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>特性实现。</p><p>Deref 的实现表明实现类型可以通过调用<code>deref</code>方法转换为目标类型，该方法接收对调用类型的不可变的引用，并返回对目标类型的引用（具有相同的生命周期）。<code>*</code>前缀操作符是<code>deref</code>方法的简写。</p><p>它们被称“coercions”，因为下面的规则，这里引用了<a href="https://doc.rust-lang.org/book/ch15-02-deref.html"> Rust 书</a>。</p><blockquote><p>如果你有一个类型<code>U</code>，并且它实现了<code>Deref&lt;Target=T&gt;</code>，那么<code>&amp;U</code>的值将自动被强制为<code>T</code>。</p></blockquote><p>例如，如果你有一个<code>&amp;Rc&lt;String&gt;</code>，它将通过这个规则联合成一个<code>&amp;String</code>，然后以同样的方式联合成一个<code>&amp;str</code>。因此，如果一个函数需要一个<code>&amp;str</code>参数，你可以直接传入一个<code>&amp;Rc&lt;String&gt;</code>，所有的强制都通过<code>Deref</code>特性自动处理。</p><p>最常见的 Derefcoercions 种类是：</p><ul><li><code>&amp;Rc&lt;T&gt;</code>到<code>&amp;T</code>。</li><li><code>&amp;Box&lt;T&gt;</code>到<code>&amp;T</code>。</li><li><code>&amp;Arc&lt;T&gt;</code>到<code>&amp;T</code>。</li><li><code>&amp;Vec&lt;T&gt;</code>改为<code>&amp;[T]</code>。</li><li><code>&amp;String</code>改为<code>&amp;str</code>。</li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="为什么是生命周期"><a href="#为什么是生命周期" class="headerlink" title="为什么是生命周期?"></a>为什么是生命周期?</h2><p>生命周期是 Rust 对内存安全问题的回答。它允许 Rust 确保内存安全而不需要付出垃圾回收的性能代价。它们是基于各种学术工作的。</p><h2 id="为什么生命周期的语法是这样的？"><a href="#为什么生命周期的语法是这样的？" class="headerlink" title="为什么生命周期的语法是这样的？"></a>为什么生命周期的语法是这样的？</h2><p><code>&#39;a</code>语法来自于 ML 系列编程语言，其中<code>&#39;a</code>用于表示一个通用类型参数。对于 Rust 来说，这种语法必须是明确的、明显的，并且适合在类型声明中与 traits 和 reference 一起使用。其他的语法已经被讨论过了，但是还没有其他的语法被证明是更好的。</p><h2 id="我如何将一个借来的东西返回到我从函数中创建的东西？"><a href="#我如何将一个借来的东西返回到我从函数中创建的东西？" class="headerlink" title="我如何将一个借来的东西返回到我从函数中创建的东西？"></a>我如何将一个借来的东西返回到我从函数中创建的东西？</h2><p>你需要确保借来的东西会超过函数的寿命。这可以通过将输出寿命与一些输入寿命绑定来实现，比如说。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Pool</span></span> = TypedArena&lt;Thing&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的生命周期只是为了说明问题而明确写的；它可以通过后面描述的删除规则省略。</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">create_borrowed</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(pool: &amp;<span class="symbol">&#x27;a</span> Pool,</span><br><span class="line">                       x: <span class="built_in">i32</span>,</span><br><span class="line">                       y: <span class="built_in">i32</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> Thing &#123;</span><br><span class="line">    pool.alloc(Thing &#123; x: x, y: y &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是通过返回一个自有类型如<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>来完全消除引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">happy_birthday</span></span>(name: &amp;<span class="built_in">str</span>, age: <span class="built_in">i64</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span> (<span class="string">&quot;Hello &#123;&#125;! You&#x27;re &#123;&#125; years old!&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法比较简单，但往往会导致不必要的分配。</p><h2 id="为什么有些引用有寿命，如-amp-39-a-T，而有些则没有，如-amp-T？"><a href="#为什么有些引用有寿命，如-amp-39-a-T，而有些则没有，如-amp-T？" class="headerlink" title="为什么有些引用有寿命，如&amp;&#39;a T，而有些则没有，如&amp;T？"></a>为什么有些引用有寿命，如<code>&amp;&#39;a T</code>，而有些则没有，如<code>&amp;T</code>？</h2><p>事实上, <em>所有</em>引用类型都有一个寿命, 但大多数时候你不必明确写出<br>它是明确的。规则如下。</p><ol><li><p>在一个函数体中，你永远不需要明确地写出生命周期；正确的值应该总是被推断出来的。</p></li><li><p>在一个函数的<em>签名</em>中（例如，在其参数的类型或其返回类型中），你<em>可能</em>会需要写一个生命周期。这里的生命周期使用一个简单的默认方案，称为<a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">“lifetime elision”</a>。它由以下三条规则组成：</p><ul><li>在一个函数的参数中，每一个被省略的生命周期都成为一个独立的生命周期参数。</li><li>如果正好只有一个输入生命周期，无论是否被省略，该生命周期都被分配给所有返回值中被省略的生命周期。</li><li>如果有多个输入生命周期，但其中一个是 &amp;self 或 &amp;mut self，那么 self 的生命周期将被分配给所有被忽略的返回生命周期。</li></ul></li><li><p>最后，在“结构”或“枚举”的定义中，所有的生命周期必须被明确地声明。</p></li></ol><p>如果这些规则导致了编译错误，Rust 编译器将提供一个错误信息，指出所造成的错误，并根据推理过程的哪一步造成的错误，提出一个潜在的解决方案。</p><h2 id="Rust如何保证“没有空指针”和“没有悬空指针”"><a href="#Rust如何保证“没有空指针”和“没有悬空指针”" class="headerlink" title="Rust如何保证“没有空指针”和“没有悬空指针”?"></a>Rust如何保证“没有空指针”和“没有悬空指针”?</h2><p>构造一个<code>&amp;Foo</code>或<code>&amp;mut Foo</code>类型的值的唯一方法是指定一个引用所指向的<code>Foo</code>类型的现有值。引用在给定的代码区域内（引用的生命周期）“借用”原始值，在借用期间，被借用的值不能被移动或销毁。</p><h2 id="我如何用“null”来表达一个值的缺失"><a href="#我如何用“null”来表达一个值的缺失" class="headerlink" title="我如何用“null”来表达一个值的缺失?"></a>我如何用“null”来表达一个值的缺失?</h2><p>你可以用<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>类型来做，它可以是<code>Some(T)</code>或<code>None</code>。<code>Some(T)</code>表示其中包含一个<code>T</code>类型的值，而<code>None</code>表示没有值。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是“单态化”"><a href="#什么是“单态化”" class="headerlink" title="什么是“单态化”?"></a>什么是“单态化”?</h2><p>单态化是将泛型函数（或结构）的每一次使用都基于调用该函数（或使用该结构）的参数类型用特定的实例进行单态化。</p><p>在单态化过程中，泛型函数的一个新副本被翻译为该函数实例化的每一组独特类型。这与 C++ 使用的策略相同。它的结果是为每个调用点专门设计的快速代码，并且是静态调度的，其代价是用许多不同类型实例化的函数会导致“代码膨胀”，即多个函数实例会导致比用其他翻译策略创建的二进制文件更大。</p><p>接受<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html"> Trait Object </a>而不是类型参数的函数不进行单态化。相反，特质对象上的方法在运行时被动态地分配。</p><h2 id="一个函数和一个没有捕获任何变量的闭包之间有什么区别？"><a href="#一个函数和一个没有捕获任何变量的闭包之间有什么区别？" class="headerlink" title="一个函数和一个没有捕获任何变量的闭包之间有什么区别？"></a>一个函数和一个没有捕获任何变量的闭包之间有什么区别？</h2><p>函数和闭包在操作上是等价的，但由于它们的实现方式不同，所以有不同的运行时表示。</p><p>函数是语言的内置基元，而闭包本质上是三种特征之一的语法糖。<a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, 和 <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>。当你创建一个闭包时，Rust 编译器会自动创建一个结构，实现这三个结构的相应特性，并将捕获的环境变量作为成员，并使该结构可以作为一个函数被调用。裸露的函数不能捕获环境。</p><p>这些特征之间的最大区别是它们如何接受“self”参数。<a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>使用<code>&amp;self</code>，<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>使用<code>&amp;mut self</code>，而<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>使用<code>self</code>。</p><p>即使一个闭包没有捕获任何环境变量，它在运行时也被表示为两个指针，与其他闭包相同。</p><h2 id="什么是高阶类型，为什么我需要它们，以及为什么-Rust-没有它们？"><a href="#什么是高阶类型，为什么我需要它们，以及为什么-Rust-没有它们？" class="headerlink" title="什么是高阶类型，为什么我需要它们，以及为什么 Rust 没有它们？"></a>什么是高阶类型，为什么我需要它们，以及为什么 Rust 没有它们？</h2><p>高等类型是指具有未填充参数的类型。类型构造器，如<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>，<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>，和<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>都是高类型类型的例子：每个类型都需要一些额外的类型参数，以便实际表示一个特定的类型，如<code>Vec&lt;u32&gt;</code>。对高类型的支持意味着这些“不完整”的类型可以在任何可以使用“完整”类型的地方使用，包括作为函数的泛型。</p><p>任何完整的类型，像<a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>，<a href="https://doc.rust-lang.org/std/primitive.bool.html"><code>bool</code></a>或<a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>都属于<code>*</code>类型（这个符号来自类型理论领域）。一个有一个参数的类型，像<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>是属于<code>* -&gt; *</code>，意思是<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>接收一个完整的类型，像<a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>，并返回一个完整类型<code>Vec&lt;i32&gt;</code>。一个有三个参数的类型，如<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap&lt;K, V, S&gt;</code></a>是一种<code>* -&gt; * -&gt; * -&gt; *</code>，并接收三个完整的类型（如<a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>，<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>，和<a href="https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html"><code>RandomState</code></a>），产生一个新的完整类型<code>HashMap&lt;i32, String, RandomState&gt;</code>。</p><p>除了这些例子之外，类型构造函数还可以接受<em>生命周期</em>参数，我们将其表示为<code>Lt</code>。例如，<code>slice::Iter</code>的种类是<code>Lt -&gt; * -&gt; *</code>，因为它必须像<code>Iter&lt;&#39;a, u32&gt;</code>一样被实例化。</p><p>由于缺乏对高阶类型的支持，因此很难编写某些类型的通用代码。对于像迭代器这样的概念的抽象来说，这尤其成问题，因为迭代器通常至少要在一个生命周期内进行参数化。这反过来又阻碍了对 Rust 的集合进行抽象的 traits 的创建。</p><p>另一个常见的例子是像 functors 或 monads 这样的概念，它们都是类型构造函数，而不是单一类型。</p><p>Rust 目前并不支持高类型的类型，因为与我们想做的其他改进相比，这并不是一个优先事项。由于该设计是一个重大的、跨领域的变化，我们也想谨慎地对待它。但是目前缺乏支持并没有什么内在的原因。</p><h2 id="通用类型中像-lt-T-Foo-gt-这样的命名类型参数是什么意思"><a href="#通用类型中像-lt-T-Foo-gt-这样的命名类型参数是什么意思" class="headerlink" title="通用类型中像&lt;T=Foo&gt;这样的命名类型参数是什么意思?"></a>通用类型中像<code>&lt;T=Foo&gt;</code>这样的命名类型参数是什么意思?</h2><p>这些被称为<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types">关联类型</a>，它们允许表达不能用<code>where</code>子句表达的特征边界。例如，一个泛型约束<code>X: Bar&lt;T=Foo&gt;</code>意味着”<code>X</code>必须实现 trait <code>Bar</code>，在<code>Bar</code>的实现中，<code>X</code>必须选择<code>Foo</code>作为<code>Bar</code>的关联类型<code>T</code>“。这种约束不能通过<code>where</code>子句来表达的例子包括像<code>Box&lt;Bar&lt;T=Foo&gt;&gt;</code>这样的 trait object。</p><p>关联类型的存在是因为泛型经常涉及类型家族，其中一个类型决定了一个家族中的所有其他类型。例如，一个图的 trait 可能将图本身作为其<code>Self</code>类型，并有节点和边的关联类型。每个图的类型唯一地决定了相关的类型。使用关联类型使这些类型族的工作更加简洁，并且在许多情况下提供更好的类型推理。</p><h2 id="我可以重载运算符吗-哪些操作符，如何操作？"><a href="#我可以重载运算符吗-哪些操作符，如何操作？" class="headerlink" title="我可以重载运算符吗? 哪些操作符，如何操作？"></a>我可以重载运算符吗? 哪些操作符，如何操作？</h2><p>你可以使用它们的关联特性为各种运算符提供自定义的实现。<a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a>代表<code>+</code>，<a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a>代表<code>*</code>，等等。它看起来像这样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Add <span class="keyword">for</span> Foo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Foo;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: Foo) -&gt; Self::Output &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Adding!&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下操作符可以被重载。</p><table><thead><tr><th align="left">Operation</th><th align="left">Trait</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td></tr><tr><td align="left"><code>+=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html"><code>AddAssign</code></a></td></tr><tr><td align="left"><code>binary -</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td></tr><tr><td align="left"><code>-=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html"><code>SubAssign</code></a></td></tr><tr><td align="left"><code>*</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td></tr><tr><td align="left"><code>*=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html"><code>MulAssign</code></a></td></tr><tr><td align="left"><code>/</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td></tr><tr><td align="left"><code>/=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html"><code>DivAssign</code></a></td></tr><tr><td align="left"><code>unary -</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html"><code>Neg</code></a></td></tr><tr><td align="left"><code>%</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td></tr><tr><td align="left"><code>%=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html"><code>RemAssign</code></a></td></tr><tr><td align="left"><code>&amp;</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html"><code>BitAnd</code></a></td></tr><tr><td align="left"><code>&amp;=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html"><code>BitAndAssign</code></a></td></tr><tr><td align="left"><code>&#124;</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html"><code>BitOr</code></a></td></tr><tr><td align="left"><code>&#124;=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html"><code>BitOrAssign</code></a></td></tr><tr><td align="left"><code>^</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXor.html"><code>BitXor</code></a></td></tr><tr><td align="left"><code>^=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html"><code>BitXorAssign</code></a></td></tr><tr><td align="left"><code>!</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Not.html"><code>Not</code></a></td></tr><tr><td align="left"><code>&lt;&lt;</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Shl.html"><code>Shl</code></a></td></tr><tr><td align="left"><code>&lt;&lt;=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html"><code>ShlAssign</code></a></td></tr><tr><td align="left"><code>&gt;&gt;</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Shr.html"><code>Shr</code></a></td></tr><tr><td align="left"><code>&gt;&gt;=</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html"><code>ShrAssign</code></a></td></tr><tr><td align="left"><code>*</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a></td></tr><tr><td align="left"><code>mut *</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a></td></tr><tr><td align="left"><code>[]</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a></td></tr><tr><td align="left"><code>mut []</code></td><td align="left"><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a></td></tr></tbody></table><h2 id="为什么要在Eq-PartialEq和Ord-PartialOrd之间划分？"><a href="#为什么要在Eq-PartialEq和Ord-PartialOrd之间划分？" class="headerlink" title="为什么要在Eq/PartialEq和Ord/PartialOrd之间划分？"></a>为什么要在<code>Eq</code>/<code>PartialEq</code>和<code>Ord</code>/<code>PartialOrd</code>之间划分？</h2><p>在 Rust 中，有一些类型的值只有部分排序，或者只有部分相等。部分排序的意思是，在给定的类型中可能存在既不小于也不大于对方的值。部分平等意味着可能有给定类型的值不等于自己。</p><p>浮点类型（<a href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>和<a href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>）是每种类型的很好的例子。任何浮点类型都可以有<code>NaN</code>（意思是“不是一个数字”）的值。<code>NaN</code>不等于自己（<code>NaN == NaN</code>是 false），也不小于或大于任何其他浮点值。因此，<a href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>和[<code>f64</code>]都实现了<a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>和<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>，但没有实现<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>和``Eq`]<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a>。</p><p>正如在<a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E8%83%BD%E6%AF%94%E8%BE%83%E6%B5%AE%E7%82%B9%E6%95%B0%E6%88%96%E7%94%A8%E5%AE%83%E4%BB%AC%E4%BD%9C%E4%B8%BAHashMap%E6%88%96BTreeMap%E7%9A%84%E9%94%AE">先前关于 floats 的问题</a>中解释的那样，这些区别很重要，因为有些集合依赖于总排序/equality，以便给出正确的结果。</p><h1 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h1><h2 id="如何将一个文件读成一个“字符串”"><a href="#如何将一个文件读成一个“字符串”" class="headerlink" title="如何将一个文件读成一个“字符串”?"></a>如何将一个文件读成一个“字符串”?</h2><p>使用<a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string()</code></a>方法, 这个方法是在<a href="https://doc.rust-lang.org/std/io/index.html"><code>std::io</code></a>中的<a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a>特性上定义。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="keyword">let</span> _ = File::open(path)?.read_to_string(&amp;<span class="keyword">mut</span> s);  <span class="comment">// `s` contains the contents of &quot;foo.txt&quot;</span></span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> read_file(<span class="string">&quot;foo.txt&quot;</span>) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got file contents!&quot;</span>),</span><br><span class="line">        <span class="literal">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Getting file contents failed with error: &#123;&#125;&quot;</span>, err)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何有效地读取文件输入"><a href="#如何有效地读取文件输入" class="headerlink" title="如何有效地读取文件输入?"></a>如何有效地读取文件输入?</h2><p><a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a>类型实现了<a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a>特性，它有多种函数用于读写数据，包括<a href="https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read"><code>read()</code></a>, <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_end"><code>read_to_end()</code></a>, <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.bytes"><code>bytes()</code></a>, <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.chars"><code>chars()</code></a>, 和<a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.take"><code>take()</code></a> 。这些函数中的每一个都从一个给定的文件中读取一定量的输入。<a href="https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read"><code>read()</code></a> 在一次调用中读取底层系统所能提供的输入量。<a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_end"><code>read_to_end()</code></a> 将整个缓冲区读入一个向量，需要多少空间就分配多少。<a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.bytes"><code>bytes()</code></a>和<a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.chars"><code>chars()</code></a>分别允许你对文件的字节和字符进行迭代。最后，<a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.take"><code>take()</code></a>允许你从文件中读取任意数量的字节。总的来说，这些应该允许你有效地读入任何你需要的数据。</p><p>对于缓冲读取，使用<a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a>结构，这有助于减少读取时的系统调用数量。</p><h2 id="我如何在-Rust-中进行异步输入-输出？"><a href="#我如何在-Rust-中进行异步输入-输出？" class="headerlink" title="我如何在 Rust 中进行异步输入/输出？"></a>我如何在 Rust 中进行异步输入/输出？</h2><p>使用 <a href="https://github.com/tokio-rs/tokio">tokio</a>。</p><h2 id="我如何在-Rust-中获得命令行参数"><a href="#我如何在-Rust-中获得命令行参数" class="headerlink" title="我如何在 Rust 中获得命令行参数?"></a>我如何在 Rust 中获得命令行参数?</h2><p>最简单的方法是使用<a href="https://doc.rust-lang.org/std/env/struct.Args.html"><code>Args</code></a>，它提供了一个输入参数的迭代器。</p><p>如果你正在寻找更强大的库，在 crates.io 上有<a href="https://crates.io/keywords/argument">一些选项</a>。</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="为什么-Rust-没有异常？"><a href="#为什么-Rust-没有异常？" class="headerlink" title="为什么 Rust 没有异常？"></a>为什么 Rust 没有异常？</h2><p>异常使控制流的理解复杂化，它们在类型系统之外表达有效性/无效性，而且它们与多线程代码（Rust 的主要焦点）的互操作性很差。</p><p>Rust 更倾向于采用基于类型的错误处理方法，这在书中有<a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">详细介绍</a>。这与 Rust 的控制流、并发性和其他一切都更加吻合。</p><h2 id="到处都有-unwrap-’是怎么回事"><a href="#到处都有-unwrap-’是怎么回事" class="headerlink" title="到处都有`unwrap()’是怎么回事?"></a>到处都有`unwrap()’是怎么回事?</h2><p><code>unwrap()</code>是一个提取<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>或<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>里面的值的函数，如果没有值就会 panic。</p><p><code>unwrap()</code>不应该是你处理预期出现的错误的默认方式，例如用户输入不正确。在生产代码中，它应该被视为一个断言，即该值是非空的，如果违反，将使程序崩溃。</p><p>它对快速原型也很有用，在那里你还不想处理错误，或者在博客文章中，错误处理会分散对重点的注意力。</p><h2 id="当我试图运行使用try-宏的示例代码时，为什么我得到一个错误"><a href="#当我试图运行使用try-宏的示例代码时，为什么我得到一个错误" class="headerlink" title="当我试图运行使用try!宏的示例代码时，为什么我得到一个错误?"></a>当我试图运行使用<code>try!</code>宏的示例代码时，为什么我得到一个错误?</h2><p>这可能是函数的返回类型的问题。<a href="https://doc.rust-lang.org/std/macro.try!.html"><code>try!</code></a>宏要么从<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>中提取数值，要么提前返回，错误是<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>携带的。这意味着<a href="https://doc.rust-lang.org/std/macro.try!.html"><code>try</code></a>只对返回<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>本身的函数有效，其中<code>Err</code>构造的类型实现了<code>From::from(err)</code>。特别是，这意味着<a href="https://doc.rust-lang.org/std/macro.try!.html"><code>try!</code></a>宏不能在<code>main</code>函数中工作。</p><h2 id="有没有比到处都是“Result”更简单的方法来做错误处理？"><a href="#有没有比到处都是“Result”更简单的方法来做错误处理？" class="headerlink" title="有没有比到处都是“Result”更简单的方法来做错误处理？"></a>有没有比到处都是“Result”更简单的方法来做错误处理？</h2><p>如果你正在寻找一种方法来避免在其他人的代码中处理<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>，总是有<a href="https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap"><code>unwrap()</code></a>，但这可能不是你想要的。<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>是一个指标，表明某些计算可能会或可能不会成功完成。要求你明确地处理这些失败是 Rust 鼓励健壮性的方式之一。Rust 提供了像<a href="https://doc.rust-lang.org/std/macro.try!.html"><code>try!</code>宏</a>这样的工具，使处理失败的过程符合人体工程学。</p><p>如果你真的不想处理错误，可以使用<a href="https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap"><code>unwrap()</code></a>，但要知道，这样做意味着代码在失败时 panic，这通常会导致关闭进程。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="我可以在没有“不安全”块的情况下跨线程使用静态值吗？"><a href="#我可以在没有“不安全”块的情况下跨线程使用静态值吗？" class="headerlink" title="我可以在没有“不安全”块的情况下跨线程使用静态值吗？"></a>我可以在没有“不安全”块的情况下跨线程使用静态值吗？</h2><p>如果是同步的，修改是安全的。修改一个静态的<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>（通过<a href="https://crates.io/crates/lazy_static/">lazy-static</a> crate 懒惰地初始化）不需要一个<code>unsafe</code>块，修改一个静态的<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html"><code>AtomicUsize</code></a>（可以不用 lazy_static 初始化）也是如此。</p><p>更一般地说，如果一个类型实现了<a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>，并且没有实现<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>，它<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable">可以在<code>static</code>中使用</a>。</p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><h2 id="我可以写一个宏来生成标识符吗"><a href="#我可以写一个宏来生成标识符吗" class="headerlink" title="我可以写一个宏来生成标识符吗?"></a>我可以写一个宏来生成标识符吗?</h2><p>目前不能。Rust 的宏是<a href="https://en.wikipedia.org/wiki/Hygienic_macro">“卫生宏”</a>，它有意避免捕捉或创建可能与其他标识符发生意外碰撞的标识符。它们的功能与通常与 C 预处理器相关的宏的风格明显不同。宏调用只能出现在被明确支持的地方：项目、方法声明、语句、表达式和模式。这里，“方法声明”指的是可以放置方法的空白处。它们不能被用来完成部分方法声明。按照同样的逻辑，它们也不能用来完成一个部分变量声明。</p><h1 id="Debugging-and-Tooling"><a href="#Debugging-and-Tooling" class="headerlink" title="Debugging and Tooling"></a>Debugging and Tooling</h1><h2 id="我如何调试-Rust-程序？"><a href="#我如何调试-Rust-程序？" class="headerlink" title="我如何调试 Rust 程序？"></a>我如何调试 Rust 程序？</h2><p>Rust 程序可以使用 <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">gdb</a> 或 <a href="http://lldb.llvm.org/tutorial.html">lldb</a> 进行调试，与 C 和 C++ 相同。事实上，每一个 Rust 的安装都带有 rust-gdb 和 rust-lldb 中的一个或两个（取决于平台支持）。这些是对 gdb 和 lldb 的封装，并启用了 Rust pretty-printing。</p><h2 id="rustc说标准库代码中发生了-panic。我如何定位我的代码中的错误？"><a href="#rustc说标准库代码中发生了-panic。我如何定位我的代码中的错误？" class="headerlink" title="rustc说标准库代码中发生了 panic。我如何定位我的代码中的错误？"></a><code>rustc</code>说标准库代码中发生了 panic。我如何定位我的代码中的错误？</h2><p>这个错误通常是由客户端代码中<a href="https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap"><code>unwrap()</code>ing</a>一个<code>None</code>或<code>Err</code>引起的。通过设置环境变量<code>RUST_BACKTRACE=1</code>来启用回溯，有助于获得更多信息。在调试模式下编译（默认为“cargo build”）也有帮助。使用调试器，如提供的<code>rust-gdb</code>或<code>rust-lldb</code>也很有帮助。</p><h2 id="我应该使用什么-IDE？"><a href="#我应该使用什么-IDE？" class="headerlink" title="我应该使用什么 IDE？"></a>我应该使用什么 IDE？</h2><p>Rust 的开发环境有很多选择，所有这些都在非官方的 <a href="https://areweideyet.com/">IDE 支持页面</a>上有详细说明。</p><h1 id="Low-Level"><a href="#Low-Level" class="headerlink" title="Low-Level"></a>Low-Level</h1><h2 id="我怎样才能memcpy字节"><a href="#我怎样才能memcpy字节" class="headerlink" title="我怎样才能memcpy字节?"></a>我怎样才能<code>memcpy</code>字节?</h2><p>如果你想安全地克隆一个现有的分片，你可以使用<a href="https://doc.rust-lang.org/std/primitive.slice.html#method.clone_from_slice"><code>clone_from_slice</code></a>。</p><p>要复制可能重叠的字节，使用<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>copy</code></a>。要复制不重叠的字节，使用<a href="https://doc.rust-lang.org/std/ptr/fn.copy_nonoverlapping.html"><code>copy_nonoverlapping</code></a>。这两个函数都是“不安全”的，因为它们都可以被用来破坏语言的安全保证。在使用它们时要注意。</p><h2 id="没有标准库，Rust-能合理地运行吗？"><a href="#没有标准库，Rust-能合理地运行吗？" class="headerlink" title="没有标准库，Rust 能合理地运行吗？"></a>没有标准库，Rust 能合理地运行吗？</h2><p>当然可以。Rust 程序可以使用<code>#![no_std]</code>属性设置为不加载标准库。设置了这个属性后，你可以继续使用 Rust 核心库，它只是平台无关的原语。因此，它不包括 IO、并发性、堆分配等。</p><h2 id="我可以用-Rust-写一个操作系统吗？"><a href="#我可以用-Rust-写一个操作系统吗？" class="headerlink" title="我可以用 Rust 写一个操作系统吗？"></a>我可以用 Rust 写一个操作系统吗？</h2><p>是的！事实上，有<a href="http://wiki.osdev.org/Rust">几个正在进行的项目就是这样</a>。</p><h2 id="我如何在文件或其他字节流中以大数或小数格式读写数字类型如i32或f64"><a href="#我如何在文件或其他字节流中以大数或小数格式读写数字类型如i32或f64" class="headerlink" title="我如何在文件或其他字节流中以大数或小数格式读写数字类型如i32或f64?"></a>我如何在文件或其他字节流中以大数或小数格式读写数字类型如<code>i32</code>或<code>f64</code>?</h2><p>你应该看看 <a href="https://docs.rs/byteorder">byteorder crate</a>，它提供了相应的实用程序。</p><h2 id="Rust-是否保证一个特定的数据布局？"><a href="#Rust-是否保证一个特定的数据布局？" class="headerlink" title="Rust 是否保证一个特定的数据布局？"></a>Rust 是否保证一个特定的数据布局？</h2><p>默认情况下不是。在一般情况下，<code>enum</code>和<code>struct</code>的布局是未定义的。这允许编译器进行潜在的优化，比如为判别式重新使用填充物，压缩嵌套的<code>enum</code>的变体，重新排序字段以移除填充物，等等。不携带数据的<code>enum</code>（“C-like”）有资格拥有一个定义的表示。这种<code>枚举</code>很容易区分，因为它们只是一个没有数据的名字列表。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">snum CLike &#123;</span><br><span class="line">    A,</span><br><span class="line">    B = <span class="number">32</span>,</span><br><span class="line">    C = <span class="number">34</span>,</span><br><span class="line">    D</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>＃[repr(C)]</code>属性可以应用于这些“enum”，使它们在同等的 C 代码中具有相同的表示。这允许在 FFI 代码中使用 Rust 的“enum”，而在大多数情况下也使用 C 的“enum”。该属性也可以应用于<code>struct</code>，以获得与<code>C struct</code>相同的布局。</p><h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><h2 id="在-Rust-中表达特定平台行为的习惯性方法是什么？"><a href="#在-Rust-中表达特定平台行为的习惯性方法是什么？" class="headerlink" title="在 Rust 中表达特定平台行为的习惯性方法是什么？"></a>在 Rust 中表达特定平台行为的习惯性方法是什么？</h2><p>平台特定行为可以用<a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">条件编译属性</a>来表达，如<code>target_os</code>, <code>target_family</code>, <code>target_endian</code>，等等。</p><h2 id="Rust-可以用于-Android-iOS-编程吗？"><a href="#Rust-可以用于-Android-iOS-编程吗？" class="headerlink" title="Rust 可以用于 Android/iOS 编程吗？"></a>Rust 可以用于 Android/iOS 编程吗？</h2><p>是的，它可以! 在 <a href="https://github.com/tomaka/android-rs-glue">Android</a>和 <a href="https://www.bignerdranch.com/blog/building-an-ios-app-in-rust-part-1/">iOS</a> 中都已经有使用 Rust 的例子。它确实需要一些工作来设置，但 Rust 在这两个平台上的功能都很好。</p><h2 id="我可以在网络浏览器中运行我的-Rust-程序吗？"><a href="#我可以在网络浏览器中运行我的-Rust-程序吗？" class="headerlink" title="我可以在网络浏览器中运行我的 Rust 程序吗？"></a>我可以在网络浏览器中运行我的 Rust 程序吗？</h2><p>有可能。Rust 对<a href="http://asmjs.org/">asm.js</a>和<a href="http://webassembly.org/">WebAssembly</a>都有<a href="https://davidmcneil.gitbooks.io/the-rusty-web/">实验性支持</a>。</p><h2 id="我如何在-Rust-中进行交叉编译？"><a href="#我如何在-Rust-中进行交叉编译？" class="headerlink" title="我如何在 Rust 中进行交叉编译？"></a>我如何在 Rust 中进行交叉编译？</h2><p>在 Rust 中可以进行交叉编译，但需要<a href="https://github.com/japaric/rust-cross/blob/master/README.md">一点工作</a>来设置。每个 Rust 编译器都是一个交叉编译器，但是库需要针对目标平台进行交叉编译。</p><p>Rust 确实为每个支持的平台分发了标准库的副本，这些副本包含在分发页面上找到的每个构建目录的<code>rust-std-*</code>文件中，但目前还没有自动安装的方法。</p><h1 id="mod-和-crate"><a href="#mod-和-crate" class="headerlink" title="mod 和 crate"></a>mod 和 crate</h1><h2 id="mod-和-crate-之间的关系是什么？"><a href="#mod-和-crate-之间的关系是什么？" class="headerlink" title="mod 和 crate 之间的关系是什么？"></a>mod 和 crate 之间的关系是什么？</h2><ul><li>crate 是一个编译单元，它是 Rust 编译器可以操作的最小的代码量。</li><li>mod 是 crate 内的一个（可能是嵌套的）代码组织单元。</li><li>一个 crate 包含一个隐含的、未命名的顶层 mod。</li><li>递归定义可以跨越 mod，但不能跨越 crate。</li></ul><h2 id="为什么-Rust-编译器找不到我正在使用的这个库"><a href="#为什么-Rust-编译器找不到我正在使用的这个库" class="headerlink" title="为什么 Rust 编译器找不到我正在使用的这个库?"></a>为什么 Rust 编译器找不到我正在<code>使用</code>的这个库?</h2><p>有很多可能的答案，但一个常见的错误是没有意识到<code>use</code>声明是相对于 crate root 的。试着改写你的声明，使用它们在你的项目根文件中定义的路径，看看是否能解决这个问题。</p><p>还有“self”和“super”，它们分别将“use”路径区分为相对于当前 mod 或父 mod。</p><p>关于<code>use</code>库的完整信息，请阅读 Rust 书中的<a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">“Packages, Crates, and Modules”</a>一章。</p><h2 id="为什么我必须在-crate-的顶层用mod声明-mod-文件，而不是直接use它们？"><a href="#为什么我必须在-crate-的顶层用mod声明-mod-文件，而不是直接use它们？" class="headerlink" title="为什么我必须在 crate 的顶层用mod声明 mod 文件，而不是直接use它们？"></a>为什么我必须在 crate 的顶层用<code>mod</code>声明 mod 文件，而不是直接<code>use</code>它们？</h2><p>在 Rust 中，有两种方法来声明模块，内联或在另一个文件中。下面是各自的一个例子。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main.rs</span></span><br><span class="line"><span class="keyword">mod</span> hello &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    hello::f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main.rs</span></span><br><span class="line"><span class="keyword">mod</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    hello::f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In hello.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一个例子中，模块被定义在它所使用的同一文件中。在第二个例子中，主文件中的模块声明告诉编译器寻找<code>hello.rs</code>或<code>hello/mod.rs</code>，并加载该文件。</p><p>注意<code>mod</code>和<code>use</code>之间的区别：<code>mod</code>声明一个模块的存在，而<code>use</code>引用一个在其他地方声明的模块，将其内容纳入当前模块的范围。</p><h2 id="我如何配置-Cargo-使用代理？"><a href="#我如何配置-Cargo-使用代理？" class="headerlink" title="我如何配置 Cargo 使用代理？"></a>我如何配置 Cargo 使用代理？</h2><p>参考 <a href="https://rsproxy.cn/">https://rsproxy.cn/</a>。</p><h2 id="为什么我已经“use”了-crate，但编译器还是找不到方法的实现？"><a href="#为什么我已经“use”了-crate，但编译器还是找不到方法的实现？" class="headerlink" title="为什么我已经“use”了 crate，但编译器还是找不到方法的实现？"></a>为什么我已经“use”了 crate，但编译器还是找不到方法的实现？</h2><p>对于定义在 trait 上的方法，你必须明确导入 trait 声明。这意味着仅仅导入一个结构实现 trait 的模块是不够的，你还必须导入 trait 本身。</p><h2 id="为什么编译器不能为我推断出use声明？"><a href="#为什么编译器不能为我推断出use声明？" class="headerlink" title="为什么编译器不能为我推断出use声明？"></a>为什么编译器不能为我推断出<code>use</code>声明？</h2><p>它可能可以，但你也不希望它这样做。虽然在很多情况下，编译器有可能通过简单地寻找给定标识符的定义位置来确定导入的正确模块，但在一般情况下可能不是这样的。<code>rustc</code>中任何用于选择竞争性选项的决策规则，在某些情况下可能会引起惊讶和混乱，Rust 更倾向于明确说明名称的来源。</p><p>例如，编译器可以说，在标识符定义相互竞争的情况下，会选择最早导入的模块的定义。所以如果模块<code>foo</code>和模块<code>bar</code>都定义了标识符<code>baz</code>，但是<code>foo</code>是第一个注册的模块，编译器会插入<code>use foo::baz;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> foo;</span><br><span class="line"><span class="keyword">mod</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use foo::baz  // to be inserted by the compiler.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  baz();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你知道这种情况会发生，也许它可以节省少量的按键，但它也大大增加了当你真正想把<code>baz()</code>变成<code>bar::baz()</code>时出现令人惊讶的错误信息的可能性，而且它通过使函数调用的意义依赖于模块声明而降低了代码的可读性。这些都是我们不愿意做的折衷。</p><p>然而，IDE 可以帮助管理声明，这将给你带来两方面的好处：机器协助拉入名字，但明确声明这些名字的来源。</p><h2 id="我如何进行动态-Rust-库加载？"><a href="#我如何进行动态-Rust-库加载？" class="headerlink" title="我如何进行动态 Rust 库加载？"></a>我如何进行动态 Rust 库加载？</h2><p>用<a href="https://crates.io/crates/libloading"> libloading </a>导入 Rust 中的动态库，它提供了一个跨平台的动态链接系统。</p><h2 id="为什么-crates-io-没有命名空间？"><a href="#为什么-crates-io-没有命名空间？" class="headerlink" title="为什么 crates.io 没有命名空间？"></a>为什么 crates.io 没有命名空间？</h2><p>引用 crates.io 设计的<a href="https://internals.rust-lang.org/t/crates-io-package-policies/1041">官方解释</a>：</p><blockquote><p>在使用 crates.io 的第一个月里，很多人问我们是否有可能引入<a href="https://github.com/rust-lang/crates.io/issues/58">命名空间</a>。</p><p>虽然 namespace 允许多个作者使用单一的、通用的名称，但它们增加了包在 Rust 代码中的引用和人类对包的交流的复杂性。乍一看，它们允许多个作者使用“http”这样的名字，但这仅仅意味着人们需要将这些包称为“wycats’http”或“reem’http”，与“wycats-http”或“reem-http”这样的包名相比没有什么好处。</p><p>当我们研究没有命名空间的软件包生态系统时，我们发现人们倾向于使用更有创意的名字（如<code>nokogiri</code>而不是<code>tenderlove&#39;s libxml2</code>）。这些有创意的名字往往简短易记，部分原因是缺乏任何层次结构。它们使人们更容易简洁明了地交流软件包。他们创造了令人兴奋的品牌。我们已经看到了一些 10,000+ 软件包生态系统的成功，如 NPM 和 RubyGems，它们的社区在一个单一的命名空间内蓬勃发展。</p><p>简而言之，我们认为如果 Piston 选择<code>bvssvni/game-engine</code>这样的名字（允许其他用户选择<code>wycats/game-engine</code>）而不是简单的<code>piston</code>，那么 Cargo 的生态系统就不会好转。</p><p>因为命名空间在很多方面严格来说都比较复杂，而且如果将来有必要的话，还可以兼容添加，所以我们要坚持使用单一的共享命名空间。</p></blockquote><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><h2 id="我怎样才能发出-HTTP-请求"><a href="#我怎样才能发出-HTTP-请求" class="headerlink" title="我怎样才能发出 HTTP 请求?"></a>我怎样才能发出 HTTP 请求?</h2><p>标准库不包括 HTTP 的实现，所以你要使用一个外部的 crate。<br><a href="http://docs.rs/reqwest">reqwest</a> 是最简单的。它建立在<a href="https://github.com/hyperium/hyper">hyper</a>上，用 Rust 编写，但也有<a href="https://crates.io/keywords/http">一些其他的</a>。<a href="https://docs.rs/curl">curl</a> crate 被广泛使用，它提供了与 curl 库的绑定。</p><h2 id="我如何用-Rust-编写-GUI-应用程序？"><a href="#我如何用-Rust-编写-GUI-应用程序？" class="headerlink" title="我如何用 Rust 编写 GUI 应用程序？"></a>我如何用 Rust 编写 GUI 应用程序？</h2><p>有多种方法可以在 Rust 中编写 GUI 应用程序。只要看看<a href="https://github.com/kud1ing/awesome-rust#gui">这个 GUI 框架的列表</a>。</p><h2 id="我怎样才能解析-JSON-XML"><a href="#我怎样才能解析-JSON-XML" class="headerlink" title="我怎样才能解析 JSON/XML?"></a>我怎样才能解析 JSON/XML?</h2><p><a href="https://serde.rs/">Serde</a>是推荐的 Rust 数据序列化和反序列化的库，可以从许多不同的格式中获取。</p><h2 id="是否有一个标准的-2D-矢量和形状-crate"><a href="#是否有一个标准的-2D-矢量和形状-crate" class="headerlink" title="是否有一个标准的 2D+ 矢量和形状 crate?"></a>是否有一个标准的 2D+ 矢量和形状 crate?</h2><p>还没有! 想写一个吗？</p><h2 id="我如何在-Rust-中编写一个-OpenGL-应用程序"><a href="#我如何在-Rust-中编写一个-OpenGL-应用程序" class="headerlink" title="我如何在 Rust 中编写一个 OpenGL 应用程序?"></a>我如何在 Rust 中编写一个 OpenGL 应用程序?</h2><p><a href="https://github.com/tomaka/glium">Glium</a> 是 Rust 中 OpenGL 编程的主要库。<a href="https://github.com/bjz/glfw-rs">GLFW</a> 也是一个可靠的选择。</p><h2 id="我可以用-Rust-写一个视频游戏吗？"><a href="#我可以用-Rust-写一个视频游戏吗？" class="headerlink" title="我可以用 Rust 写一个视频游戏吗？"></a>我可以用 Rust 写一个视频游戏吗？</h2><p>是的，你可以。Rust 的主要游戏编程库是<a href="http://www.piston.rs/">Piston</a>，而且还有一个<a href="https://www.reddit.com/r/rust_gamedev/"> Rust 游戏编程的 subreddit </a>和一个 IRC 频道（<code>#rust-gamedev</code> on <a href="https://wiki.mozilla.org/IRC">Mozilla IRC</a>）。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Rust是面向对象的吗？"><a href="#Rust是面向对象的吗？" class="headerlink" title="Rust是面向对象的吗？"></a>Rust是面向对象的吗？</h2><p>它是多范式的。很多在 OO 语言中可以做的事情在 Rust 中也可以做，但不是所有的事情，也不总是使用你所习惯的那种抽象方式。</p><h2 id="我如何将面向对象的概念映射到-Rust-中？"><a href="#我如何将面向对象的概念映射到-Rust-中？" class="headerlink" title="我如何将面向对象的概念映射到 Rust 中？"></a>我如何将面向对象的概念映射到 Rust 中？</h2><p>这取决于。有一些方法可以将面向对象的概念，如<a href="https://www.reddit.com/r/rust/comments/2sryuw/ideaquestion_about_multiple_inheritence/">多重继承</a>翻译成 Rust，但由于 Rust 不是面向对象的，所以翻译的结果可能与它在 OO 语言中的外观有很大不同。</p><h2 id="我如何处理带有可选参数的结构的配置？"><a href="#我如何处理带有可选参数的结构的配置？" class="headerlink" title="我如何处理带有可选参数的结构的配置？"></a>我如何处理带有可选参数的结构的配置？</h2><p>最简单的方法是在你用来构建结构实例的任何函数中使用<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>类型（通常是<code>new()</code>）。另一种方法是使用构建器模式，在构建所构建的类型之前，只必须调用某些实例化成员变量的函数。</p><h2 id="我如何在-Rust-中做全局变量"><a href="#我如何在-Rust-中做全局变量" class="headerlink" title="我如何在 Rust 中做全局变量?"></a>我如何在 Rust 中做全局变量?</h2><p>Rust 中的全局变量可以使用<code>const</code>声明来实现编译时计算的全局常量，而<code>static</code>可以用来实现可变的全局变量。请注意，修改<code>static mut</code>变量需要使用<code>unsafe</code>，因为它允许数据竞争，而在安全的 Rust 中保证不会发生这种情况。<code>const</code>和<code>static</code>值之间的一个重要区别是，你可以对<code>static</code>值进行引用，但不能对<code>const</code>值进行引用，后者没有指定的内存位置。关于<code>const</code>与<code>static</code>的更多信息，请阅读<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"> Rust 书</a>。</p><h2 id="我如何设置程序化定义的编译时常量？"><a href="#我如何设置程序化定义的编译时常量？" class="headerlink" title="我如何设置程序化定义的编译时常量？"></a>我如何设置程序化定义的编译时常量？</h2><p>Rust 目前对编译时常量的支持有限。你可以使用“const”声明来定义基元（类似于“static”，但是是不可变的，在内存中没有指定的位置），也可以定义“const”函数和固有方法。</p><p>要定义不能通过这些机制定义的程序性常量，可以使用<a href="https://crates.io/crates/lazy_static"><code>lazy-static</code></a> crate，它通过在第一次使用时自动计算常量来模拟编译时计算。</p><h2 id="我可以运行发生在-main-之前的初始化代码吗？"><a href="#我可以运行发生在-main-之前的初始化代码吗？" class="headerlink" title="我可以运行发生在 main 之前的初始化代码吗？"></a>我可以运行发生在 main 之前的初始化代码吗？</h2><p>Rust 没有“在<code>main</code>之前的生命”的概念。最接近的是通过<a href="https://crates.io/crates/lazy_static"><code>lazy-static</code></a> crate 来完成，它通过在静态变量第一次使用时懒散地初始化静态变量来模拟“main之前”。</p><h2 id="Rust-允许-globals-使用非结构表达式的值吗？"><a href="#Rust-允许-globals-使用非结构表达式的值吗？" class="headerlink" title="Rust 允许 globals 使用非结构表达式的值吗？"></a>Rust 允许 globals 使用非结构表达式的值吗？</h2><p>不允许。全局变量不能有一个非结构表达式的构造函数，也不能有一个析构函数。静态构造函数是不可取的，因为确保静态初始化顺序的可移植性是很困难的。main 之前的生命通常被认为是一个错误的功能，所以 Rust 不允许它。</p><p>参见 <a href="http://yosefk.com/c++fqa/ctors.html#fqa-10.12">C++ FQA </a>中关于“静态初始化顺序惨败”的内容，以及<a href="https://ericlippert.com/2013/02/06/static-constructors-part-one/"> Eric Lippert 的博客</a>中关于 C# 的挑战，它也有这种特性。</p><p>你可以用<a href="https://crates.io/crates/lazy_static/"> lazy-static </a>工具箱来近似非内容表达式的 globals。</p><h1 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h1><h2 id="我怎样才能在-Rust-中实现类似-C-语言的struct-X-static-int-X-的东西呢？"><a href="#我怎样才能在-Rust-中实现类似-C-语言的struct-X-static-int-X-的东西呢？" class="headerlink" title="我怎样才能在 Rust 中实现类似 C 语言的struct X { static int X; };的东西呢？"></a>我怎样才能在 Rust 中实现类似 C 语言的<code>struct X &#123; static int X; &#125;;</code>的东西呢？</h2><p>Rust 没有上面代码片断中所示的<code>静态</code>字段。相反，你可以在一个给定的模块中声明一个<code>静态</code>变量，这个变量对该模块是私有的。</p><h2 id="我如何将-C-风格的枚举转换为整数，反之亦然？"><a href="#我如何将-C-风格的枚举转换为整数，反之亦然？" class="headerlink" title="我如何将 C 风格的枚举转换为整数，反之亦然？"></a>我如何将 C 风格的枚举转换为整数，反之亦然？</h2><p>将 C 风格的枚举转换为整数可以用<code>as</code>表达式来完成，比如<code>e as i64</code>(其中<code>e</code>是某个枚举)。</p><p>另一个方向的转换可以用<code>match</code>语句来完成, 它将不同的数字值映射到枚举的不同潜在值上.</p><h2 id="为什么-Rust-程序的二进制大小比-C-程序大"><a href="#为什么-Rust-程序的二进制大小比-C-程序大" class="headerlink" title="为什么 Rust 程序的二进制大小比 C 程序大?"></a>为什么 Rust 程序的二进制大小比 C 程序大?</h2><p>有几个因素导致 Rust 程序默认比功能相当的 C 程序有较大的二进制大小。一般来说，Rust 更倾向于对现实世界的程序性能进行优化，而不是对小程序的大小进行优化。</p><h3 id="单态化"><a href="#单态化" class="headerlink" title="单态化"></a>单态化</h3><p>Rust 对泛型进行了单态化处理，这意味着在程序中每使用一个具体类型，就会生成一个新的泛型函数或类型。这类似于 C++ 中模板的工作方式。例如，在下面的程序中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;T&gt;(t: T) &#123;</span><br><span class="line">    <span class="comment">// ... do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foo(<span class="number">10</span>);       <span class="comment">// i32</span></span><br><span class="line">    foo(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// &amp;str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个不同版本的<code>foo</code>将出现在最终的二进制文件中，一个专门用于<code>i32</code>输入，一个专门用于<code>&amp;str</code>输入。这使得通用函数的静态调度更加有效，但代价是一个更大的二进制文件。</p><h3 id="调试符号"><a href="#调试符号" class="headerlink" title="调试符号"></a>调试符号</h3><p>Rust 程序在编译时保留了一些调试符号，即使是在 release 模式下编译。这些符号用于提供 panic 时的 backtrace，可以用<code>strip</code>或其他调试符号移除工具移除。值得注意的是，用 Cargo 在 release 模式下编译，相当于用 rustc 设置优化级别 3。另一个优化级别（称为<code>s</code>或<code>z</code>）<a href="https://github.com/rust-lang/rust/pull/32386">已被添加</a>，它告诉编译器为大小而不是性能进行优化。</p><h3 id="链接时优化"><a href="#链接时优化" class="headerlink" title="链接时优化"></a>链接时优化</h3><p>Rust 默认不做链接时优化，但可以被指示这样做。这增加了 Rust 编译器可能做的优化量，并对二进制的大小有小的影响。与之前提到的尺寸优化模式相结合，这种影响可能更大。</p><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>Rust 标准库包括 libbacktrace 和 libunwind，这在某些程序中可能是不可取的。因此，使用<code>#![no_std]</code>可以带来更小的二进制文件，但通常也会对你正在编写的那种 Rust 代码造成实质性的改变。请注意，在没有标准库的情况下使用 Rust，通常在功能上更接近于同等的 C 代码。</p><p>举个例子，下面的 C 程序读入一个名字，并对有这个名字的人说“你好”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name?\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> input[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s!\n&quot;</span>, input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Rust重写这个，你可能会得到如下的东西。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> input = <span class="built_in">String</span>::new();</span><br><span class="line">    io::stdin().read_line(&amp;<span class="keyword">mut</span> input).unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;&#125;!&quot;</span>, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序在编译后与 C 程序相比，会有更大的二进制，使用更多的内存。但是这个程序并不完全等同于上面的 C 代码。等价的 Rust 代码反而会是这样的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(lang_items)]</span></span><br><span class="line"><span class="meta">#![feature(libc)]</span></span><br><span class="line"><span class="meta">#![feature(no_std)]</span></span><br><span class="line"><span class="meta">#![feature(start)]</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> libc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">printf</span></span>(fmt: *<span class="keyword">const</span> <span class="built_in">u8</span>, ...) -&gt; <span class="built_in">i32</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">scanf</span></span>(fmt: *<span class="keyword">const</span> <span class="built_in">u8</span>, ...) -&gt; <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[start]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(_argc: <span class="built_in">isize</span>, _argv: *<span class="keyword">const</span> *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        printf(<span class="string">b&quot;What&#x27;s your name?\n\0&quot;</span>.as_ptr());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> input = [<span class="number">0u8</span>; <span class="number">100</span>];</span><br><span class="line">        scanf(<span class="string">b&quot;%s\0&quot;</span>.as_ptr(), &amp;<span class="keyword">mut</span> input);</span><br><span class="line">        printf(<span class="string">b&quot;Hello %s!\n\0&quot;</span>.as_ptr(), &amp;input);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[lang=<span class="meta-string">&quot;eh_personality&quot;</span>]</span> <span class="keyword">extern</span> <span class="function"><span class="keyword">fn</span> <span class="title">eh_personality</span></span>() &#123;&#125;</span><br><span class="line"><span class="meta">#[lang=<span class="meta-string">&quot;panic_fmt&quot;</span>]</span> <span class="function"><span class="keyword">fn</span> <span class="title">panic_fmt</span></span>() -&gt; ! &#123; <span class="keyword">loop</span> &#123;&#125; &#125;</span><br><span class="line"><span class="meta">#[lang=<span class="meta-string">&quot;stack_exhausted&quot;</span>]</span> <span class="keyword">extern</span> <span class="function"><span class="keyword">fn</span> <span class="title">stack_exhausted</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这确实应该在内存使用方面与 C 语言大致相同，但代价是更多的程序员复杂性，以及缺乏通常由 Rust 提供的静态保证（在这里通过使用<code>unsafe</code>来避免）。</p><h2 id="为什么-Rust-不像-C-那样有一个稳定的-ABI，为什么我必须用-extern-来注解东西？"><a href="#为什么-Rust-不像-C-那样有一个稳定的-ABI，为什么我必须用-extern-来注解东西？" class="headerlink" title="为什么 Rust 不像 C 那样有一个稳定的 ABI，为什么我必须用 extern 来注解东西？"></a>为什么 Rust 不像 C 那样有一个稳定的 ABI，为什么我必须用 extern 来注解东西？</h2><p>对 ABI 的承诺是一个重大的决定，会限制未来潜在的有利的语言变化。鉴于 Rust 在 2015 年 5 月才达到 1.0，现在做出像稳定 ABI 这样大的承诺还为时过早。但这并不意味着未来不会发生。(尽管 C++ 已经成功地运行了很多年而没有指定一个稳定的 ABI)。</p><p><code>extern</code>关键字允许 Rust 使用特定的 ABI，例如定义明确的 C ABI，以便与其他语言互操作。</p><h2 id="Rust-代码可以调用-C-代码吗？"><a href="#Rust-代码可以调用-C-代码吗？" class="headerlink" title="Rust 代码可以调用 C 代码吗？"></a>Rust 代码可以调用 C 代码吗？</h2><p>可以。从 Rust 中调用 C 代码的设计与从 C++ 中调用 C 代码一样高效。</p><h2 id="C-代码可以调用-Rust-代码吗"><a href="#C-代码可以调用-Rust-代码吗" class="headerlink" title="C 代码可以调用 Rust 代码吗?"></a>C 代码可以调用 Rust 代码吗?</h2><p>是的，Rust 代码必须通过“extern”声明公开，这使得它与 C-ABI 兼容。这样的函数可以作为一个函数指针传递给 C 代码，或者，如果赋予<code>#[no_mangle]</code>属性以禁用符号纠缠，可以直接从 C 代码中调用。</p><h2 id="我已经写了完美的-C-代码。Rust-能给我什么？"><a href="#我已经写了完美的-C-代码。Rust-能给我什么？" class="headerlink" title="我已经写了完美的 C++ 代码。Rust 能给我什么？"></a>我已经写了完美的 C++ 代码。Rust 能给我什么？</h2><p>现代 C++ 包含了许多使编写安全和正确的代码不容易出错的特性，但它并不完美，而且仍然很容易引入不安全因素。这是 C++ 的核心开发人员正在努力克服的问题，但是 C++ 受限于悠久的历史，它比他们现在试图实现的很多想法都要早。</p><p>Rust 从第一天起就被设计成一种安全的系统编程语言，这意味着它不会受到历史上的设计决定的限制，而这些决定使 C++ 的安全问题变得如此复杂。在 C++ 中，安全是通过谨慎的个人纪律实现的，而且很容易出错。在 Rust 中，安全是默认的。它让你有能力在一个包括不如你完美的人在内的团队中工作，而不必花时间反复检查他们的代码是否存在安全漏洞。</p><h2 id="我如何在-Rust-中实现相当于-C-模板的专业化？"><a href="#我如何在-Rust-中实现相当于-C-模板的专业化？" class="headerlink" title="我如何在 Rust 中实现相当于 C++ 模板的专业化？"></a>我如何在 Rust 中实现相当于 C++ 模板的专业化？</h2><p>Rust 目前还没有与模板专业化完全对等的东西，但它<a href="https://github.com/rust-lang/rust/issues/31844">正在研究中</a>，希望能很快加入。然而，类似的效果可以通过<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">关联类型</a>实现。</p><h2 id="Rust-的所有权系统与-C-的移动语义有什么关系？"><a href="#Rust-的所有权系统与-C-的移动语义有什么关系？" class="headerlink" title="Rust 的所有权系统与 C++ 的移动语义有什么关系？"></a>Rust 的所有权系统与 C++ 的移动语义有什么关系？</h2><p>底层的概念是相似的，但这两个系统在实践中的工作方式是非常不同的。在这两个系统中，“move”一个值都是一种为了转移其底层资源的所有权的方式。例如，移动一个字符串会转移字符串的缓冲区，而不是复制它。</p><p>在 Rust 中，所有权转移是默认行为。例如，如果我编写了一个以“String”为参数的函数，这个函数将对其调用者提供的<code>String</code>值拥有所有权。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(s: <span class="built_in">String</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">caller</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    process(s); <span class="comment">// Transfers ownership of `s` to `process`</span></span><br><span class="line">    process(s); <span class="comment">// Error! ownership already transferred.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你在上面的片段中看到的，在函数<code>caller</code>中，对<code>process</code>的第一次调用转移了变量<code>s</code>的所有权。编译器会跟踪所有权，所以第二次调用<code>process</code>会导致一个错误，因为将同一个值的所有权转让两次是非法的。如果一个值有一个未完成的引用，Rust 也会阻止你移动这个值。</p><p>C++ 采取了一种不同的方法。在 C++ 中，默认的做法是复制一个值（更确切地说，是调用复制构造函数）。然而，被调用者可以使用一个“rvalue reference”来声明他们的参数，例如<code>string&amp;&amp;</code>，以表明他们将获得该参数所拥有的一些资源的所有权（在这个例子中，字符串的内部缓冲区）。然后调用者必须传递一个临时表达式或使用<code>std::move</code>进行明确的移动。大致相当于上面的函数<code>process</code>的粗略等价物是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(string&amp;&amp; s)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">caller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello, world!&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(s));</span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ 编译器没有义务去跟踪移动。例如，上面的代码在编译时没有任何警告或错误，至少在使用默认的设置的情况下，上述代码在编译时没有任何警告或错误。此外，在C++中，字符串<code>s</code>本身的所有权（如果不是它的内部缓冲区的话）仍然属于<code>caller</code>，所以<code>s</code>的析构函数会在<code>caller</code>返回时运行，即使它已经被移动了（相反，在 Rust 中，被移动的值只被其新主人丢弃）。</p><h2 id="我怎样才能从-Rust-与-C-互操作，或者从-C-与-Rust-互操作？"><a href="#我怎样才能从-Rust-与-C-互操作，或者从-C-与-Rust-互操作？" class="headerlink" title="我怎样才能从 Rust 与 C++ 互操作，或者从 C++ 与 Rust 互操作？"></a>我怎样才能从 Rust 与 C++ 互操作，或者从 C++ 与 Rust 互操作？</h2><p>Rust 和 C++ 可以通过 C 语言进行互操作。Rust 和 C++ 都为 C 语言提供了一个<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code">外来函数接口</a>，并可以用它来进行相互之间的通信。如果编写 C 语言绑定太过繁琐，你可以使用<a href="https://github.com/rust-lang/rust-bindgen">rust-bindgen</a>来帮助自动生成可行的 C 语言绑定。</p><h2 id="Rust-有-C-风格的构造函数吗？"><a href="#Rust-有-C-风格的构造函数吗？" class="headerlink" title="Rust 有 C++ 风格的构造函数吗？"></a>Rust 有 C++ 风格的构造函数吗？</h2><p>不，函数的作用与构造函数相同，不会增加语言的复杂性。在 Rust 中，相当于构造函数的通常名称是<code>new()</code>，尽管这只是一个惯例而不是语言规则。<code>new()</code>函数实际上就像其他函数一样。它的一个例子是这样的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">i32</span>,</span><br><span class="line">    b: <span class="built_in">f64</span>,</span><br><span class="line">    c: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Foo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Foo &#123;</span><br><span class="line">        Foo &#123;</span><br><span class="line">            a: <span class="number">0</span>,</span><br><span class="line">            b: <span class="number">0.0</span>,</span><br><span class="line">            c: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rust-有复制构造函数吗？"><a href="#Rust-有复制构造函数吗？" class="headerlink" title="Rust 有复制构造函数吗？"></a>Rust 有复制构造函数吗？</h2><p>不完全是。实现了<code>Copy</code>的类型会做一个标准的类似于 C 语言的“浅拷贝”，不需要额外的工作（类似于 C++ 中的 trivially copyable 类型）。不可能实现需要自定义复制行为的<code>Copy</code>类型。相反，在 Rust 中，“复制构造器”是通过实现<code>Clone</code>特性，并明确调用<code>clone</code>方法来创建的。将用户定义的复制操作符显性化，使开发者更容易识别潜在的昂贵操作。</p><h2 id="Rust-有移动构造函数吗？"><a href="#Rust-有移动构造函数吗？" class="headerlink" title="Rust 有移动构造函数吗？"></a>Rust 有移动构造函数吗？</h2><p>没有。所有类型的值都是通过<code>memcpy</code>移动的。这使得编写通用的不安全代码变得更加简单，因为赋值、传递和返回都是已知的，不会产生像解绑（unwinding）那样的副作用。</p><h2 id="Go-和-Rust-有什么相似之处，又有什么不同？"><a href="#Go-和-Rust-有什么相似之处，又有什么不同？" class="headerlink" title="Go 和 Rust 有什么相似之处，又有什么不同？"></a>Go 和 Rust 有什么相似之处，又有什么不同？</h2><p>Rust 和 Go 的设计目标有很大不同。以下的差异并不是唯一的差异（这些差异太多，无法一一列举），但却是其中几个比较重要的差异：</p><ul><li>Rust 比 Go 层级更低。例如，Rust 不需要垃圾收集器，而 Go 需要。一般来说，Rust 提供的控制水平与 C 或 C++ 相当。</li><li>Rust 的重点是确保安全和效率，同时提供高层次的能力，而 Go 的重点是成为一种小而简单的语言，可以快速编译并与各种工具很好地配合。</li><li>Rust 对泛型有很强的支持，而 Go （目前）却没有。</li><li>Rust 受到函数式编程世界的强烈影响，包括从 Haskell 的 typeclasses 中提取的类型系统。Go 有一个更简单的类型系统，使用接口进行基本的泛型编程。</li></ul><h2 id="Rust-traits-与-Haskell-typeclasses-相比如何？"><a href="#Rust-traits-与-Haskell-typeclasses-相比如何？" class="headerlink" title="Rust traits 与 Haskell typeclasses 相比如何？"></a>Rust traits 与 Haskell typeclasses 相比如何？</h2><p>Rust traits 类似于 Haskell 的 typeclasses，但目前还没有那么强大，因为 Rust 不能表达更高类型的类型。Rust 的关联类型等同于 Haskell 类型族。</p><p>Haskell typeclasses 和 Rust traits 之间的一些具体区别包括：</p><ul><li>Rust traits 有一个隐含的第一个参数，叫做<code>Self</code>。Rust 中的<code>trait Bar</code>对应于 Haskell 中的<code>class Bar self</code>，而 Rust 中的<code>trait Bar&lt;Foo&gt;</code>对应于 Haskell 中的<code>class Bar foo self</code>。</li><li>Rust 中的“Supertraits”或“superclass constraints”被写成<code>trait Sub: Super</code>，而 Haskell 中的为<code>class Super self =&gt; Sub self</code>。</li><li>Rust 禁止无主实例，导致 Rust 中的一致性规则与 Haskell 不同。</li><li>Rust 的<code>impl</code>解析在决定两个<code>impl</code>是否重叠或在潜在的<code>impl</code>之间进行选择时，会考虑相关的<code>where</code>条款和特质约束条件。Haskell 只考虑<code>instance</code>声明中的约束，不考虑其他地方提供的任何约束。</li><li>Rust 的 traits 的一个子集（<a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">“对象安全”</a>的 traits）可以通过 trait 对象用于动态调度。同样的功能在 Haskell 中通过 GHC 的“ExistentialQuantification”可用。</li></ul><h1 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h1><h2 id="为什么-Stack-Overflow-上有这么多-Rust-的答案是错误的？"><a href="#为什么-Stack-Overflow-上有这么多-Rust-的答案是错误的？" class="headerlink" title="为什么 Stack Overflow 上有这么多 Rust 的答案是错误的？"></a>为什么 Stack Overflow 上有这么多 Rust 的答案是错误的？</h2><p>Rust 语言已经存在了很多年，在 2015 年 5 月才达到 1.0 版本。在这之前的时间里，语言发生了很大的变化，而 Stack Overflow 的一些答案是在语言的旧版本时给出的。</p><p>随着时间的推移，越来越多的答案将提供给当前的版本，从而改善这个问题，因为过时的答案的比例减少了。</p><h2 id="我在哪里报告-Rust-文档中的问题？"><a href="#我在哪里报告-Rust-文档中的问题？" class="headerlink" title="我在哪里报告 Rust 文档中的问题？"></a>我在哪里报告 Rust 文档中的问题？</h2><p>你可以在 Rust 编译器<a href="https://github.com/rust-lang/rust/issues">issue tracker</a>上报告 Rust 文档中的问题。请务必先阅读<a href="https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#writing-documentation">贡献指南</a>。</p><h2 id="我如何查看我的项目所依赖的库的-Rustdoc-文档？"><a href="#我如何查看我的项目所依赖的库的-Rustdoc-文档？" class="headerlink" title="我如何查看我的项目所依赖的库的 Rustdoc 文档？"></a>我如何查看我的项目所依赖的库的 Rustdoc 文档？</h2><p>当你使用<code>cargo doc</code>为你自己的项目生成文档时，它也会为活动的依赖版本生成文档。这些文档会被放到你的项目的<code>target/doc</code>目录下。使用<code>cargo doc --open</code>来打开这些文档，或者自己打开<code>target/doc/index.html</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文：&lt;a href=&quot;https://github.com/dtolnay/rust-faq&quot;&gt;https://github.com/dtolnay/rust-faq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文档的存在是为了回答有关 Rust 编程语言的常见问题。它不是一个完整的语言指南，也不是一个教授该语言的工具。它只是一个参考，用来回答 Rust 社区中人们经常遇到的问题，并澄清 Rust 的一些设计决定背后的原因。&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="https://www.purewhite.io/categories/rust/"/>
    
    
    <category term="rust" scheme="https://www.purewhite.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 认为什么是“未定义”以及什么不是“不安全”？</title>
    <link href="https://www.purewhite.io/2021/08/11/rust-considered-unsafe-undefined/"/>
    <id>https://www.purewhite.io/2021/08/11/rust-considered-unsafe-undefined/</id>
    <published>2021-08-11T07:27:38.000Z</published>
    <updated>2021-12-02T12:51:07.229Z</updated>
    
    <content type="html"><![CDATA[<p>大家应该都听说过 Rust 语言是以安全（Safe）作为特性之一的，但是由于一个悲哀的事实——硬件是不安全（Unsafe）的，所以其实所有的“安全”一定是在“不安全”之上的封装，这也导致了完全意义上的“Safe”是很难做到且功能极其受限的。</p><p>那让我们来看看，Rust 的 Safe 边界在哪里。</p><span id="more"></span><h1 id="Rust-认为什么不是“不安全”？"><a href="#Rust-认为什么不是“不安全”？" class="headerlink" title="Rust 认为什么不是“不安全”？"></a>Rust 认为什么不是“不安全”？</h1><p>什么是安全的 Rust 相信大家都了解，这里不再赘述；实际上，有一些行为虽然我们会认为是预期之外甚至不安全的，但是 Rust 不会：</p><ul><li>死锁</li><li>内存、资源泄露</li><li>未执行析构就退出</li><li>由于指针泄漏，暴露了随机的基地址</li><li>整型溢出</li><li>逻辑错误</li></ul><p>前四个都好理解，特别是内存泄漏这个，在 The Book 中就有提到（而且可以看下，标准库的<code>std::mem:leak</code>都不是 unsafe 的）；这里特别要讨论的是，整型溢出和逻辑错误这两个问题。</p><h2 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h2><p>如果一段代码包含算术溢出，那是程序员的锅。在下面的讨论中，我们需要区分算术溢出和包装算术（wrapping arithmetic）。前者是错误的，而后者是预期之中的。</p><p>当程序员启用了<code>debug_assert!</code>断言（例如，debug 模式下的编译），编译器会在运行时插入动态检查，如果发生了溢出会 panic。其他类型的构建（如 release 模式下）可能会导致 panic 或在溢出时啥都不做。</p><p>在隐式包装溢出的情况下，实现者必须通过使用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8">二补数的溢出约定</a>来提供定义明确的（即使仍然被认为是错误的）结果。</p><p>Rust 标准库为整型提供了一些方法，允许程序员明确地执行包装算术。例如，<code>i32::wrapping_add</code>提供了二补、包装加法。</p><p>标准库还提供了一个<code>Wrapping&lt;T&gt;</code>类型，确保<code>T</code>的所有标准算术操作都有包装语义。</p><p>关于整数溢出的错误条件、原理和更多细节，可以参考<a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a>。</p><h2 id="逻辑错误"><a href="#逻辑错误" class="headerlink" title="逻辑错误"></a>逻辑错误</h2><p>安全代码可以有一些额外的逻辑约束，这些约束在编译时和运行时都无法检查。如果一个程序破坏了这样的约束，其行为可能是未指定的，但不会导致未定义行为。这可能包括 panic、不正确的结果、非预期的中止或者死循环。这种行为也可能在不同的运行、构建或构建种类之间有所不同。</p><p>例如，实现<code>Hash</code>和<code>Eq</code>要求相等的值一定要有相等的哈希值。另一个例子是像<code>BinaryHeap</code>、<code>BTreeMap</code>、<code>BTreeSet</code>、<code>HashMap</code>和<code>HashSet</code>这样的数据结构，它们针对在它们 Key 中的对象的修改定义了一些约束。违反这样的约束不被认为是不安全的，然而程序的行为是不可预测的，随时有可能挂。</p><h1 id="Rust-认为什么是“未定义”"><a href="#Rust-认为什么是“未定义”" class="headerlink" title="Rust 认为什么是“未定义”"></a>Rust 认为什么是“未定义”</h1><p>未定义（Undefined Behaviour）是一个很有意思的定义，算是写 C 和 C++ 程序员的老朋友了，甚至很多代码会依赖未定义行为。</p><p>如果 Rust 代码有以下列表中的任何行为，那么它就是不正确的，包括 unsafe 中的代码。<strong>unsafe 只意味着避免未定义的行为是由程序员负责的；它没有改变任何关于 Rust 程序决不能引起未定义行为的要求。</strong>换言之，无论是否使用 unsafe，都不应该有未定义的行为出现。</p><p>在编写 unsafe 代码时，程序员有责任确保任何与不安全代码交互的安全代码不能触发这些行为。对于任何安全的调用者来说，满足这一属性的不安全代码被称为健全（sound）的；如果不安全代码可以被安全代码滥用而表现出未定义的行为，那么它就是不健全的。</p><p><strong>要注意，下面的列表并不是详尽的。对于不安全代码中允许和不允许的行为，Rust 的语义并没有正式的模型，所以可能有更多的行为被认为是不安全的。下面的列表只是我们确定的未定义行为。在编写不安全代码之前，请阅读死灵书（Rustonomicon）。</strong></p><ul><li><p>数据竞争（Data races）</p></li><li><p>在一个悬空或不对齐的原始指针上执行解引用表达式（*expr），即使是在地址表达式上下文中（例如<code>addr_of!(&amp;*expr)</code>）。</p></li><li><p>破坏了指针别名规则。<code>&amp;mut T</code>和<code>&amp;T</code>遵循 LLVM 的作用域<code>noalias</code>模型，除非<code>&amp;T</code>包含一个<code>UnsafeCell&lt;U&gt;</code>。</p></li><li><p>修改不可变的数据。const 项中的所有数据都是不可变的。此外，所有共享引用的数据或由不可变的绑定所拥有的数据都是不可变的，除非该数据包含在一个<code>UnsafeCell&lt;U&gt;</code>中。</p></li><li><p>通过编译器的内建指令调用未定义的行为。</p></li><li><p>执行当前平台不支持的平台特性编译的代码（见<a href="https://doc.rust-lang.org/stable/reference/attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a>，这通常会导致 SIGILL）。</p></li><li><p>调用具有错误调用规约（ABI）的函数或 unwind 具有错误 unwind ABI 的函数。</p></li><li><p>产生一个无效的值，哪怕是在私有字段和局部字段中。一个值被分配到一个地方或从一个地方读出、传递到一个函数 / 原始操作（primitive operation）或从一个函数 / 原始操作返回都会“产生”一个值。以下的值是无效的：</p><ul><li><p>bool 中除 false（0）或 true（1）以外的值。</p></li><li><p>类型定义中没有包括的枚举中的判别式。</p></li><li><p>一个空的 fn 指针。</p></li><li><p>char 中的一个值是代用的（surrogate）或高于<code>char::MAX</code>的。</p></li><li><p><code>!</code> （所有的值对这个类型来说都是无效的）。</p></li><li><p>一个整数、浮点值，或从未初始化的内存中获得的原始指针，或<code>str</code>中未初始化的内存。</p></li><li><p>一个引用或<code>Box&lt;T&gt;</code>是悬空的、不对齐的，或者指向一个无效的值。</p></li><li><p>泛引用、<code>Box&lt;T&gt;</code>或原始指针中无效的元数据。</p><ul><li>如果一个<code>dyn Trait</code>指针 / 引用指向的 vtable 和对应 Trait 的 vtable 不匹配，那么<code>dyn Trait</code>的元数据是无效的。</li><li>如果 Slice 的长度不是有效的 usize（比如，从未初始化的内存中读取的 usize），那么 Slice 的元数据是无效的。</li></ul></li><li><p>对于一个具有自定义的无效值的类型来说是无效的值（看着有点绕），比如在标准库中的<code>NonNull&lt;T&gt;</code>和<code>NonZero*</code>。</p><blockquote><p>注：Rustc 通过不稳定的<code>rustc_layout_scalar_valid_range_*</code>属性实现了这一点。</p></blockquote></li></ul></li></ul><p>注意：对于任何具有受限的有效值集的类型，未初始化的内存也是隐式无效的。换句话说，唯一允许读取未初始化内存的情况是在 union 内和<code>padding</code>中（一个类型的字段 / 元素之间的空隙）。</p><blockquote><p>注：未定义行为会影响整个程序。例如，在 C 语言中调用一个表现出 C 语言未定义行为的函数，意味着你的整个程序包含未定义行为，这也会影响 Rust 代码。反之亦然，Rust 中的未定义行为会对其他语言的任何 FFI 调用所执行的代码造成不良影响。</p></blockquote><h2 id="悬垂指针"><a href="#悬垂指针" class="headerlink" title="悬垂指针"></a>悬垂指针</h2><p>如果一个引用 / 指针是空的，或者它所指向的所有地址并非合法的地址（比如 malloc 分配出的内存），那么它就是<code>悬垂</code>的。它所指向的范围是由指针值和被指向类型的大小决定的（使用<code>size_of_val</code>）。因此，如果指向的范围是空的，<code>悬垂</code>与<code>非空</code>是一样的。</p><p>要注意，切片和字符串指向它们的整个范围，所以它们的长度不可能很大。内存分配的长度、切片和字符串的长度不能大于<code>isize::MAX</code>字节。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家应该都听说过 Rust 语言是以安全（Safe）作为特性之一的，但是由于一个悲哀的事实——硬件是不安全（Unsafe）的，所以其实所有的“安全”一定是在“不安全”之上的封装，这也导致了完全意义上的“Safe”是很难做到且功能极其受限的。&lt;/p&gt;
&lt;p&gt;那让我们来看看，Rust 的 Safe 边界在哪里。&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="https://www.purewhite.io/categories/rust/"/>
    
    
    <category term="rust" scheme="https://www.purewhite.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】Inventing the Service trait</title>
    <link href="https://www.purewhite.io/2021/05/24/inventing-the-service-trait/"/>
    <id>https://www.purewhite.io/2021/05/24/inventing-the-service-trait/</id>
    <published>2021-05-24T08:21:59.000Z</published>
    <updated>2021-12-02T12:51:07.227Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：</p><p>最近看到了一篇讲 Rust 如何对框架进行抽象的文章，写得非常好，这两天抽空翻译了一下。</p><p>原文：<a href="https://tokio.rs/blog/2021-05-14-inventing-the-service-trait">https://tokio.rs/blog/2021-05-14-inventing-the-service-trait</a></p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><a href="https://github.com/tower-rs/tower"><code>Tower</code></a>是一个模块化和可重复使用的用来构建 client 和 server 的组件库。其核心是<a href="https://docs.rs/tower/latest/tower/trait.Service.html"><code>Service</code></a>特性。一个<code>Service</code>是一个异步函数，它接受一个请求并产生一个响应。然而，<code>Tower</code>设计的某些方面可能不是那么一目了然。</p><p>与其解释今天存在于<code>Tower</code>中的<code>Service</code>特性，不如来看看<code>Service</code>背后的设计考量。让我们试试看，如果今天重新设计实现它，我们会怎么做。</p><span id="more"></span><p>想象一下，你正在用 Rust 构建一个简单的 HTTP 框架。这个框架将允许用户提供接收请求并返回响应的处理逻辑来实现一个 HTTP 服务器。你可能会有这么一个 API：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个在 3000 端口监听的服务器</span></span><br><span class="line"><span class="keyword">let</span> server = Server::new(<span class="string">&quot;127.0.0.1:3000&quot;</span>).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以某种方式运行用户的应用程序</span></span><br><span class="line">server.run(the_users_application).<span class="keyword">await</span>?</span><br></pre></td></tr></table></figure><p>现在问题来了，<code>the_users_application</code>应该是什么？</p><p>最简单的一个实现，可能是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_request</span></span>(request: HttpRequest) -&gt; HttpResponse &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>HttpRequest</code>和<code>HttpResponse</code>是由我们的框架提供的一些结构。有了这个，我们就可以这样实现<code>Server::run</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Server &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>&lt;F&gt;(<span class="keyword">self</span>, handler: F) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">Fn</span>(HttpRequest) -&gt; HttpResponse,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> listener = TcpListener::bind(<span class="keyword">self</span>.addr).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> connection = listener.accept().<span class="keyword">await</span>?</span><br><span class="line">            <span class="keyword">let</span> request = read_http_request(&amp;<span class="keyword">mut</span> connection).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用由用户提供的处理程序</span></span><br><span class="line">            <span class="keyword">let</span> response = handler(request);</span><br><span class="line"></span><br><span class="line">            write_http_response(connection).<span class="keyword">await</span>?</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们有一个异步函数<code>run</code>，它接受一个闭包，这个闭包接受一个<code>HttpRequest</code>并返回<code>HttpResponse</code>。用户可以像这样使用我们的<code>server</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_request</span></span>(request: HttpRequest) -&gt; HttpResponse &#123;</span><br><span class="line">    <span class="keyword">if</span> request.path() == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">        HttpResponse::ok(<span class="string">&quot;Hello, World!&quot;</span> )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HttpResponse::not_found()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行服务器并使用我们的 handle_request 函数处理请求</span></span><br><span class="line">server.run(handle_request).<span class="keyword">await</span>?</span><br></pre></td></tr></table></figure><p>感觉还行，它让用户可以很容易地运行 HTTP 服务器而不必担心任何低层次的细节。</p><p>然而，我们目前的设计有一个问题：我们无法处理异步地处理请求。想象一下，我们的用户需要查询一个数据库，或者在处理请求的同时发送一个请求给其他服务器。目前，这样会导致我们需要同步等待 handler 的返回结果，从而导致了<a href="https://ryhl.io/blog/async-what-is-blocking/">阻塞</a>。</p><p>如果我们希望我们的服务器能够处理大量的并发连接，我们需要在等待该请求异步完成的同时为其他请求提供服务。我们可以通过让 handler 返回一个<a href="https://doc.rust-lang.org/stable/std/future/trait.Future.html"><code>future</code></a>来解决这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Server &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>&lt;F, Fut&gt;(<span class="keyword">self</span>, handler: F) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="comment">// handler 现在返回一个通用类型的 Fut</span></span><br><span class="line">        F: <span class="built_in">Fn</span>(HttpRequest) -&gt; Fut,</span><br><span class="line">        <span class="comment">// FUT 是一个 Future，其输出是一个 HttpResponse</span></span><br><span class="line">        Fut: Future&lt;Output = HttpResponse&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> listener = TcpListener::bind(<span class="keyword">self</span>.addr).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> connection = listener.accept().<span class="keyword">await</span>?</span><br><span class="line">            <span class="keyword">let</span> request = read_http_request(&amp;<span class="keyword">mut</span> connection).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待由 handler 返回的 Future</span></span><br><span class="line">            <span class="keyword">let</span> response = handler(request).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">            write_http_response(connection).<span class="keyword">await</span>?</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API 的用法和之前差不多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在是一个异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">handle_request</span></span>(request: HttpRequest) -&gt; HttpResponse &#123;</span><br><span class="line">    <span class="keyword">if</span> request.path() == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">        HttpResponse::ok(<span class="string">&quot;Hello, World!&quot;</span> )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> request.path() == <span class="string">&quot;/important-data&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 我们现在可以在这里做异步的事情了</span></span><br><span class="line">        <span class="keyword">let</span> some_data = fetch_data_from_database().<span class="keyword">await</span>;</span><br><span class="line">        make_response(some_data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HttpResponse::not_found()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行 server 也是一样的</span></span><br><span class="line">server.run(handle_request).<span class="keyword">await</span>?</span><br></pre></td></tr></table></figure><p>这就比之前要好很多了，因为我们的 handler 现在可以调用其他异步函数啦。然而，我们仍然缺了点啥——如果我们的处理程序出错了怎么办？我们可以让 Handler 返回一个<code>Result</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> server &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>&lt;F, Fut&gt;(<span class="keyword">self</span>, handler: F) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">Fn</span>(HttpRequest) -&gt; Fut,</span><br><span class="line">        <span class="comment">// 响应的 Future 允许返回 Error</span></span><br><span class="line">        Fut: Future&lt;Output = <span class="built_in">Result</span>&lt;HttpResponse, Error&gt;&gt;。</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> listener = TcpListener::bind(<span class="keyword">self</span>.addr).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> connection = listener.accept().<span class="keyword">await</span>?</span><br><span class="line">            <span class="keyword">let</span> request = read_http_request(&amp;<span class="keyword">mut</span> connection).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对响应的 Future 进行模式匹配</span></span><br><span class="line">            <span class="keyword">match</span> handler(request).<span class="keyword">await</span> &#123;</span><br><span class="line">                <span class="literal">Ok</span>(response) =&gt; write_http_response(connection).<span class="keyword">await</span>?</span><br><span class="line">                <span class="literal">Err</span>(error) =&gt; handle_error_somehow(error, connection)。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加更多的功能"><a href="#添加更多的功能" class="headerlink" title="添加更多的功能"></a>添加更多的功能</h1><p>现在，假设我们想确保所有的请求都能及时完成或失败，而不是让客户端无限期地等待一个可能永远不会有的响应。</p><p>我们可以通过给每个请求添加一个超时来做到这一点。一个超时设置了<code>handler</code>允许持续的最大时间的限制。如果它在这个时间内没有产生响应，就会返回一个错误。这使得客户端可以重试该请求或向用户报告错误，而不是永远等待。</p><p>最简单的方法可能是去修改<code>Server</code>，使其可以配置一个超时，然后在每次调用<code>handler</code>时应用该超时。然而，其实你也可以在不修改<code>Server</code>的情况下添加一个超时。使用<a href="https://docs.rs/tokio/latest/tokio/time/fn.timeout.html"><code>tokio::time::timeout</code></a>，我们可以写一个新的处理函数，让它调用我们之前的<code>handle_request</code>，并且设置超时时间为 30 秒：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">handler_with_timeout</span></span>(request: HttpRequest) -&gt; <span class="built_in">Result</span>&lt;HttpResponse, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = tokio::time::timeout(</span><br><span class="line">        Duration::from_secs(<span class="number">30</span>),</span><br><span class="line">        handle_request(request)</span><br><span class="line">    ).<span class="keyword">await</span>。</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="literal">Ok</span>(<span class="literal">Ok</span>(response)) =&gt; <span class="literal">Ok</span>(response)。</span><br><span class="line">        <span class="literal">Ok</span>(<span class="literal">Err</span>(error)) =&gt; <span class="literal">Err</span>(error),</span><br><span class="line">        <span class="literal">Err</span>(_timeout_elapsed) =&gt; <span class="literal">Err</span>(Error::timeout() )。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这提供了一个相当好的抽象，我们能够添加一个超时器而不改变任何现有的代码。</p><p>让我们用这种方式再增加一个功能。想象一下，我们正在写一个 JSON API，并且希望在所有的响应上有一个<code>Content-Type: application/json</code>的头。我们可以用类似的方式包装<code>handler_with_timeout</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">handler_with_timeout_and_content_type</span></span>(</span><br><span class="line">    request: HttpRequest,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;HttpResponse, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> response = handler_with_timeout(request).<span class="keyword">await</span>?</span><br><span class="line">    response.set_header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)。</span><br><span class="line">    <span class="literal">Ok</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在有了一个处理程序，它将处理一个 HTTP 请求，超时为 30 秒，并且会设置好正确的<code>Content-Type</code>头，所有这些都不需要修改我们原来的<code>handle_request</code>函数或<code>Server</code>结构。</p><p>设计可以以这种方式扩展的库是非常强大的，因为它允许用户通过增加一层新行为来扩展库的功能，而不需要等待库的维护者为其添加支持。</p><p>它也使测试变得更容易，因为你可以把你的代码分解成小的隔离的孤立的单元，并为它们编写细粒度的测试，而不必担心其他的部分。</p><p>然而，又有了一个问题：我们目前的设计是套娃，也就是实现一个处理函数来实现功能，并在其内部调用其他处理函数。这能 work，但如果我们想增加更多的额外功能，它并不能很好地扩展。</p><p>想象一下，我们有许多<code>handle_with_*</code>函数，每一个都增加了一点儿新的行为。要硬编码谁调用谁的这个调用链将成为一种挑战。我们目前的调用链是：</p><ol><li><code>handler_with_timeout_and_content_type</code>，调用</li><li><code>handler_with_timeout</code>，调用</li><li><code>handle_request</code>，实际处理请求。</li></ol><p>如果我们能以某种方式<a href="https://en.wikipedia.org/wiki/Function_composition">组合</a>这三个函数而不需要硬编码确切的顺序，那就更好了，就像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> final_handler = with_content_type(with_timeout(handle_request));</span><br></pre></td></tr></table></figure><p>同时仍然能够像以前一样运行我们的处理程序。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.run(final_handler).<span class="keyword">await</span>?</span><br></pre></td></tr></table></figure><p>你可以把<code>with_content_type</code>和<code>with_timeout</code>作为函数来实现，该函数接受一个<code>F: Fn(HttpRequest) -&gt; Future&lt;Output = Result&lt;HttpResponse, Error&gt;</code>的参数并返回一个<code>impl Fn(HttpRequest) -&gt; Future&lt;Output = Result&lt;HttpResponse, Error&gt;&gt;</code>的闭包。这也不是不行，但所有这些闭包类型会很快变得难以处理。</p><h1 id="Handlertrait"><a href="#Handlertrait" class="headerlink" title="Handlertrait"></a><code>Handler</code>trait</h1><p>让我们来尝试另一种方法。与其让<code>Server::run</code>接受了一个闭包(<code>Fn(HttpRequest) -&gt; …</code>)，不如让我们定义一个新的 trait 来封装<code>async fn(HttpRequest) -&gt; Result&lt;HttpResponse, Error&gt;</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) -&gt; <span class="built_in">Result</span>&lt;HttpResponse, Error&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这样一个 trait，我们就可以编写实现它的具体类型，这样我们就不必到处用<code>Fn</code>了。</p><p>然而，Rust 目前不支持 async trait 方法，所以我们有两个选择：</p><ol><li>让<code>call</code>返回一个 Boxed Future，如<code>Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;HttpResponse, Error&gt;&gt;</code>。这也就是<a href="https://crates.io/crates/async-trait"><code>async-trait</code></a>干的事。</li><li>在<code>Handler</code>中添加一个关联的<code>type Future</code>，这样用户就可以指定自己的类型。</li></ol><p>我们采用方案二，因为它是最灵活的。有一个具体的 Future 类型的用户可以避免<code>Box</code>的开销，而不在乎的用户也可以使用<code>Pin&lt;Box&lt;...&gt;&gt;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">handler</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>: Future&lt;Output = <span class="built_in">Result</span>&lt;HttpResponse, Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仍然要求<code>Handler::Future</code>实现输出为<code>Result&lt;HttpResponse, Error&gt;</code>的<code>Future</code>，因为那是<code>Server::run</code>的要求。</p><p>让<code>call</code>接受<code>&amp;mut self</code>是有用的，因为它允许处理程序在必要时更新他们的内部状态<sup><a href="#pin">1</a></sup>。</p><p>让我们把原来的<code>handle_request</code>函数转换为使用这个特性的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RequestHandler</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Handler <span class="keyword">for</span> RequestHandler &#123;</span><br><span class="line">    <span class="comment">// 为了简单起见，我们在这里使用 Pin&lt;Box&lt;...&gt;&gt;，但也可以定义我们的</span></span><br><span class="line">    <span class="comment">// 自己的 Future 类型，以避免开销。</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span> = Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="built_in">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="built_in">Box</span>::pin(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="comment">// 与我们之前的实现相同</span></span><br><span class="line">            <span class="keyword">if</span> request.path() == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">                <span class="literal">Ok</span>(HttpResponse::ok(<span class="string">&quot;Hello, World!&quot;</span>))</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> request.path() == <span class="string">&quot;/important-data&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> some_data = fetch_data_from_database().<span class="keyword">await</span>?;</span><br><span class="line">                <span class="literal">Ok</span>(make_response(some_data))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="literal">Ok</span>(HttpResponse::not_found())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们如何基于这个实现超时呢？请记住，我们的目标是允许我们在不修改每个单独部分的情况下，将不同的功能组合在一起。</p><p>我们可以定义一个通用的<code>Timeout</code>结构，就像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Timeout</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// T 实现了`Handler&#x27;的类型</span></span><br><span class="line">    inner_handler: T,</span><br><span class="line">    duration: Duration,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以为<code>Timeout&lt;T&gt;</code>实现<code>Handler</code>并委托给<code>T</code>的<code>Handler</code>实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> Timeout&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Handler,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span> = Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="built_in">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="built_in">Box</span>::pin(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> result = tokio::time::timeout(</span><br><span class="line">                <span class="keyword">self</span>.duration,</span><br><span class="line">                <span class="keyword">self</span>.inner_handler.call(request),</span><br><span class="line">            ).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> result &#123;</span><br><span class="line">                <span class="literal">Ok</span>(<span class="literal">Ok</span>(response)) =&gt; <span class="literal">Ok</span>(response),</span><br><span class="line">                <span class="literal">Ok</span>(<span class="literal">Err</span>(error)) =&gt; <span class="literal">Err</span>(error),</span><br><span class="line">                <span class="literal">Err</span>(_timeout) =&gt; <span class="literal">Err</span>(Error::timeout()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重要的一行是<code>self.inner_handler.call(request)</code>，在这我们继续调用内部处理程序，让它做自己的事情而不管关它是什么。我们只需要知道它完成后会返回一个<code>Result&lt;HttpResponse, Error&gt;</code>。</p><p>但是，这段代码编译不过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0759]: `<span class="keyword">self</span>` has an anonymous lifetime `<span class="symbol">&#x27;_</span>` but it needs to satisfy a `<span class="symbol">&#x27;static</span>` lifetime requirement</span><br><span class="line">   --&gt; src/lib.rs:<span class="number">145</span>:<span class="number">29</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">144</span> |       <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) -&gt; Self::Future &#123;</span><br><span class="line">    |               --------- this data with an anonymous lifetime `<span class="symbol">&#x27;_</span>`...</span><br><span class="line"><span class="number">145</span> |           <span class="built_in">Box</span>::pin(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    |  _____________________________^</span><br><span class="line"><span class="number">146</span> | |             <span class="keyword">let</span> result = tokio::time::timeout(</span><br><span class="line"><span class="number">147</span> | |                 <span class="keyword">self</span>.duration,</span><br><span class="line"><span class="number">148</span> | |                 <span class="keyword">self</span>.inner_handler.call(request),</span><br><span class="line">...   |</span><br><span class="line"><span class="number">155</span> | |             &#125;</span><br><span class="line"><span class="number">156</span> | |         &#125;)</span><br><span class="line">    | |_________^ ...is captured here, requiring it to live <span class="keyword">as</span> long <span class="keyword">as</span> `<span class="symbol">&#x27;static</span>`</span><br></pre></td></tr></table></figure><p>编译出错的原因是，我们正在捕获一个<code>&amp;mut self</code>并将其移到一个异步的代码块中。这意味着我们的 Future 和<code>&amp;mut self</code>的生命周期是相同的。但是这并不符合我们的预期，因为我们可能想在多个线程上运行我们的 Future 以获得更好的性能，或者产生多个 Future 并将它们全部并行运行。如果对 handler 的引用存在于 Future<sup><a href="#gats">2</a></sup> 中，这就不可能了。</p><p>因此，我们需要将<code>&amp;mut self</code>转换为一个有所有权的<code>self</code>。这正是<code>Clone</code>所做的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这必须是 Clone，才能使 Timeout&lt;T&gt; 成为 Clone</span></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RequestHandler</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Handler <span class="keyword">for</span> RequestHandler &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Timeout</span></span>&lt;T&gt; &#123;</span><br><span class="line">    inner_handler: T,</span><br><span class="line">    duration: Duration,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> Timeout&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Handler + <span class="built_in">Clone</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span> = Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="built_in">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="comment">// 获得`&amp;mut self`的所有权</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> this = <span class="keyword">self</span>.clone();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Box</span>::pin(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> result = tokio::time::timeout(</span><br><span class="line">                this.duration,</span><br><span class="line">                this.inner_handler.call(request),</span><br><span class="line">            ).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> result &#123;</span><br><span class="line">                <span class="literal">Ok</span>(<span class="literal">Ok</span>(response)) =&gt; <span class="literal">Ok</span>(response),</span><br><span class="line">                <span class="literal">Ok</span>(<span class="literal">Err</span>(error)) =&gt; <span class="literal">Err</span>(error),</span><br><span class="line">                <span class="literal">Err</span>(_timeout) =&gt; <span class="literal">Err</span>(Error::timeout()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在这种情况下，clone 是非常便宜的，因为<code>RequestHandler</code>没有任何数据，<code>Timeout&lt;T&gt;</code>只增加了一个<code>Duration</code>（也就是实际上是<code>Copy</code>）。</p><p>好，我们现在更进一步了，现在我们得到了另一个错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0310]: the parameter <span class="class"><span class="keyword">type</span> `<span class="title">T</span></span>` may not live long enough</span><br><span class="line">   --&gt; src/lib.rs:<span class="number">149</span>:<span class="number">9</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">140</span> |   <span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> Timeout&lt;T&gt;</span><br><span class="line">    |        - help: consider adding an explicit lifetime bound...: `T: <span class="symbol">&#x27;static</span>`</span><br><span class="line">...</span><br><span class="line"><span class="number">149</span> | /         <span class="built_in">Box</span>::pin(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line"><span class="number">150</span> | |             <span class="keyword">let</span> result = tokio::time::timeout(</span><br><span class="line"><span class="number">151</span> | |                 this.duration,</span><br><span class="line"><span class="number">152</span> | |                 this.inner_handler.call(request),</span><br><span class="line">...   |</span><br><span class="line"><span class="number">159</span> | |             &#125;</span><br><span class="line"><span class="number">160</span> | |         &#125;)</span><br><span class="line">    | |__________^ ...so that the <span class="class"><span class="keyword">type</span> `<span class="title">impl</span></span> Future` will meet its required lifetime bounds</span><br></pre></td></tr></table></figure><p>现在的问题是，因为<code>T</code>可以是任何类型。它甚至可以是一个包含引用的类型，比如<code>Vec&lt;&amp;&#39;a str&gt;</code>。然而这就拉胯了，原因和之前一样。我们需要返回的 Future 有一个<code>&#39;static</code>的生命周期，这样我们可以更容易地传递它。</p><p>编译器实际上已经告诉了我们该如何解决——加个<code>T: &#39;static&#39;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> Timeout&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Handler + <span class="built_in">Clone</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 Future 现在满足了<code>&#39;static&#39;</code>寿命的要求，因为它不包含引用（并且任何<code>T</code>包含的引用都是<code>&#39;static&#39;</code>的）。现在，我们的代码可以编译了！</p><p>让我们创建一个类似的 handler 在响应中添加<code>Content-Type</code>头：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JsonContentType</span></span>&lt;T&gt; &#123;</span><br><span class="line">    inner_handler: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> JsonContentType&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Handler + <span class="built_in">Clone</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span> = Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="built_in">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> this = <span class="keyword">self</span>.clone();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Box</span>::pin(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> response = this.inner_handler.call(request).<span class="keyword">await</span>?;</span><br><span class="line">            response.set_header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            <span class="literal">Ok</span>(response)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与<code>Timeout</code>的模式非常相似。</p><p>接下来我们修改<code>Server::run</code>以接受我们新的<code>Handler Trait</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Server &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>&lt;T&gt;(<span class="keyword">self</span>, <span class="keyword">mut</span> handler: T) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: Handler,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> listener = TcpListener::bind(<span class="keyword">self</span>.addr).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> connection = listener.accept().<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">let</span> request = read_http_request(&amp;<span class="keyword">mut</span> connection).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// have to call `Handler::call` here</span></span><br><span class="line">            <span class="keyword">match</span> handler.call(request).<span class="keyword">await</span> &#123;</span><br><span class="line">                <span class="literal">Ok</span>(response) =&gt; write_http_response(connection, response).<span class="keyword">await</span>?,</span><br><span class="line">                <span class="literal">Err</span>(error) =&gt; handle_error_somehow(error, connection),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在可以将我们的三个 handler 组合在一起：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JsonContentType &#123;</span><br><span class="line">    inner_handler: Timeout &#123;</span><br><span class="line">        inner_handler: RequestHandler,</span><br><span class="line">        duration: Duration::from_secs(<span class="number">30</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们给我们的类型添加一些<code>new</code>方法，那就更容易构建啦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = RequestHandler;</span><br><span class="line"><span class="keyword">let</span> handler = Timeout::new(handler, Duration::from_secs(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">let</span> handler = JsonContentType::new(handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `handler` has type `JsonContentType&lt;Timeout&lt;RequestHandler&gt;&gt;`</span></span><br><span class="line"></span><br><span class="line">server.run(handler).<span class="keyword">await</span></span><br></pre></td></tr></table></figure><p>搞定！我们现在可以为<code>RequestHandler</code>增加额外的功能而不必修改它的实现。理论上，我们可以把我们的<code>JsonContentType</code>和<code>Timeout</code> handler 放到一个<code>crate</code>中，然后在<code>crates.io</code>上把它作为一个库发布供其他用户使用！</p><h1 id="让Handler更加灵活"><a href="#让Handler更加灵活" class="headerlink" title="让Handler更加灵活"></a>让<code>Handler</code>更加灵活</h1><p>我们的<code>Handler trait</code>看着还不错，但目前它只支持我们的<code>HttpRequest</code>和<code>HttpResponse</code>类型。如果这些变成了泛型，用户就可以使用他们想要的任何类型。</p><p>我们将 Request 作为 Trait 的泛型参数，这样服务就可以接受许多不同类型的请求。这样，我们的 handler 就可以用于不同的协议，而不仅仅是 HTTP 了。我们定义 Response 为一个关联类型，因为对于任意给定的请求类型，只能有且只有一种（相关的）响应类型：对应的调用返回的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Handler</span></span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误也应该是一个关联类型。没有理由让它成为一个</span></span><br><span class="line">    <span class="comment">// 硬编码的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前的 Future 类型，但现在它的输出必须使用</span></span><br><span class="line">    <span class="comment">// 相关的 Response 和 Error 类型。</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>: Future&lt;Output = <span class="built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  call 没有变化，但注意这里的 Request 是个泛型，</span></span><br><span class="line">    <span class="comment">//  而不是我们之前所使用的 HttpRequest 类型。</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对<code>RequestHandler</code>的实现现在变成了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Handler&lt;HttpRequest&gt; <span class="keyword">for</span> RequestHandler &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span> = HttpResponse;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = Error;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span> = Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="built_in">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: Request) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="comment">// 和之前一样</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Timeout&lt;T&gt;</code>则有点不同，因为它包装了一些其他的<code>Handler</code>，并添加了一个异步超时，它实际上并不关心请求或响应类型是什么，只要它所包装的<code>Handler</code>使用相同的类型。</p><p>而<code>Error</code>类型则有点不同。因为<code>tokio::time::timeout</code>会返回<code>Result&lt;T, tokio::time::error::Elapsed&gt;</code>，我们必须能够把<code>tokio::time::error::Elapsed</code>转换成内部<code>Handler</code>的错误类型。</p><p>如果我们把所有这些东西组合在一起，我们就能获得：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Timeout`接受任何类型的`R`的请求，只要和`T`接受相同类型的请求</span></span><br><span class="line"><span class="keyword">impl</span>&lt;R, T&gt; Handler&lt;R&gt; <span class="keyword">for</span> Timeout&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="comment">// 实际的请求类型必须不包含</span></span><br><span class="line">    <span class="comment">// 引用。编译器会告诉我们要添加</span></span><br><span class="line">    <span class="comment">// 这个，如果我们不这样做的话</span></span><br><span class="line">    R: <span class="symbol">&#x27;static</span>,</span><br><span class="line">    <span class="comment">// `T`必须接受`R`类型的请求</span></span><br><span class="line">    T: Handler&lt;R&gt; + <span class="built_in">Clone</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    <span class="comment">// 我们必须能够将一个超时的请求转换为</span></span><br><span class="line">    <span class="comment">// `T`的错误类型</span></span><br><span class="line">    T::Error: <span class="built_in">From</span>&lt;tokio::time::error::Elapsed&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 我们的响应类型与`T`相同，因此我们</span></span><br><span class="line">    <span class="comment">// 不需要修改它</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span> = T::Response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误类型也是一样的</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = T::Error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Future 必须输出一个具有正确类型的`Result`。</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span> = Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="built_in">Result</span>&lt;T::Response, T::Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: R) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> this = <span class="keyword">self</span>.clone();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Box</span>::pin(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> result = tokio::time::timeout(</span><br><span class="line">                this.duration,</span><br><span class="line">                this.inner_handler.call(request),</span><br><span class="line">            ).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> result &#123;</span><br><span class="line">                <span class="literal">Ok</span>(<span class="literal">Ok</span>(response)) =&gt; <span class="literal">Ok</span>(response),</span><br><span class="line">                <span class="literal">Ok</span>(<span class="literal">Err</span>(error)) =&gt; <span class="literal">Err</span>(error),</span><br><span class="line">                <span class="literal">Err</span>(elapsed) =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 转换错误类型</span></span><br><span class="line">                    <span class="literal">Err</span>(T::Error::from(elapsed))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JsonContentType</code>也有点不同。它不关心请求或错误类型，但它关心响应类型。它必须是<code>Response</code>，这样我们才能调用<code>set_header</code>。</p><p>因此，实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还是一个通用的请求类型</span></span><br><span class="line"><span class="keyword">impl</span>&lt;R, T&gt; Handler&lt;R&gt; <span class="keyword">for</span> JsonContentType&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    R: <span class="symbol">&#x27;static</span>,</span><br><span class="line">    <span class="comment">// `T`必须接受任何类型的`R`的请求，并返回`HttpResponse`类型的响应。</span></span><br><span class="line">    T: Handler&lt;R, Response = HttpResponse&gt; + <span class="built_in">Clone</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span> = HttpResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的错误类型和`T`一致</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = T::Error;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span> = Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="built_in">Result</span>&lt;Response, T::Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: R) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> this = <span class="keyword">self</span>.clone();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Box</span>::pin(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> response = this.inner_handler.call(request).<span class="keyword">await</span>?;</span><br><span class="line">            response.set_header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            <span class="literal">Ok</span>(response)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，传递给<code>Server::run</code>的<code>Handler</code>必须使用<code>HttpRequest</code>和<code>HttpResponse</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Server &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>&lt;T&gt;(<span class="keyword">self</span>, <span class="keyword">mut</span> handler: T) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: Handler&lt;HttpRequest, Response = HttpResponse&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 server 的代码不需要变：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = RequestHandler;</span><br><span class="line"><span class="keyword">let</span> handler = Timeout::new(handler, Duration::from_secs(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">let</span> handler = JsonContentType::new(handler);</span><br><span class="line"></span><br><span class="line">server.run(handler).<span class="keyword">await</span></span><br></pre></td></tr></table></figure><p>到目前为止，我们有了一个<code>Handler trait</code>，这可以将我们的应用程序分解成独立的小部分，并可以复用。看着不错！</p><h1 id="“如果我告诉你……”"><a href="#“如果我告诉你……”" class="headerlink" title="“如果我告诉你……”"></a>“如果我告诉你……”</h1><p>到目前为止，我们只讨论了 server 方面的事情。但是实际上，我们的<code>Handler trait</code>也适用于 HTTP 客户端。比如，我们可以想象有个客户端的<code>Handler</code>接受一些请求并异步地将其发送给互联网上的某 server，我们的<code>Timeout</code>包装器在这里也很有用。<code>JsonContentType</code>可能没啥用，因为设置响应头不是客户端的工作。</p><p>由于我们的<code>Handler trait</code>对于定义服务器和客户端都很有用，<code>Handler</code>可能不是一个合适的名字，毕竟客户端并不处理一个请求，它将请求发送给服务器，然后由服务器来处理它。让我们改称我们的 trait 为<code>Service</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>: Future&lt;Output = <span class="built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上<em>几乎</em>就是<code>Tower</code>中定义的<code>Service trait</code>了。如果你已经跟着看到了这里，你现在已经了解了<code>Tower</code>的大部分内容了。除了<code>Service trait</code>，<code>Tower</code>还提供了一些实用工具，通过包装其它的<code>Service</code>并实现一个<code>Service</code>，就像我们对<code>Timeout</code>和<code>JsonContentType</code>所做的那样。这些<code>Service</code>的组成方式与我们到目前为止所做的类似。</p><p>以下是一些由<code>Tower</code>提供的<code>Service</code>示例：</p><ul><li><a href="https://docs.rs/tower/latest/tower/timeout/index.html"><code>Timeout</code></a>——这与我们之前实现的超时基本相同。</li><li><a href="https://docs.rs/tower/latest/tower/retry/index.html"><code>Retry</code></a>——自动重试失败的请求。</li><li><a href="https://docs.rs/tower/latest/tower/limit/rate/index.html"><code>RateLimit</code></a>——限制一个服务在一段时间内收到的请求数量。</li></ul><p>像<code>Timeout</code>和<code>JsonContentType</code>这样的类型通常被称为<em>中间件</em>，因为它们包裹着另一个<code>Service</code>并以某种方式对请求或响应进行处理。像<code>RequestHandler</code>这样的类型通常被称为<code>叶子服务</code>，因为它们位于嵌套服务树的叶子上。实际的响应通常是在叶子服务中产生，并由中间件修改。</p><p>好了，到这里唯一（唯二？）我们剩下还没聊的是<em>backpressure</em>和<a href="https://docs.rs/tower/0.4.7/tower/trait.Service.html#tymethod.poll_ready"><code>poll_ready</code></a>。</p><h1 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h1><p>想象一下，现在你想写一个限制请求速率的中间件，来包装一个<code>Service</code>，以对底层服务的最大并发请求数进行限制。如果你的服务对它的负载量有一个硬性的上限，这将是非常有用的。</p><p>在我们目前的<code>Service trait</code>中，我们并没有一个好的方法来实现这样的东西，我们可以尝试这样做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;R, T&gt; Service&lt;R&gt; <span class="keyword">for</span> ConcurrencyLimit&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: R) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="comment">// 1. 检查当前正在处理的请求数的计数器。</span></span><br><span class="line">        <span class="comment">// 2. 如果有剩余的容量，将请求发送到`T`，并增加计数器。</span></span><br><span class="line">        <span class="comment">// 3. 如果没有，则等到有能力时再进行处理。</span></span><br><span class="line">        <span class="comment">// 4. 当返回响应后，减去计数器。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有剩余的容量，我们必须等待，并在容量可用时以某种方式得到通知。此外，我们必须在等待时将请求保留在内存中（也称为<em>缓冲</em>）。这意味着，等待的请求越多，我们的程序就会使用更多的内存——如果产生的请求超过我们的服务所能处理的数量，我们可能会耗尽内存。<br>只有当我们确定服务有能力处理请求时，才为请求分配空间，这将是更稳健的做法。否则，在我们等待我们的服务准备好时，我们有可能使用大量的内存来缓冲请求。</p><p>如果说<code>Service</code>有这样一个方法，那就完美了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">ready</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ready</code>将是一个异步函数，当服务有足够的容量来接收一个新的请求时，它就会完成并返回。我们将要求用户首先调用<code>service.ready().await</code>，然后再进行<code>service.call(require).await</code>。</p><p>将“调用服务”与“预留容量”分开，还可以有新的用法：比如我们可以维护一组“准备好的服务”，并在后台保持更新。这样，当一个请求到来时，我们已经有了一个可以使用的服务，而不需要首先等待它准备好。</p><p>通过这种设计，<code>ConcurrencyLimit</code>可以在<code>ready</code>内部计算容量，而不允许用户调用<code>call</code>，直到有足够的容量。</p><p>不关心容量的服务可以从<code>ready</code>中立即返回，或者如果它们包含了一些内部的<code>Service</code>，它们可以委托给它内部的<code>ready</code>方法。</p><p>然而，现在我们仍然不能在 trait 中定义异步函数。因此，我们可以给<code>Service</code>定义另一个关联类型，叫做<code>ReadyFuture</code>，但是必须返回一个<code>Future</code>会给我们带来我们之前遇到的同样的生命周期问题。如果有一些方法可以解决这个问题就好了。</p><p>作为替代，我们可以从<code>Future</code>特性中获得一些灵感，定义一个方法叫做<code>poll_ready</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;R&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_ready</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;()&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果服务没有容量，<code>poll_ready</code>将返回<code>Poll::Pending</code>；当容量变得可用时，使用<code>Context</code>中的<code>waker</code>通知调用者。这时，可以再次调用<code>poll_ready</code>，如果它返回<code>Poll::Ready(())</code>，那么容量就被保留了，就可以调用<code>call</code>了。</p><p>请注意，从技术上来说，没有任何东西可以阻止用户在没有确定服务准备好的情况下调用<code>call</code>，然而，这样做被认为是违反了<code>Service</code>的 API 调用约定。这时候<code>call</code>可以<code>panic</code>如果服务没有准备好。</p><p><code>poll_ready</code>不返回<code>Future</code>也意味着我们能够快速检查一个服务是否准备好了，而不需要被迫等待它准备好。如果我们<br>调用<code>poll_ready</code>并返回<code>Poll::Pending</code>，我们可以决定去做其他事情而不是等待。举个例子，这允许你写个负载均衡器，通过服务返回<code>Poll::Pending</code>的频率来估计服务的负载，并将请求发送到负载最小的服务。</p><p>使用类似于<a href="https://docs.rs/futures/0.3.14/futures/future/fn.poll_fn.html"><code>futures::future::poll_fn</code></a>或者<a href="https://docs.rs/tower/0.4.7/tower/trait.ServiceExt.html#method.ready"><code>tower::ServiceExt::ready</code></a>的东西，仍然可以获得一个等待服务容量可用的 Future。</p><p>这种服务与它们的调用者沟通其容量的概念被称为“反压传播”。你可以把它看作是服务向后反推他们的调用者，并且如果他们产生的请求太快了时，告诉他们需要放慢速度。其基本思想是，你不应该向一个没有能力处理的服务发送请求。相反，你应该等待（缓冲），放弃请求（减负），或以其他方式处理能力不足的问题。你可以在<a href="https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7">这里</a>和<a href="https://aws.amazon.com/builders-library/using-load-shedding-to-avoid-overload/">这里</a>了解更多关于背压的一般概念。</p><p>最后，在预留容量时也可能发生一些错误，所以<code>poll_ready</code>也许应该返回<code>Poll&lt;Result&lt;(), Self::Error&gt;</code>。</p><p>有了这一改变，我们现在已经有了完整的<code>tower::Service</code>特性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>: Future&lt;Output = <span class="built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_ready</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">    ) -&gt; Poll&lt;<span class="built_in">Result</span>&lt;(), Self::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, req: Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>许多中间件不添加自己的背压，而只是委托给被封装的服务的<code>poll_ready</code>实现。然而，中间件的背压确实可以实现一些有趣的用例，例如各种速率限制、负载均衡和自动扩容。</p><p>由于你永远不知道一个<code>Service</code>可能由哪些中间件组成，所以重要的是不要忘记调用<code>poll_ready</code>。</p><p>有了这一切，调用服务的最常用方法是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tower::&#123;</span><br><span class="line">    Service,</span><br><span class="line">    <span class="comment">// for the `ready` method</span></span><br><span class="line">    ServiceExt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> response = service</span><br><span class="line">    <span class="comment">// wait for the service to have capacity</span></span><br><span class="line">    .ready().<span class="keyword">await</span>?</span><br><span class="line">    <span class="comment">// send the request</span></span><br><span class="line">    .call(request).<span class="keyword">await</span>?;</span><br></pre></td></tr></table></figure><div style="text-align:right">&mdash; David Pedersen (<a href="https://github.com/davidpdrsn">@davidpdrsn</a>) </div><hr><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p><a name="pin">1</a>: 关于<code>call</code>是否应该使用<code>Pin&lt;&amp;mut Self&gt;</code> ，已经有了一些讨论。但是到目前为止，我们决定采用一个普通的 <code>&amp;mut self</code>，这意味着 handler（咳，<em>Services</em>）必须是<code>Unpin</code>。在实践中，这很少出现问题。更多细节可以看<a href="https://github.com/tower-rs/tower/issues/319">这里</a>。</p><p><a name="gats">2</a>: 说得更准确一点，这要求响应返回的 Future 必须是<code>&#39;static&#39;</code>的，因为写<code>Box&lt;dyn Future&gt;</code>实际上会被 desugar 成<code>Box&lt;dyn Future + &#39;static&gt;</code>，因此在<code>fn call(&amp;&#39;_ mut self, ...) </code>中的匿名<code>lifetime</code>并不满足这个要求。在未来，Rust编译器团队计划增加一个名为<a href="https://github.com/rust-lang/rust/issues/44265">泛型关联类型（GAT）</a>的功能，这将解决这个问题。泛型关联类型允许我们将响应的 future 定义为<code>type Future&lt;&#39;a&gt;</code>，<code>call</code>定义为<code>fn call&lt;&#39;a&gt;(&amp;&#39;a mut self, ...) -&gt; Self::Future&lt;&#39;a&gt;</code>，但现在响应返回的 Future 必须是<code>&#39;static</code>的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写在前面：&lt;/p&gt;
&lt;p&gt;最近看到了一篇讲 Rust 如何对框架进行抽象的文章，写得非常好，这两天抽空翻译了一下。&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://tokio.rs/blog/2021-05-14-inventing-the-service-trait&quot;&gt;https://tokio.rs/blog/2021-05-14-inventing-the-service-trait&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tower-rs/tower&quot;&gt;&lt;code&gt;Tower&lt;/code&gt;&lt;/a&gt;是一个模块化和可重复使用的用来构建 client 和 server 的组件库。其核心是&lt;a href=&quot;https://docs.rs/tower/latest/tower/trait.Service.html&quot;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt;特性。一个&lt;code&gt;Service&lt;/code&gt;是一个异步函数，它接受一个请求并产生一个响应。然而，&lt;code&gt;Tower&lt;/code&gt;设计的某些方面可能不是那么一目了然。&lt;/p&gt;
&lt;p&gt;与其解释今天存在于&lt;code&gt;Tower&lt;/code&gt;中的&lt;code&gt;Service&lt;/code&gt;特性，不如来看看&lt;code&gt;Service&lt;/code&gt;背后的设计考量。让我们试试看，如果今天重新设计实现它，我们会怎么做。&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="https://www.purewhite.io/categories/rust/"/>
    
    
    <category term="rust" scheme="https://www.purewhite.io/tags/rust/"/>
    
    <category term="tokio" scheme="https://www.purewhite.io/tags/tokio/"/>
    
  </entry>
  
  <entry>
    <title>一次 Golang 的 time.Now 优化之旅</title>
    <link href="https://www.purewhite.io/2021/04/29/golang-time-now-optimize/"/>
    <id>https://www.purewhite.io/2021/04/29/golang-time-now-optimize/</id>
    <published>2021-04-29T06:10:44.000Z</published>
    <updated>2021-12-02T12:51:07.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>最近想尝试在 Golang 里面实现<code>clock_gettime</code>的<code>CLOCK_REALTIME_COARSE</code>和<code>CLOCK_MONOTONIC_COARSE</code>，正好深入研究了下 <code>time.Now</code>的实现，还机缘巧合下顺便优化了一把<code>time.Now</code>（虽然最终提交的是 Ian 大佬的版本）。</p><p>在这里记录下来整个过程，以供查阅。</p><span id="more"></span><h1 id="time-Now-实现原理"><a href="#time-Now-实现原理" class="headerlink" title="time.Now 实现原理"></a>time.Now 实现原理</h1><p>首先我们来看看 <code>time.Now</code>的实现原理，从代码（以下代码基于 Go &lt;= 1.16 版本）入手：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provided by package runtime.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">now</span><span class="params">()</span> <span class="params">(sec <span class="keyword">int64</span>, nsec <span class="keyword">int32</span>, mono <span class="keyword">int64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now returns the current local time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">sec, nsec, mono := now()</span><br><span class="line">mono -= startNano</span><br><span class="line">sec += unixToInternal - minWall</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint64</span>(sec)&gt;&gt;<span class="number">33</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Time&#123;<span class="keyword">uint64</span>(nsec), sec + minWall, Local&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Time&#123;hasMonotonic | <span class="keyword">uint64</span>(sec)&lt;&lt;nsecShift | <span class="keyword">uint64</span>(nsec), mono, Local&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>time.Now</code>里面实际上是调用了<code>now</code>来获得对应的时间数值，然后进行了一系列的处理。这部分处理就不说了，网上有较多资料，也不是本文重点。我们接着去<code>runtime</code>包里面找找<code>now</code>是怎么实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname time_now time.now</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_now</span><span class="params">()</span> <span class="params">(sec <span class="keyword">int64</span>, nsec <span class="keyword">int32</span>, mono <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">sec, nsec = walltime()</span><br><span class="line"><span class="keyword">return</span> sec, nsec, nanotime()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据关键字搜索，很快能搜到在<code>runtime</code>的<code>timestub.go</code>文件中的以上代码，可以看到实际上调用了两个方法：<code>walltime</code>和<code>nanotime</code>，这两个方法又调用了<code>walltime1</code>和<code>nanotime1</code>，并且是以汇编实现的，让我们继续深入看下这两个方法的汇编实现，因为代码基本相同，这边以<code>walltime1</code>作为例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// func walltime1() (sec int64, nsec int32)</span><br><span class="line">// non-zero frame-size means bp is saved and restored</span><br><span class="line">TEXT runtime·walltime1(SB),NOSPLIT,$16-12</span><br><span class="line">// We don&#x27;t know how much stack space the VDSO code will need,</span><br><span class="line">// so switch to g0.</span><br><span class="line">// In particular, a kernel configured with CONFIG_OPTIMIZE_INLINING=n</span><br><span class="line">// and hardening can use a full page of stack space in gettime_sym</span><br><span class="line">// due to stack probes inserted to avoid stack/heap collisions.</span><br><span class="line">// See issue #20427.</span><br><span class="line"></span><br><span class="line">MOVQSP, R12// Save old SP; R12 unchanged by C code.</span><br><span class="line"></span><br><span class="line">get_tls(CX)</span><br><span class="line">MOVQg(CX), AX</span><br><span class="line">MOVQg_m(AX), BX // BX unchanged by C code.</span><br><span class="line"></span><br><span class="line">// Set vdsoPC and vdsoSP for SIGPROF traceback.</span><br><span class="line">// Save the old values on stack and restore them on exit,</span><br><span class="line">// so this function is reentrant.</span><br><span class="line">MOVQm_vdsoPC(BX), CX</span><br><span class="line">MOVQm_vdsoSP(BX), DX</span><br><span class="line">MOVQCX, 0(SP)</span><br><span class="line">MOVQDX, 8(SP)</span><br><span class="line"></span><br><span class="line">LEAQsec+0(FP), DX</span><br><span class="line">MOVQ-8(DX), CX</span><br><span class="line">MOVQCX, m_vdsoPC(BX)</span><br><span class="line">MOVQDX, m_vdsoSP(BX)</span><br><span class="line"></span><br><span class="line">CMPQAX, m_curg(BX)// Only switch if on curg.</span><br><span class="line">JNEnoswitch</span><br><span class="line"></span><br><span class="line">MOVQm_g0(BX), DX</span><br><span class="line">MOVQ(g_sched+gobuf_sp)(DX), SP// Set SP to g0 stack</span><br><span class="line"></span><br><span class="line">noswitch:</span><br><span class="line">SUBQ$16, SP// Space for results</span><br><span class="line">ANDQ$~15, SP// Align for C code</span><br><span class="line"></span><br><span class="line">MOVL$0, DI // CLOCK_REALTIME</span><br><span class="line">LEAQ0(SP), SI</span><br><span class="line">MOVQruntime·vdsoClockgettimeSym(SB), AX</span><br><span class="line">CMPQAX, $0</span><br><span class="line">JEQfallback</span><br><span class="line">CALLAX</span><br><span class="line">ret:</span><br><span class="line">MOVQ0(SP), AX// sec</span><br><span class="line">MOVQ8(SP), DX// nsec</span><br><span class="line">MOVQR12, SP// Restore real SP</span><br><span class="line">// Restore vdsoPC, vdsoSP</span><br><span class="line">// We don&#x27;t worry about being signaled between the two stores.</span><br><span class="line">// If we are not in a signal handler, we&#x27;ll restore vdsoSP to 0,</span><br><span class="line">// and no one will care about vdsoPC. If we are in a signal handler,</span><br><span class="line">// we cannot receive another signal.</span><br><span class="line">MOVQ8(SP), CX</span><br><span class="line">MOVQCX, m_vdsoSP(BX)</span><br><span class="line">MOVQ0(SP), CX</span><br><span class="line">MOVQCX, m_vdsoPC(BX)</span><br><span class="line">MOVQAX, sec+0(FP)</span><br><span class="line">MOVLDX, nsec+8(FP)</span><br><span class="line">RET</span><br><span class="line">fallback:</span><br><span class="line">MOVQ$SYS_clock_gettime, AX</span><br><span class="line">SYSCALL</span><br><span class="line">JMP ret</span><br></pre></td></tr></table></figure><p>这段代码的注释非常的清晰，根据这段代码，可以看到，实际上是使用的<code>vdso call</code>来获取到当前的时间信息。只不过，由于 Go 是自己维护的协程的栈，而这个栈在某些内核上调用<code>vdso</code>会出问题，所以需要先切换到<code>g0</code>（也就是系统线程的栈）上才行。所以这里在开头和结尾有很多额外的操作，需要制造和清理作案现场。</p><p>有同学可能对<code>vdso</code>不了解，这里简单介绍下，实际上一开始获取时间信息是需要通过系统调用的，也就是要 syscall 才行，但是众所周知，syscall 的性能较差，同时获取时间戳又是个高频操作，所以大家也想办法优化了几版，最终是现在采用的<code>vdso</code>的方案。<code>vdso</code>全称是<code>virtual dynamic shared object</code>，简单来说就是把这段原本需要系统调用的方法，像动态链接库（<code>so</code>库）一样加载到用户内存空间里面，这样用户的进程就可以像调用一个普通方法一样调用这个方法了，可以避免系统调用的额外开销。具体可以参考一下：<a href="https://man7.org/linux/man-pages/man7/vdso.7.html%E3%80%82">https://man7.org/linux/man-pages/man7/vdso.7.html。</a></p><p>看完<code>walltime1</code>之后我们来看下<code>nanotime1</code>，由于开头的切换到<code>g0</code>的代码都是一样的，所以这里只截取后续部分的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">noswitch:</span><br><span class="line">SUBQ$16, SP// Space for results</span><br><span class="line">ANDQ$~15, SP// Align for C code</span><br><span class="line"></span><br><span class="line">MOVL$1, DI // CLOCK_MONOTONIC</span><br><span class="line">LEAQ0(SP), SI</span><br><span class="line">MOVQruntime·vdsoClockgettimeSym(SB), AX</span><br><span class="line">CMPQAX, $0</span><br><span class="line">JEQfallback</span><br><span class="line">CALLAX</span><br><span class="line">ret:</span><br><span class="line">MOVQ0(SP), AX// sec</span><br><span class="line">MOVQ8(SP), DX// nsec</span><br><span class="line">MOVQR12, SP// Restore real SP</span><br><span class="line">// Restore vdsoPC, vdsoSP</span><br><span class="line">// We don&#x27;t worry about being signaled between the two stores.</span><br><span class="line">// If we are not in a signal handler, we&#x27;ll restore vdsoSP to 0,</span><br><span class="line">// and no one will care about vdsoPC. If we are in a signal handler,</span><br><span class="line">// we cannot receive another signal.</span><br><span class="line">MOVQ8(SP), CX</span><br><span class="line">MOVQCX, m_vdsoSP(BX)</span><br><span class="line">MOVQ0(SP), CX</span><br><span class="line">MOVQCX, m_vdsoPC(BX)</span><br><span class="line">// sec is in AX, nsec in DX</span><br><span class="line">// return nsec in AX</span><br><span class="line">IMULQ$1000000000, AX</span><br><span class="line">ADDQDX, AX</span><br><span class="line">MOVQAX, ret+0(FP)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>可以看到，唯二修改的就是调用的<code>clockid</code>——<code>CLOCK_MONOTONIC</code>和<code>RET</code>之前的处理逻辑——将返回结果转换成纳秒。</p><h1 id="time-Now-优化"><a href="#time-Now-优化" class="headerlink" title="time.Now 优化"></a>time.Now 优化</h1><p>说到这里，大家应该就能发现问题所在了——<code>time.Now</code>调用了一次<code>walltime</code>和一次<code>nanotime</code>，这两次调用都有几乎一样的切换到<code>g0</code>栈再恢复的代码，而且这段代码量还比较多。如果我们把这两次调用给合并到一起，就可以节省一次切换栈和准备工作导致的额外开销了！</p><p>Go 官方团队的 Ian 大佬和我（几乎）同时提了对应的 pr 来优化这部分的逻辑，最终 Ian 大佬实现的性能更好（-20%，<a href="https://go-review.googlesource.com/c/go/+/314571">我的版本</a>是 -17%），于是最终采用的是 Ian 大佬的版本：<a href="https://go-review.googlesource.com/c/go/+/314277/%E3%80%82">https://go-review.googlesource.com/c/go/+/314277/。</a></p><h1 id="在runtime外调用vdso？"><a href="#在runtime外调用vdso？" class="headerlink" title="在runtime外调用vdso？"></a>在<code>runtime</code>外调用<code>vdso</code>？</h1><p>回到开头，我是想自己实现<code>clock_gettime</code>的<code>CLOCK_REALTIME_COARSE</code>和<code>CLOCK_MONOTONIC_COARSE</code>，这就需要我在<code>runtime</code>包外部实现以上的一系列操作。但是如果要这么干，就需要把所有<code>runtime</code>包里面的结构体定义全部复制一份（这样在汇编代码里面 include 的 <code>go_asm.h</code>才有对应的偏移量），这样可维护性太差了，而且如果某个版本调整了结构体的顺序，行为就不可定义，太危险了，要不就得每个版本单独复制一份出来。</p><p>针对这个问题，也和 Go 官方进行了讨论，最终确实没有什么太好的思路，Go 目前不支持在<code>runtime</code>外部安全地调用<code>vdso</code>。</p><p>不过不管怎么样，在这个讨论的过程中，促成了<code>time.Now</code>的优化，还是不枉此行。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;p&gt;最近想尝试在 Golang 里面实现&lt;code&gt;clock_gettime&lt;/code&gt;的&lt;code&gt;CLOCK_REALTIME_COARSE&lt;/code&gt;和&lt;code&gt;CLOCK_MONOTONIC_COARSE&lt;/code&gt;，正好深入研究了下 &lt;code&gt;time.Now&lt;/code&gt;的实现，还机缘巧合下顺便优化了一把&lt;code&gt;time.Now&lt;/code&gt;（虽然最终提交的是 Ian 大佬的版本）。&lt;/p&gt;
&lt;p&gt;在这里记录下来整个过程，以供查阅。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
    <category term="asm" scheme="https://www.purewhite.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>Golang 泛型初探</title>
    <link href="https://www.purewhite.io/2021/03/09/golang-generic-glance/"/>
    <id>https://www.purewhite.io/2021/03/09/golang-generic-glance/</id>
    <published>2021-03-09T09:24:55.000Z</published>
    <updated>2021-12-02T12:51:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 的泛型实现已经正式合并到 master 分支上啦，之后也会在 master 分支上进行开发，那么作为期待这个 feature 许久的 gopher，也想第一时间看看到底是如何实现的。</p><span id="more"></span><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>这里不过多讲解泛型的语法，具体可以参考一下 <a href="https://github.com/golang/go/issues/43651">https://github.com/golang/go/issues/43651</a> 这个 issue。</p><p>简单来说，在 struct 和 func 的名字后面可以加一个 [] 里面包含泛型的名字和限制条件，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> container[T any] <span class="keyword">struct</span>&#123;</span><br><span class="line">    elem T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>any 是个特殊的关键字，表示所有类型都可以。</p><h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><p>这里我们写一个示例程序来编译成汇编，来看看泛型到底是怎么实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stringer2 <span class="keyword">interface</span> &#123;</span><br><span class="line">Stringer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> container[T Stringer] <span class="keyword">struct</span> &#123;</span><br><span class="line">s T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stringerImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s stringerImpl)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> s.s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loop</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">_ = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">loop([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line">c := container[Stringer2]&#123;&#125;</span><br><span class="line">loop([]container[Stringer2]&#123;c&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译成汇编"><a href="#编译成汇编" class="headerlink" title="编译成汇编"></a>编译成汇编</h1><p>我们先基于 master 分支来编译一个 go 出来，然后用这个 go 来执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build -gcflags=<span class="string">&quot;-G=3 -l -S&quot;</span> main.go &gt; main.s 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><p>接下来去<code>main.s</code>这个文件看看，就会发现有这么一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.#loop[int] STEXT nosplit size=18 args=0x18 locals=0x0 funcid=0x0</span><br><span class="line">0x0000 00000 (/Users/purewhite/go/src/local/study/main.go:39)TEXT&quot;&quot;.#loop[int](SB), NOSPLIT|ABIInternal, $0-24</span><br><span class="line">0x0000 00000 (/Users/purewhite/go/src/local/study/main.go:39)FUNCDATA$0, gclocals·1a65e721a2ccc325b382662e7ffee780(SB)</span><br><span class="line">0x0000 00000 (/Users/purewhite/go/src/local/study/main.go:39)FUNCDATA$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x0000 00000 (/Users/purewhite/go/src/local/study/main.go:33)MOVQ&quot;&quot;.s+16(SP), AX</span><br><span class="line">0x0005 00005 (/Users/purewhite/go/src/local/study/main.go:33)XORLCX, CX</span><br><span class="line">0x0007 00007 (/Users/purewhite/go/src/local/study/main.go:33)JMP12</span><br><span class="line">0x0009 00009 (/Users/purewhite/go/src/local/study/main.go:33)INCQCX</span><br><span class="line">0x000c 00012 (/Users/purewhite/go/src/local/study/main.go:33)CMPQAX, CX</span><br><span class="line">0x000f 00015 (/Users/purewhite/go/src/local/study/main.go:33)JGT9</span><br><span class="line">0x0011 00017 (/Users/purewhite/go/src/local/study/main.go:33)RET</span><br><span class="line">0x0000 48 8b 44 24 10 31 c9 eb 03 48 ff c1 48 39 c8 7f  H.D$.1...H..H9..</span><br><span class="line">0x0010 f8 c3                                            ..</span><br><span class="line">&quot;&quot;.#loop[container[Stringer2]] STEXT nosplit size=21 args=0x18 locals=0x0 funcid=0x0</span><br><span class="line">0x0000 00000 (/Users/purewhite/go/src/local/study/main.go:44)TEXT&quot;&quot;.#loop[container[Stringer2]](SB), NOSPLIT|ABIInternal, $0-24</span><br><span class="line">0x0000 00000 (/Users/purewhite/go/src/local/study/main.go:44)FUNCDATA$0, gclocals·1a65e721a2ccc325b382662e7ffee780(SB)</span><br><span class="line">0x0000 00000 (/Users/purewhite/go/src/local/study/main.go:44)FUNCDATA$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x0000 00000 (/Users/purewhite/go/src/local/study/main.go:33)MOVQ&quot;&quot;.s+16(SP), AX</span><br><span class="line">0x0005 00005 (/Users/purewhite/go/src/local/study/main.go:33)TESTQAX, AX</span><br><span class="line">0x0008 00008 (/Users/purewhite/go/src/local/study/main.go:33)JLE20</span><br><span class="line">0x000a 00010 (/Users/purewhite/go/src/local/study/main.go:33)XORLCX, CX</span><br><span class="line">0x000c 00012 (/Users/purewhite/go/src/local/study/main.go:33)INCQCX</span><br><span class="line">0x000f 00015 (/Users/purewhite/go/src/local/study/main.go:33)CMPQAX, CX</span><br><span class="line">0x0012 00018 (/Users/purewhite/go/src/local/study/main.go:33)JGT12</span><br><span class="line">0x0014 00020 (/Users/purewhite/go/src/local/study/main.go:33)RET</span><br><span class="line">0x0000 48 8b 44 24 10 48 85 c0 7e 0a 31 c9 48 ff c1 48  H.D$.H..~.1.H..H</span><br><span class="line">0x0010 39 c8 7f f8 c3                                   9....</span><br></pre></td></tr></table></figure><p>再看 main 中调用的地方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x008c 00140 (/Users/purewhite/go/src/local/study/main.go:39)CALL&quot;&quot;.#loop[int](SB)</span><br><span class="line">...</span><br><span class="line">0x00c0 00192 (/Users/purewhite/go/src/local/study/main.go:44)CALL&quot;&quot;.#loop[container[Stringer2]](SB)</span><br></pre></td></tr></table></figure><p>基本可以确定，go 的泛型目前的实现方案是在编译时进行代码生成，这个方案虽然会降低编译速度，但是在运行时是没有性能损耗的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Golang 的泛型实现已经正式合并到 master 分支上啦，之后也会在 master 分支上进行开发，那么作为期待这个 feature 许久的 gopher，也想第一时间看看到底是如何实现的。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
    <category term="asm" scheme="https://www.purewhite.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>使用 SIMD 优化 Thrift 编码</title>
    <link href="https://www.purewhite.io/2021/01/06/simd-optimize-thrift/"/>
    <id>https://www.purewhite.io/2021/01/06/simd-optimize-thrift/</id>
    <published>2021-01-06T07:41:29.000Z</published>
    <updated>2021-12-02T12:51:07.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>可以先看下我之前在 JTalk 上分享的实践：<a href="https://www.bilibili.com/video/BV1UZ4y1g7ju">https://www.bilibili.com/video/BV1UZ4y1g7ju</a></p><p>这篇文章是对于其中我最后说的“使用 SIMD 优化”部分的详细说明。</p><h1 id="TL；DR"><a href="#TL；DR" class="headerlink" title="TL；DR"></a>TL；DR</h1><p>List&lt;i64&gt; 场景下提升六倍，List&lt;i32&gt; 提升十二倍。</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>基于 FastRead/Write 接口，由于我们已经拿到了所有的内存，所以我们可以尝试采用 SIMD 来进一步的优化。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>最容易想到的优化点也是公司内最常见的用法 list&lt;i64/i32&gt;，这个比较容易想到使用 SIMD 进行优化。</p><p>在 thrift binary 里面，int 类型在复制到 buffer 之前需要先转成大端，也就是 binary.BigEndian.PutInt 一次，这个操作原本需要比较多语句，通过软件来模拟，但是在 amd64 下有一个 BSWAP 指令可以直接完成，这个优化 Go 编译器已经做了，所以现在的伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> src, dst</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++ &#123;</span><br><span class="line">    dst[i] = bswap(src[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，这个操作实际上是很有规律的，并且全都是相邻的操作，符合 SIMD 指令的模式。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><p>先使用了 C++ 做了一个 POC（只贴了关键代码，完整代码见 <a href="https://gist.github.com/PureWhiteWu/e88f241fc8b62df06ae1eb04923a88ae%EF%BC%89%EF%BC%9A">https://gist.github.com/PureWhiteWu/e88f241fc8b62df06ae1eb04923a88ae）：</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> MASK = <span class="number">0x0001020304050607</span>;</span><br><span class="line"><span class="keyword">const</span> __mmask16 bit16mask[<span class="number">17</span>] = &#123;<span class="number">0x0000</span>, <span class="number">0x0001</span>, <span class="number">0x0003</span>, <span class="number">0x0007</span>, <span class="number">0x000f</span>, <span class="number">0x001f</span>, <span class="number">0x003f</span>, <span class="number">0x007f</span>, <span class="number">0x00ff</span>, <span class="number">0x01ff</span>, <span class="number">0x03ff</span>, <span class="number">0x07ff</span>, <span class="number">0x0fff</span>, <span class="number">0x1fff</span>, <span class="number">0x3fff</span>, <span class="number">0x7fff</span>, <span class="number">0xffff</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avx512_little_2_big</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *src, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *dst, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loop_count = n / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> remainder = n % <span class="number">8</span>;</span><br><span class="line">    __m512i mask = _mm512_set1_epi64(MASK);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i * <span class="number">8</span>;</span><br><span class="line">        __m512i input_data = _mm512_loadu_si512(&amp;src[index]);</span><br><span class="line">        __m512i output_data = _mm512_shuffle_epi8(input_data, mask);</span><br><span class="line">        _mm512_storeu_si512(&amp;avx512_data[index], output_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (remainder != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = loop_count * <span class="number">8</span>;</span><br><span class="line">        __m512i padding = _mm512_set1_epi64(<span class="number">0</span>);</span><br><span class="line">        __m512i input_data = _mm512_mask_loadu_epi64(padding, bit16mask[remainder], &amp;src[index]);</span><br><span class="line">        __m512i output_data = _mm512_shuffle_epi8(input_data, mask);</span><br><span class="line">        _mm512_mask_storeu_epi64(&amp;avx512_data[index], bit16mask[remainder], output_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avx2_little_2_big</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *src, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *dst, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loop_count = n / <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> remainder = n % <span class="number">4</span>;</span><br><span class="line">    __m256i mask = _mm256_set1_epi64x(MASK);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i * <span class="number">4</span>;</span><br><span class="line">        __m256i input_data = _mm256_loadu_si256((__m256i *)&amp;src[index]);</span><br><span class="line">        __m256i output_data = _mm256_shuffle_epi8(input_data, mask);</span><br><span class="line">        _mm256_storeu_si256((__m256i *)&amp;avx2_data[index], output_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (remainder != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = loop_count * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; index + remainder; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            avx2_data[i] = <span class="built_in">bswap_64</span>(src[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p>编译命令如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">g</span>++ <span class="comment">little_2_big_gcc</span><span class="string">.</span><span class="comment">cpp</span> <span class="literal">-</span><span class="comment">o</span> <span class="comment">ll2</span> <span class="literal">-</span><span class="comment">mavx512f</span> <span class="literal">-</span><span class="comment">mavx512bw</span> <span class="literal">-</span><span class="comment">mavx2</span> <span class="literal">-</span><span class="comment">mavx</span> <span class="literal">-</span><span class="comment">O3</span></span><br></pre></td></tr></table></figure><p>在 linux 物理机上进行测试，结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">avx512</span> time: <span class="number">27009</span> us</span><br><span class="line"><span class="attribute">avx2</span> time: <span class="number">21920</span> us</span><br><span class="line"><span class="attribute">bswap</span> time: <span class="number">49967</span> us</span><br></pre></td></tr></table></figure><p>可以得出结论：</p><ol><li>avx512 的性能很不稳定，有些情况下还不如 avx2；</li><li>avx2 相比 bswap 方案基本可以提升一倍以上的性能；</li><li>Linus 诚不欺我。</li></ol><h1 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h1><p>bswap 做的事情是将整个字节序进行倒序，以 int32 为例，包含 4 字节，假设原来数据如下：</p><p>00000000 00000001 00000010 00000011</p><p>那么 bswap 之后，数据为：</p><p>00000011 00000010 00000001 00000000</p><p>在 avx2 中，也有一个指令 vpshufb 能够达到类似的效果，不过不是纯粹的 bswap，详见：<a href="https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/intrinsics-for-intel-advanced-vector-extensions-2/intrinsics-for-shuffle-operations-1/mm256-shuffle-epi8.html">https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/intrinsics-for-intel-advanced-vector-extensions-2/intrinsics-for-shuffle-operations-1/mm256-shuffle-epi8.html</a></p><p>shuffle 的意思是“洗牌”，作用是可以根据一个传入的 mask 来重排对应 byte 的位置。所以这里最关键的就是代码示例中最上面那行：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> MASK = <span class="number">0x0001020304050607</span>;</span><br></pre></td></tr></table></figure><p>为什么用这个 mask 就行了呢？我们得复习一下大小端的知识。</p><p>大端字节序是符合人类阅读习惯的顺序，高位在前，还是以刚才的 int32 作为例子，假如大端序表示如下：</p><p>00000011（高位在这里） 00000010 00000001 00000000</p><p>那么在我们电脑上，小端字节序就是这么存的：</p><table><thead><tr><th>内存地址</th><th>0</th><th>1</th><th>2</th><th>3（高位在这里）</th></tr></thead><tbody><tr><td>值</td><td>00000000</td><td>00000001</td><td>00000010</td><td>00000011</td></tr></tbody></table><p>这时候对应的 MASK 是 0x00010203，在内存中以小端序表示为：</p><table><thead><tr><th>内存地址</th><th>0</th><th>1</th><th>2</th><th>3（高位在这里）</th></tr></thead><tbody><tr><td>值</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tbody></table><p>我们的机器都是小端序的，所以，在做 shuffle 的时候，内存地址 0 对应的是 内存地址 3 处的值，内存地址 1 对应的是 内存地址 2 处的值，以此类推。</p><p>这样，shuffle 计算下来之后，内存中的值就变成了：</p><table><thead><tr><th>内存地址</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>值</td><td>00000011</td><td>00000010</td><td>00000001</td><td>00000000</td></tr></tbody></table><p><img data-src="https://static-ali-oss.purewhite.io/uPic/2021-01-06/124kux-image-20210106162329929.png!webp_90" alt="shuffle"></p><p>这时候，也就相当于成功完成了一次 bswap 的操作了。</p><p>由于 int64 有 8 位，所以 MASK 为 0x00 01 02 03 04 05 06 07 就可以完成一次 int64 的 bswap。</p><p><em>（注：没有 0 键在编写此节时遭到虐待）</em></p><h1 id="Go-中测试结果"><a href="#Go-中测试结果" class="headerlink" title="Go 中测试结果"></a>Go 中测试结果</h1><p>最后附上 Go 中的测试结果，我们测试了 List 中有 12345 个元素的 benchmark：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">BenchmarkWriteListI64</span></span><br><span class="line"><span class="attribute">BenchmarkWriteListI64</span>-<span class="number">16</span>         <span class="number">703928</span>         <span class="number">1753</span> ns/op</span><br><span class="line"><span class="attribute">BenchmarkWriteI64</span></span><br><span class="line"><span class="attribute">BenchmarkWriteI64</span>-<span class="number">16</span>              <span class="number">98204</span>        <span class="number">11875</span> ns/op</span><br><span class="line"><span class="attribute">BenchmarkWriteListI32</span></span><br><span class="line"><span class="attribute">BenchmarkWriteListI32</span>-<span class="number">16</span>        <span class="number">1300507</span>          <span class="number">907</span> ns/op</span><br><span class="line"><span class="attribute">BenchmarkWriteI32</span></span><br><span class="line"><span class="attribute">BenchmarkWriteI32</span>-<span class="number">16</span>              <span class="number">98522</span>        <span class="number">12580</span> ns/op</span><br></pre></td></tr></table></figure><p>可以看出，在 Go 上的性能提升非常巨大，List&lt;i64&gt; 场景下提升六倍，List&lt;i32&gt; 更是提升了十几倍。</p><p>究其原因，应该是 Go 做的优化太少太差，远远比不上 gcc。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h1&gt;&lt;p&gt;可以先看下我之前在 JTalk 上分享的实践：&lt;a href=&quot;https://www.bilibili.com/video/BV1UZ4y1g7ju&quot;&gt;https://www.bilibili.com/video/BV1UZ4y1g7ju&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章是对于其中我最后说的“使用 SIMD 优化”部分的详细说明。&lt;/p&gt;
&lt;h1 id=&quot;TL；DR&quot;&gt;&lt;a href=&quot;#TL；DR&quot; class=&quot;headerlink&quot; title=&quot;TL；DR&quot;&gt;&lt;/a&gt;TL；DR&lt;/h1&gt;&lt;p&gt;List&amp;lt;i64&amp;gt; 场景下提升六倍，List&amp;lt;i32&amp;gt; 提升十二倍。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
    <category term="asm" scheme="https://www.purewhite.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>掘金JTalk Meetup 11期 - Golang 进阶指南和最佳实践</title>
    <link href="https://www.purewhite.io/2020/12/21/jtalk-11-golang/"/>
    <id>https://www.purewhite.io/2020/12/21/jtalk-11-golang/</id>
    <published>2020-12-21T05:54:15.000Z</published>
    <updated>2021-12-02T12:51:07.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p><a href="https://www.bilibili.com/video/BV1UZ4y1g7ju">https://www.bilibili.com/video/BV1UZ4y1g7ju</a></p><h1 id="PPT-下载"><a href="#PPT-下载" class="headerlink" title="PPT 下载"></a>PPT 下载</h1><p>链接: <a href="https://pan.baidu.com/s/1w8TKFZcFbAi-ug26pzkxug">https://pan.baidu.com/s/1w8TKFZcFbAi-ug26pzkxug</a>  密码: vvbh</p><p>解压密码：purewhite.io</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视频&quot;&gt;&lt;a href=&quot;#视频&quot; class=&quot;headerlink&quot; title=&quot;视频&quot;&gt;&lt;/a&gt;视频&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1UZ4y1g7ju&quot;&gt;https://www.bili</summary>
      
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用人工智能优化 Golang 编译器</title>
    <link href="https://www.purewhite.io/2020/10/14/manual-intelligence-optimize-golang-compiler/"/>
    <id>https://www.purewhite.io/2020/10/14/manual-intelligence-optimize-golang-compiler/</id>
    <published>2020-10-14T08:26:00.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有多少人工就有多少智能。                            ——鲁迅</p></blockquote><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>众所周知，字节跳动内部主要使用 Thrift，为了更好地掌控生成代码，我们用 Go 自己实现了 Thrift 代码生成工具。</p><p>而我们的故(shi)事(gu)，正是由一次重构开始……</p><span id="more"></span><p>在一次平淡无奇的重构发版后，正当我拎着电脑包往外冲心里已经盘算好了回去之后要拿出我熟练度 30W 的至臻 KDA 卡莎大杀四方时，业务方拉住了我，告诉我他们在用了新版的生成代码后，性能下降了10%。</p><p>内心 os：What？？？你们是不是有其它逻辑变更？<del>我写的代码怎么可能有 bug</del> 逻辑一模一样的生成代码怎么可能会有性能差异？</p><p>好吧，为了避免突然哪一天账号已停用，我还是耐心地问了业务方一个问题：</p><img data-src="https://static.purewhite.io/uPic/2020-10-14/QpVggz-image-20201014151957346.png!webp_90" width="30%" alt="能重现吗？" style="margin: 0 auto;"/><p>于是在一通如此这般地各种标准对齐、环境对齐等等一通操作（此处省略 2^10^10 字）后，我们终于搞清楚了状况：</p><p><strong>重构后的生成代码比重构之前，在该业务方的 idl 上，性能真的要差 10%！</strong></p><p>What？？？虽然重构过生成代码，但是新的生成代码无论从语义上还是实现上都是（几乎）和旧的一致的，怎么可能性能会差？？？</p><p>好吧，为了发扬我大 IG 不加班的光辉传统，我们决定直接十五投就完事——把生成代码 revert 回旧版的。好了，问题解决。（第二天，HR：小吴啊，财务室工资结一下）。</p><img data-src="https://static.purewhite.io/uPic/2020-10-14/CjPx3x-image-20201014152156510.png!webp_90" width="30%" style="margin: 0 auto;"/><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>先附上我们用来讲解生成代码的 IDL：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: list&lt;list&lt;<span class="keyword">i64</span>&gt;&gt; data1,</span><br><span class="line">    <span class="number">2</span>: map&lt;<span class="keyword">i64</span>, list&lt;<span class="keyword">byte</span>&gt;&gt; data2,</span><br><span class="line">    <span class="number">3</span>: list&lt;map&lt;<span class="keyword">i64</span>, <span class="keyword">byte</span>&gt;&gt; data3,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Serialize</span> </span>&#123;</span><br><span class="line">    Example Method (<span class="number">1</span>: Example req),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，对比一下新旧生成代码（由于代码较多，就不直接贴在文章中了）。</p><p>旧代码：<a href="https://gist.github.com/PureWhiteWu/bdd28734ab1f675bb7b73ecf0c57e994">https://gist.github.com/PureWhiteWu/bdd28734ab1f675bb7b73ecf0c57e994</a></p><p>新代码：<a href="https://gist.github.com/PureWhiteWu/63ac02ee613695213fe9eac4e22493ba">https://gist.github.com/PureWhiteWu/63ac02ee613695213fe9eac4e22493ba</a></p><p>可以看到，新旧生成代码，在编解码逻辑上是完全等价的！不过旧代码采用了局部变量，新代码是直接用的对应结构体的字段。我们怀疑是不是这里的差异导致的（这可能会导致计算 offset 的开销），于是生成了汇编进行比较（由于汇编较大，不直接贴了，有兴趣的同学建议自行生成一下看一下），发现确实是多了一条 MOVQ 语句用来计算偏移量！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVQ&quot;&quot;.p+144(SP), AX</span><br></pre></td></tr></table></figure><p>看来罪魁祸首好像找到了？不过又感觉哪儿不太对，毕竟现代 CPU 都是有多级流水线的，就多这么一条 MOVQ 语句，对于多级流水线架构的 CPU 来说，性能差距再怎么不可能导致 10% 这么大，特别是尽管这个语句是在 for 循环中的，但是在总的执行的指令占比中也没有 10% 这么多。</p><img data-src="https://static.purewhite.io/uPic/2020-10-14/4lXjbo-image-20201014153941394.png!webp_90" width="30%" style="margin: 0 auto;"/><p>为了验证我们的疑问，我们改了一版生成代码，改为了和原先生成的一样使用临时变量，发现确实去掉了这条语句后，性能没有任何变化。也就是说，性能的问题并不是这个间接寻址导致的。</p><p>随后，根据生成代码的汇编差异，我们提出了许多猜想，花了大量时间进行验证，但是均不是性能变差的原因（此处过于心酸略过不表）。</p><img data-src="https://static.purewhite.io/uPic/2020-10-14/CijHWI-1602576741958_a607b2f22c9eaad1d2fa15f240e3d7f9.png!webp_90" width="30%" style="margin: 0 auto;"/><p>最终，我们定位到了是由于在新的生成代码中，相比旧版本的生成代码，在返回错误的时候会额外包装一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ...; err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> thrift.PrependError(fmt.Sprintf(<span class="string">&quot;%T read field x &#x27;xxx&#x27; error: &quot;</span>, p), err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而旧版本的生成代码是直接返回的错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ...; err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这些只是在发生错误的时候才会调用到，在正常流程中不会用到，但是生成的汇编代码中这段逻辑占了相当大的比例：</p><img data-src="https://static.purewhite.io/uPic/2020-10-14/5xpCC2-1602577065517_13324d0f6a7ef6f60f4eb96f78b4d23d.png!webp_90" width="70%" style="margin: 0 auto;"/><p>而 Go 的编译器并没有帮我们重排这些指令，导致在真正运行的时候，L1 cache miss 大大提高，极大地降低了性能，参考如下实验结果：</p><p><img data-src="https://static.purewhite.io/uPic/2020-10-14/ZuyUfz-image-20201014154039859.png!webp_90" alt="Old"></p><p><img data-src="https://static.purewhite.io/uPic/2020-10-14/GkGorr-image-20201014154055511.png!webp_90" alt="New"></p><p>针对这种编译器太弱智导致的问题，只能上人工智能来解决了——有多少人工就有多少智能。</p><img data-src="https://static.purewhite.io/uPic/2020-10-14/OOtOtc-1602577689777_491ea856ccc372c98bbd3b7b83ecf03f.png!webp_90" width="30%" style="margin: 0 auto;"/><p>既然编译器不会自动做指令重排，那就我们来帮编译器干这事，改造完成后的生成代码见：<a href="https://gist.github.com/PureWhiteWu/296f2bdac6051e4052a68c2bb1de1c07">https://gist.github.com/PureWhiteWu/296f2bdac6051e4052a68c2bb1de1c07</a></p><p>比较关键的方法是，我们在所有原先<code>return thrift.PrependError</code>的地方，都改为了<code>goto XXXError</code>，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Example)</span> <span class="title">Read</span><span class="params">(iprot thrift.TProtocol)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> fieldTypeId thrift.TType</span><br><span class="line"><span class="keyword">var</span> fieldId <span class="keyword">int16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err = iprot.ReadStructBegin(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> ReadStructBeginError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, fieldTypeId, fieldId, err = iprot.ReadFieldBegin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> ReadFieldBeginError</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fieldTypeId == thrift.STOP &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> fieldId &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> fieldTypeId == thrift.LIST &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.ReadField1(iprot); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> ReadFieldError</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := iprot.Skip(fieldTypeId); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> SkipFieldError</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> fieldTypeId == thrift.MAP &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.ReadField2(iprot); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> ReadFieldError</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := iprot.Skip(fieldTypeId); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> SkipFieldError</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">if</span> fieldTypeId == thrift.LIST &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.ReadField3(iprot); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> ReadFieldError</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := iprot.Skip(fieldTypeId); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> SkipFieldError</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> err := iprot.Skip(fieldTypeId); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> SkipFieldError</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := iprot.ReadFieldEnd(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> ReadFieldEndError</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := iprot.ReadStructEnd(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> ReadStructEndError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">ReadStructBeginError:</span><br><span class="line"><span class="keyword">return</span> thrift.PrependError(fmt.Sprintf(<span class="string">&quot;%T read struct begin error: &quot;</span>, p), err)</span><br><span class="line">ReadFieldBeginError:</span><br><span class="line"><span class="keyword">return</span> thrift.PrependError(fmt.Sprintf(<span class="string">&quot;%T read field %d begin error: &quot;</span>, p, fieldId), err)</span><br><span class="line">ReadFieldError:</span><br><span class="line"><span class="keyword">return</span> thrift.PrependError(fmt.Sprintf(<span class="string">&quot;%T read field %d &#x27;%s&#x27; error: &quot;</span>, p, fieldId, fieldIDToName_Example[fieldId]), err)</span><br><span class="line">SkipFieldError:</span><br><span class="line"><span class="keyword">return</span> thrift.PrependError(fmt.Sprintf(<span class="string">&quot;%T field %d skip type %d error: &quot;</span>, p, fieldId, fieldTypeId), err)</span><br><span class="line">ReadFieldEndError:</span><br><span class="line"><span class="keyword">return</span> thrift.PrependError(fmt.Sprintf(<span class="string">&quot;%T read field end error&quot;</span>, p), err)</span><br><span class="line">ReadStructEndError:</span><br><span class="line"><span class="keyword">return</span> thrift.PrependError(fmt.Sprintf(<span class="string">&quot;%T read struct end error: &quot;</span>, p), err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，使得我们正常流程中，如果判断 err 出错的情况之下，不再有之前的一大段处理的指令，而仅仅是变成了一条简单的 jmp 指令；而对应的错误处理逻辑，则尽可能放在正常流程 return 之后，使得尽可能减少 cpu load 指令的次数并降低 L1 icache miss；同时，使得所有的错误处理的逻辑在最终的汇编中只会出现一次，而不是出现多次。</p><p>这里必须吐槽一波，Go 编译器有时候会“贴心”地帮你把这些代码挪回到上面，但是由于只会出现一次而其它错误处理的地方都会直接 jmp，所以问题也不大，后续可以考虑试一下把这些逻辑扔到一个独立的函数中并标记 noinline 是否可以再度提高性能（使得在主流程中完全不出现）。</p><p>经过这个调整，perf 的性能明显好了很多，并且可能比旧版本更优：</p><p><img data-src="https://static.purewhite.io/uPic/2020-10-14/g4d2ua-image-20201014154314334.png!webp_90" alt="Newer"></p><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>至此，这个问题算是搞明白了，在这个过程中，最大的收获是：<del>Go 编译器竟然如此的弱智</del> 人工指令重排竟然能带来如此之大的提升。</p><p>谨以此文分享我们的经验，希望能够抛砖引玉，为性能优化提出一个新的思路，毕竟鲁迅曾说过：</p><img data-src="https://static.purewhite.io/uPic/2020-10-14/gz7Udp-1602579503413_8c994f7473789b1c81ac17040fd9aa1f.png!webp_90" width="40%" style="margin: 0 auto;"/>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;有多少人工就有多少智能。                            ——鲁迅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;p&gt;众所周知，字节跳动内部主要使用 Thrift，为了更好地掌控生成代码，我们用 Go 自己实现了 Thrift 代码生成工具。&lt;/p&gt;
&lt;p&gt;而我们的故(shi)事(gu)，正是由一次重构开始……&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>踩了 Golang sync.Map 的一个坑</title>
    <link href="https://www.purewhite.io/2020/08/24/golang-sync-map-keys-never-delete/"/>
    <id>https://www.purewhite.io/2020/08/24/golang-sync-map-keys-never-delete/</id>
    <published>2020-08-24T08:23:44.000Z</published>
    <updated>2021-12-02T12:51:07.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>最近 Go 1.15 发布了，我也第一时间更新了这个版本，毕竟对 Go 的稳定性还是有一些信心的，于是直接在公司上了生产。</p><p>结果，上线几分钟，就出现了 OOM，于是 pprof 了一下 heap，然后赶紧回滚，发现某块本应该在一次请求结束时被释放的内存，被保留了下来而且一直在增长，如图（图中的 linkBufferNode）：</p><p><img data-src="https://static.purewhite.io/uPic/2020-08-24/52BZcr-image-20200824165148602.png!webp_90" alt="火焰图"></p><p>这次上线的变更只有 Go 版本的升级，没有任何其它变动，于是在本地开始测试，发现在本地也能百分百复现。</p><span id="more"></span><h1 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h1><p>看了 Go 1.15 的 Release Note，发现有俩高度疑似的东西：</p><ol><li>去除了一些 GC Data，使得 binary size 减少了 5%；</li><li>新的内存分配算法。</li></ol><p>于是改 runtime，关闭新的内存分配算法，切换回旧的，等等一顿操作猛如虎下来，发现问题还是没解决，现象仍然存在。</p><img data-src="https://static.purewhite.io/uPic/2020-08-24/1ekDRH-9150e4e5gw1fbh9986ayxj205i058mwz.jpg!webp_50" width="40%" alt="我能怎么办？我也很绝望啊" style="margin: 0 auto;"/><p>于是实在不行，祭出了<code>GODEBUG=&quot;allocfreetrace=1</code>大法，肉眼从100MB+的日志文件里面看啊看啊看啊看啊看啊看啊看啊看啊看啊看啊……（此处省略心酸过程）</p><p>最终直觉告诉我，这个问题可能和 Go 1.15 中 sync.Map 的改动有关（别问我为啥，真的是直觉，我也说不出来）。</p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>为了方便讲解，我写了一个最小可复现的代码，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sm sync.Map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertKeys</span><span class="params">()</span></span> &#123;</span><br><span class="line">keys := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// Store some keys</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">v := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>)</span><br><span class="line">keys = <span class="built_in">append</span>(keys, &amp;v)</span><br><span class="line">sm.Store(keys[i], <span class="keyword">struct</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// delete some keys, but not all keys</span></span><br><span class="line"><span class="keyword">for</span> i, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">sm.Delete(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">sm.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// do something to key</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">insertKeys()</span><br><span class="line"><span class="comment">// do something ...</span></span><br><span class="line">shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Go-1-15-中-sync-Map-改动"><a href="#Go-1-15-中-sync-Map-改动" class="headerlink" title="Go 1.15 中 sync.Map 改动"></a>Go 1.15 中 sync.Map 改动</h1><p>在 Go 1.15 中，sync.Map 增加了一个方法<code>LoadAndDelete</code>，具体的 issue 在这：<a href="https://github.com/golang/go/issues/33762">sync: add new Map method LoadAndDelete</a>，CL 在这：<a href="https://go-review.googlesource.com/c/go/+/205899/">CL</a>。</p><p>为什么我确认是这个改动导致的呢？很简单：我在本地把这个改动 revert 掉了，问题就没了，好了关机下班……</p><img data-src="https://static.purewhite.io/uPic/2020-08-25/KZLLqZ-temp_paste_image_ae4a910733531a94177f37fc7914689c.png!webp_90" width="40%" alt="关机下班" style="margin: 0 auto;"/><p>当然没这么简单，知其然要知其所以然，于是开始看到底改了哪块……（此处省略100000字）</p><p>最终发现，关键代码是这段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadAndDelete deletes the value for a key, returning the previous value if any.</span></span><br><span class="line"><span class="comment">// The loaded result reports whether the key was present.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></span><br><span class="line"><span class="comment">// will take the slow path until the dirty map is promoted to the read</span></span><br><span class="line"><span class="comment">// map.</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，会发现在 Delete 的时候，并没有真正删除掉 key，而是从 key 中取出了 entry，然后把 entry 设为 nil……</p><p>所以，在我们场景中，我们把一个连接作为 key 放了进去，于是和这个连接相关的比如 buffer 的内存就永远无法释放了……</p><p>那么为什么在 Go 1.14 中没有问题呢？以下是 Go 1.14 的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">e.<span class="built_in">delete</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 1.14 中，如果 key 在 dirty 中，是会被删除的；而凑巧，我们其实“误用”了 sync.Map，在我们的使用过程中没有读操作，导致所有的 key 其实都在 dirty 里面，所以当调用 Delete 的时候是会被真正删除的。</p><p>要注意，无论哪个版本的 Go，一旦 key 升级到了 read 中，在没有 miss 到一定的值让 dirty 提升为 read 时，key 都是永远不会被删除的。也就是说，极端情况之下，key 是会泄露的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 Go &lt;= 1.15 版本中，sync.Map 中的 key 在极端情况下是不会被删除的，如果在 Key 中放了一个大的对象，或者关联有内存，就会导致内存泄漏。</p><p>针对这个问题，我已经向 Go 官方提出了<a href="https://github.com/golang/go/issues/40999">Issue</a>，目前来看这个 behaviour 定义为了 bug（因为违背了 Go 1 兼容性承诺，和 1.14 中的 behaviour 不同了），已经由 @ChangKun Ou 大佬提了 pr 修复了，并且 backport 到了 1.15.1 中。</p><p>而针对 read 中的 key 在没有 dirty 被提升时不会删除的问题，目前看来是一个设计上的 trade-off，如果有真实世界中的程序（real-world program）出问题的话，再提 issue，看看是否要解决。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;p&gt;最近 Go 1.15 发布了，我也第一时间更新了这个版本，毕竟对 Go 的稳定性还是有一些信心的，于是直接在公司上了生产。&lt;/p&gt;
&lt;p&gt;结果，上线几分钟，就出现了 OOM，于是 pprof 了一下 heap，然后赶紧回滚，发现某块本应该在一次请求结束时被释放的内存，被保留了下来而且一直在增长，如图（图中的 linkBufferNode）：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://static.purewhite.io/uPic/2020-08-24/52BZcr-image-20200824165148602.png!webp_90&quot; alt=&quot;火焰图&quot;&gt;&lt;/p&gt;
&lt;p&gt;这次上线的变更只有 Go 版本的升级，没有任何其它变动，于是在本地开始测试，发现在本地也能百分百复现。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
    <category term="sync" scheme="https://www.purewhite.io/tags/sync/"/>
    
    <category term="map" scheme="https://www.purewhite.io/tags/map/"/>
    
    <category term="memory leak" scheme="https://www.purewhite.io/tags/memory-leak/"/>
    
  </entry>
  
  <entry>
    <title>为什么 Golang 函数赋值会产生内存分配？</title>
    <link href="https://www.purewhite.io/2020/06/30/golang-indirect-function-allocate/"/>
    <id>https://www.purewhite.io/2020/06/30/golang-indirect-function-allocate/</id>
    <published>2020-06-30T03:05:51.000Z</published>
    <updated>2021-12-02T12:51:07.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>这几天在重构某段代码后，做了一次性能测试，火焰图中发现了一个十分奇怪的<code>runtime.newobject</code>的调用，大致占用2%，而找遍了整段代码都没有发现有新建对象相关的逻辑。于是迫不得已，祭出了汇编大法，终于定位到了问题所在。这篇文章会使用一段最小可复现的代码来分享这个问题以及背后的原因。</p><span id="more"></span><h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myFuncImplStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myFuncImplStruct)</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m myFuncImplStruct)</span> <span class="title">myFunc2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myFuncContainer <span class="keyword">struct</span> &#123;</span><br><span class="line">f MyFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFuncContainer</span><span class="params">(f MyFunc)</span> *<span class="title">myFuncContainer</span></span> &#123;</span><br><span class="line">n := &amp;myFuncContainer&#123;&#125;</span><br><span class="line">n.f = f</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := &amp;myFuncImplStruct&#123;&#125;</span><br><span class="line">m2 := myFuncImplStruct&#123;&#125;</span><br><span class="line">c1 := newFuncContainer(myFunc)</span><br><span class="line">c2 := newFuncContainer(m.myFunc)</span><br><span class="line">c3 := newFuncContainer(m2.myFunc2)</span><br><span class="line"></span><br><span class="line">_, _, _ = c1, c2, c3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，初看起来貌似在 main 函数中（不考虑 newFuncContainer 函数中导致的内存分配）没有运行时内存分配（m 会被优化成全局区，所以不会真的导致运行时内存分配），但是实际上在 main 中是有两次运行时内存分配的，这是怎么回事呢？</p><h2 id="函数还能逃逸到堆上？"><a href="#函数还能逃逸到堆上？" class="headerlink" title="函数还能逃逸到堆上？"></a>函数还能逃逸到堆上？</h2><p>我们用<code>-gcflags=&quot;-m&quot;</code>来打印一下编译器的优化信息，可以看到：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">13</span>:<span class="number">7</span>: m does not escape</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">32</span>:<span class="number">23</span>: leaking param: f</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">33</span>:<span class="number">7</span>: &amp;myFuncContainer literal escapes to heap</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">39</span>:<span class="number">7</span>: &amp;myFuncImplStruct literal escapes to heap</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">42</span>:<span class="number">26</span>: m<span class="selector-class">.myFunc</span> escapes to heap</span><br><span class="line">./<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">43</span>:<span class="number">27</span>: m2<span class="selector-class">.myFunc2</span> escapes to heap</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: <span class="selector-class">.this</span> does not escape</span><br></pre></td></tr></table></figure><p>竟然说 42、43 两行中的<code>m.myFunc</code>和<code>m2.myFunc2</code>“逃逸到了堆上”？一个函数还能逃逸到堆上？？？</p><p><img data-src="https://static.purewhite.io/uPic/2020-06-30/u4KRrc-006Cmetyly1ff16b3zxvxj308408caa8.jpg!webp_90"></p><h2 id="实锤了"><a href="#实锤了" class="headerlink" title="实锤了"></a>实锤了</h2><p>虽然看起来貌似真的是这里导致的，但是我们说话做事要有证据，于是祭出汇编大法（<code>-gcflags=&quot;-S&quot;</code>），看一下生成的汇编代码是啥样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.main STEXT size=160 args=0x0 locals=0x18</span><br><span class="line">……</span><br><span class="line">0x0031 00049 (main.go:42)PCDATA$0, $1</span><br><span class="line">0x0031 00049 (main.go:42)LEAQtype.noalg.struct &#123; F uintptr; R *&quot;&quot;.myFuncImplStruct &#125;(SB), AX</span><br><span class="line">0x0038 00056 (main.go:42)PCDATA$0, $0</span><br><span class="line">0x0038 00056 (main.go:42)MOVQAX, (SP)</span><br><span class="line">0x003c 00060 (main.go:42)CALLruntime.newobject(SB)</span><br><span class="line">0x0041 00065 (main.go:42)PCDATA$0, $1</span><br><span class="line">0x0041 00065 (main.go:42)MOVQ8(SP), AX</span><br><span class="line">0x0046 00070 (main.go:42)LEAQ&quot;&quot;.(*myFuncImplStruct).myFunc-fm(SB), CX</span><br><span class="line">0x004d 00077 (main.go:42)MOVQCX, (AX)</span><br><span class="line">0x0050 00080 (main.go:42)PCDATA$0, $2</span><br><span class="line">0x0050 00080 (main.go:42)LEAQruntime.zerobase(SB), CX</span><br><span class="line">0x0057 00087 (main.go:42)PCDATA$0, $1</span><br><span class="line">0x0057 00087 (main.go:42)MOVQCX, 8(AX)</span><br><span class="line">0x005b 00091 (main.go:42)PCDATA$0, $0</span><br><span class="line">0x005b 00091 (main.go:42)MOVQAX, (SP)</span><br><span class="line">0x005f 00095 (main.go:42)CALL&quot;&quot;.newFuncContainer(SB)</span><br><span class="line">0x0064 00100 (main.go:43)PCDATA$0, $1</span><br><span class="line">0x0064 00100 (main.go:43)LEAQtype.noalg.struct &#123; F uintptr; R &quot;&quot;.myFuncImplStruct &#125;(SB), AX</span><br><span class="line">0x006b 00107 (main.go:43)PCDATA$0, $0</span><br><span class="line">0x006b 00107 (main.go:43)MOVQAX, (SP)</span><br><span class="line">0x006f 00111 (main.go:43)CALLruntime.newobject(SB)</span><br><span class="line">0x0074 00116 (main.go:43)PCDATA$0, $1</span><br><span class="line">0x0074 00116 (main.go:43)MOVQ8(SP), AX</span><br><span class="line">0x0079 00121 (main.go:43)LEAQ&quot;&quot;.myFuncImplStruct.myFunc2-fm(SB), CX</span><br><span class="line">0x0080 00128 (main.go:43)MOVQCX, (AX)</span><br><span class="line">0x0083 00131 (main.go:43)PCDATA$0, $0</span><br><span class="line">0x0083 00131 (main.go:43)MOVQAX, (SP)</span><br><span class="line">0x0087 00135 (main.go:43)CALL&quot;&quot;.newFuncContainer(SB)</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>这下子实锤了，真的是这里导致的，但是为啥呢？我把一个函数赋值给某个变量，为什么会导致一次内存分配呢？函数名不是一个指针，指向函数所在的代码地址么？</p><h2 id="Golang-函数调用机制"><a href="#Golang-函数调用机制" class="headerlink" title="Golang 函数调用机制"></a>Golang 函数调用机制</h2><p>在 Golang 中，函数调用其实并不像 C 那么简单，有一定的分类：</p><h3 id="函数调用分类"><a href="#函数调用分类" class="headerlink" title="函数调用分类"></a>函数调用分类</h3><p>在 Go 中，一共有 4 种类型的函数：</p><ol><li>顶层函数（普通的函数）</li><li>有值接收者的函数</li><li>有指针接收者的函数</li><li>函数字面量</li></ol><p>有 5 种类型的函数调用：</p><ol><li>直接调用顶层函数</li><li>直接调用有值接收者的函数</li><li>直接调用有指针接收者的函数</li><li>间接调用函数值（func value）</li><li>间接调用 interface 中函数</li></ol><p>以下的示例程序展示了所有可能的函数调用方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TopLevel</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pointer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Pointer)</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Value)</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span>&#123; M(<span class="keyword">int</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> literal = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// direct call of top-level func</span></span><br><span class="line">TopLevel(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// direct call of method with value receiver (two spellings, but same)</span></span><br><span class="line"><span class="keyword">var</span> v Value</span><br><span class="line">v.M(<span class="number">1</span>)</span><br><span class="line">Value.M(v, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// direct call of method with pointer receiver (two spellings, but same)</span></span><br><span class="line"><span class="keyword">var</span> p Pointer</span><br><span class="line">(&amp;p).M(<span class="number">1</span>)</span><br><span class="line">(*Pointer).M(&amp;p, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// indirect call of func value (×4)</span></span><br><span class="line">f1 := TopLevel</span><br><span class="line">f1(<span class="number">1</span>)</span><br><span class="line">f2 := Value.M</span><br><span class="line">f2(v, <span class="number">1</span>)</span><br><span class="line">f3 := (*Pointer).M</span><br><span class="line">f3(&amp;p, <span class="number">1</span>)</span><br><span class="line">f4 := literal</span><br><span class="line">f4(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// indirect call of method on interface (×3)</span></span><br><span class="line"><span class="keyword">var</span> i Interface</span><br><span class="line">i = v</span><br><span class="line">i.M(<span class="number">1</span>)</span><br><span class="line">i = &amp;v</span><br><span class="line">i.M(<span class="number">1</span>)</span><br><span class="line">i = &amp;p</span><br><span class="line">i.M(<span class="number">1</span>)</span><br><span class="line">Interface.M(i, <span class="number">1</span>)</span><br><span class="line">Interface.M(v, <span class="number">1</span>)</span><br><span class="line">Interface.M(&amp;p, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上程序所示，一共有 10 种可能的调用组合：</p><ol><li>直接调用顶层函数 / </li><li>直接调用值接收者函数 /</li><li>直接调用指针接收者函数 /</li><li>间接调用函数值（func value） / 函数值为顶层函数</li><li>间接调用函数值 / 函数值为值接收者函数</li><li>间接调用函数值 / 函数值为指针接收者函数</li><li>间接调用函数值 / 函数值函数字面量</li><li>间接调用 interface 中函数 / interface 为值，调用值接收者函数</li><li>间接调用 interface 中函数 / interface 为指针，调用值接收者函数</li><li>间接调用 interface 中函数 / interface 为指针，调用指针接收者函数</li></ol><p>以上列表中，斜杠 / 左侧是在编译时就已知的信息，右侧是在运行时才知道的信息。在编译时生成的代码是不知道运行时的信息的，所以在运行时需要生成一些额外的适配器函数（adapter functions）来达成间接调用。</p><h3 id="函数间接调用实现"><a href="#函数间接调用实现" class="headerlink" title="函数间接调用实现"></a>函数间接调用实现</h3><p>看到这里，大家应该能隐约猜测到原因了，正如你所猜测，在我们开头的程序中，存在着间接调用，Go 分配的这个对象和间接调用脱不了关系。由于直接调用没啥可说的，所以我们略过不谈，只说间接调用。</p><p>在 Go 里面，间接调用的实现如下图：</p><p><img data-src="https://static.purewhite.io/uPic/2020-06-30/LMj4f9-image.png!webp_90"></p><p>实际上，Go 分配了一个额外的对象，其第一个字段是一个指向我们真实函数的指针，第二个对象是与函数强相关的一些数据（对，没错，说的就是接收者 receiver）。于是，一次函数调用实际上会生成类似如下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV …, R0</span><br><span class="line">MOV 0(R0), R1</span><br><span class="line">CALL R1  # called code can access “data” using R0</span><br></pre></td></tr></table></figure><p>有一个例外，就是当一个函数并没有相关数据，如仅仅会捕获外部的局部变量的函数字面量，那么这个函数就不会有相关联的数据，于是内存布局如下：</p><p><img data-src="https://static.purewhite.io/uPic/2020-06-30/dkSyuM-image-20200630183251856.png!webp_90"></p><p>在这个场景下，Go 会将这个变量的分配优化在只读区，不会在每次调用时都进行分配，也就是生成如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV $MyFunc·f(SB), f1</span><br><span class="line"></span><br><span class="line">DATA MyFunc·f(SB)/8, $MyFunc(SB)</span><br><span class="line">GLOBL MyFunc·f(SB), 10, $8</span><br></pre></td></tr></table></figure><p>所以我们其实不必太过担心这种场景下的性能损耗，在这种场景下是 0 损耗的。</p><p>对于非例外的场景，一个适配器函数生成的代码类似下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> funcValue <span class="keyword">struct</span> &#123;</span><br><span class="line">f <span class="keyword">uintptr</span> <span class="comment">// 指向函数的指针</span></span><br><span class="line">r associatedType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里为实际函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcAdapter</span><span class="params">(...)</span> <span class="params">(...)</span></span> &#123;</span><br><span class="line">r := (associatedType)(R0 + <span class="number">8</span>)</span><br><span class="line"><span class="keyword">return</span> r.f(...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := &amp;funcValue&#123;funcAdapter, r&#125;</span><br></pre></td></tr></table></figure><p>在调用时，调用的实际上是适配器函数，适配器函数随后去调用真实的函数。</p><h3 id="为啥要这么干呢？"><a href="#为啥要这么干呢？" class="headerlink" title="为啥要这么干呢？"></a>为啥要这么干呢？</h3><p>其实想想也很简单，对于值接收者和指针接收者函数，调用时第一个参数为 self，那么如果我现在是需要把某个关联在特定值 / 指针上的函数作为一个函数值赋值给某个函数变量时，我也需要一起把对应的值 / 指针信息一起带上，不然等我真正调用的时候，我怎么知道应该调用的是哪个值 / 指针上的方法呢？也就是说，传入函数的 self 值应该是多少呢？</p><h2 id="说了那么多，到底为啥呢？"><a href="#说了那么多，到底为啥呢？" class="headerlink" title="说了那么多，到底为啥呢？"></a>说了那么多，到底为啥呢？</h2><p>回到我们开头的问题，可以看到造成两次内存分配的罪魁祸首已然找到，在汇编代码里面其实也已经能看出端倪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 0x0031 00049 (main.go:42)PCDATA$0, $1</span><br><span class="line">0x0031 00049 (main.go:42)LEAQtype.noalg.struct &#123; F uintptr; R *&quot;&quot;.myFuncImplStruct &#125;(SB), AX</span><br><span class="line">0x0038 00056 (main.go:42)PCDATA$0, $0</span><br><span class="line">0x0038 00056 (main.go:42)MOVQAX, (SP)</span><br><span class="line">0x003c 00060 (main.go:42)CALLruntime.newobject(SB)</span><br><span class="line">0x0041 00065 (main.go:42)PCDATA$0, $1</span><br><span class="line">0x0041 00065 (main.go:42)MOVQ8(SP), AX</span><br><span class="line">0x0046 00070 (main.go:42)LEAQ&quot;&quot;.(*myFuncImplStruct).myFunc-fm(SB), CX</span><br><span class="line">0x004d 00077 (main.go:42)MOVQCX, (AX)</span><br><span class="line">0x0050 00080 (main.go:42)PCDATA$0, $2</span><br><span class="line">0x0050 00080 (main.go:42)LEAQruntime.zerobase(SB), CX</span><br><span class="line">0x0057 00087 (main.go:42)PCDATA$0, $1</span><br><span class="line">0x0057 00087 (main.go:42)MOVQCX, 8(AX)</span><br><span class="line">0x005b 00091 (main.go:42)PCDATA$0, $0</span><br><span class="line">0x005b 00091 (main.go:42)MOVQAX, (SP)</span><br><span class="line">0x005f 00095 (main.go:42)CALL&quot;&quot;.newFuncContainer(SB)</span><br><span class="line">0x0064 00100 (main.go:43)PCDATA$0, $1</span><br><span class="line">0x0064 00100 (main.go:43)LEAQtype.noalg.struct &#123; F uintptr; R &quot;&quot;.myFuncImplStruct &#125;(SB), AX</span><br><span class="line">0x006b 00107 (main.go:43)PCDATA$0, $0</span><br><span class="line">0x006b 00107 (main.go:43)MOVQAX, (SP)</span><br><span class="line">0x006f 00111 (main.go:43)CALLruntime.newobject(SB)</span><br><span class="line">0x0074 00116 (main.go:43)PCDATA$0, $1</span><br><span class="line">0x0074 00116 (main.go:43)MOVQ8(SP), AX</span><br><span class="line">0x0079 00121 (main.go:43)LEAQ&quot;&quot;.myFuncImplStruct.myFunc2-fm(SB), CX</span><br><span class="line">0x0080 00128 (main.go:43)MOVQCX, (AX)</span><br><span class="line">0x0083 00131 (main.go:43)PCDATA$0, $0</span><br><span class="line">0x0083 00131 (main.go:43)MOVQAX, (SP)</span><br><span class="line">0x0087 00135 (main.go:43)CALL&quot;&quot;.newFuncContainer(SB)</span><br></pre></td></tr></table></figure><p>注意上述 <code>LEAQ    type.noalg.struct &#123; F uintptr; R *&quot;&quot;.myFuncImplStruct &#125;(SB), AX</code>这段代码，咱也别管啥意思，反正看到了一个和之前说的适配器很像的一个 struct，这个 struct 有两个字段，第一个是<code>F uintptr</code>，第二个是<code>R *myFuncImplStruct</code>；下面还有一个<code>LEAQ    type.noalg.struct &#123; F uintptr; R &quot;&quot;.myFuncImplStruct &#125;(SB), AX</code>，只不过这里的 R 是<code>myFuncImplStruct</code>的值而不是指针，这正好和我们代码吻合。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这基本上这个问题清楚了，要优化的话也很简单，只要把实际上并不需要有值接收者或者指针接收者的函数改为顶层函数即可，或者尽可能不要将一个值接收者 / 指针接收者函数进行间接调用。</p><p>由此可以看出，有接收者的函数是有代价的，不能乱用啊，代码设计还是要合理，否则是会引入额外的性能开销的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://docs.google.com/document/d/1bMwCey-gmqZVTpRax-ESeVuZGmjwbocYs1iHplK-cjo/pub">https://docs.google.com/document/d/1bMwCey-gmqZVTpRax-ESeVuZGmjwbocYs1iHplK-cjo/pub</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;这几天在重构某段代码后，做了一次性能测试，火焰图中发现了一个十分奇怪的&lt;code&gt;runtime.newobject&lt;/code&gt;的调用，大致占用2%，而找遍了整段代码都没有发现有新建对象相关的逻辑。于是迫不得已，祭出了汇编大法，终于定位到了问题所在。这篇文章会使用一段最小可复现的代码来分享这个问题以及背后的原因。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
    <category term="asm" scheme="https://www.purewhite.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>golang 在 runtime 中的一些骚东西</title>
    <link href="https://www.purewhite.io/2019/11/28/runtime-hacking-translate/"/>
    <id>https://www.purewhite.io/2019/11/28/runtime-hacking-translate/</id>
    <published>2019-11-28T14:00:43.000Z</published>
    <updated>2021-12-02T12:51:07.229Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究性能优化的时候，看到了 golang runtime 包下的一个文档<a href="https://github.com/golang/go/blob/master/src/runtime/HACKING.md"><code>HACKING.md</code></a>觉得颇有意思，读完之后觉得对于 runtime 的理解更上一层，于是想着翻译一下。</p><p>本章内容会有一定深度，需要有一定基础的读者，限于篇幅在这里不可能完全展开各个细节。</p><p>这一篇文档面向的读者是 runtime 的开发者，所以有很多内容在我们普通使用中是接触不到的。</p><span id="more"></span><p>这篇文档是会被经常编辑的，并且随着时间推移目前的内容可能会过时。这篇文档旨在说明写 runtime 代码和普通的 go 代码有什么不同，所以关注于一些普遍的概念而不是一些细节的实现。</p><h1 id="调度器结构"><a href="#调度器结构" class="headerlink" title="调度器结构"></a>调度器结构</h1><p>调度器管理三个在 runtime 中十分重要的类型：<code>G</code>、<code>M</code>和<code>P</code>。哪怕你不写 scheduler 相关代码，你也应当要了解这些概念。</p><h2 id="G、M-和-P"><a href="#G、M-和-P" class="headerlink" title="G、M 和 P"></a>G、M 和 P</h2><p>一个<code>G</code>就是一个 goroutine，在 runtime 中通过类型<code>g</code>来表示。当一个 goroutine 退出时，<code>g</code>对象会被放到一个空闲的<code>g</code>对象池中以用于后续的 goroutine 的使用（译者注：减少内存分配开销）。</p><p>一个<code>M</code>就是一个系统的线程，系统线程可以执行用户的 go 代码、runtime 代码、系统调用或者空闲等待。在 runtime 中通过类型<code>m</code>来表示。在同一时间，可能有任意数量的<code>M</code>，因为任意数量的<code>M</code>可能会阻塞在系统调用中。（译者注：当一个<code>M</code>执行阻塞的系统调用时，会将<code>M</code>和<code>P</code>解绑，并创建出一个新的<code>M</code>来执行<code>P</code>上的其它<code>G</code>。）</p><p>最后，一个<code>P</code>代表了执行用户 go 代码所需要的资源，比如调度器状态、内存分配器状态等。在 runtime 中通过类型<code>p</code>来表示。<code>P</code>的数量精确地（exactly）等于<code>GOMAXPROCS</code>。一个<code>P</code>可以被理解为是操作系统调度器中的 CPU，<code>p</code>类型可以被理解为是每个 CPU 的状态。在这里可以放一些需要高效共享但并不是针对每个<code>P</code>（Per <code>P</code>）或者每个<code>M</code>（Per <code>M</code>）的状态（译者注：意思是，可以放一些以<code>P</code>级别共享的数据）。</p><p>调度器的工作是将一个<code>G</code>（需要执行的代码）、一个<code>M</code>（代码执行的地方）和一个<code>P</code>（代码执行所需要的权限和资源）结合起来。当一个<code>M</code>停止执行用户代码的时候（比如进入阻塞的系统调用的时候），就需要把它的<code>P</code>归还到空闲的<code>P</code>池中；为了继续执行用户的 go 代码（比如从阻塞的系统调用退出的时候），就需要从空闲的<code>P</code>池中获取一个<code>P</code>。</p><p>所有的<code>g</code>、<code>m</code>和<code>p</code>对象都是分配在堆上且永不释放的，所以它们的内存使用是很稳定的。得益于此，runtime 可以在调度器实现中避免写屏障（译者注：垃圾回收时需要的一种屏障，会带来一些性能开销）。</p><h2 id="用户栈和系统栈"><a href="#用户栈和系统栈" class="headerlink" title="用户栈和系统栈"></a>用户栈和系统栈</h2><p>每个存活着的（non-dead）<code>G</code>都会有一个相关联的用户栈，用户的代码就是在这个用户栈上执行的。用户栈一开始很小（比如 2K），并且动态地生长或者收缩。</p><p>每一个<code>M</code>都有一个相关联的系统栈（也被称为<code>g0</code>栈，因为这个栈也是通过<code>g</code>实现的）；如果是在 Unix 平台上，还会有一个 <code>signal</code>栈（也被称为<code>gsignal</code>栈）。系统栈和<code>signal</code>栈不能生长，但是足够大到运行任何 runtime 和 cgo 的代码（在纯 go 二进制中为 8K，在 cgo 情况下由系统分配）。</p><p>runtime 代码经常通过调用<code>systemstack</code>、<code>mcall</code>或者<code>asmcgocall</code>临时性的切换到系统栈去执行一些特殊的任务，比如：不能被抢占的、不应该扩张用户栈的和会切换用户 goroutine 的。在系统栈上运行的代码隐含了不可抢占的含义，同时垃圾回收器不会扫描系统栈。当一个<code>M</code>在系统栈上运行时，当前的用户栈是没有被运行的。</p><h2 id="getg-和getg-m-curg"><a href="#getg-和getg-m-curg" class="headerlink" title="getg()和getg().m.curg"></a><code>getg()</code>和<code>getg().m.curg</code></h2><p>如果想要获取当前用户的<code>g</code>，需要使用<code>getg().m.curg</code>。</p><p><code>getg()</code>虽然会返回当前的<code>g</code>，但是当正在系统栈或者<code>signal</code>栈上执行的时候，会返回的是当前<code>M</code>的<code>g0</code>或者<code>gsignal</code>，而这很可能不是你想要的。</p><p>如果要判断当前正在系统栈上执行还是用户栈上执行，可以使用<code>getg() == getg().m.curg</code>。</p><h1 id="错误处理和上报"><a href="#错误处理和上报" class="headerlink" title="错误处理和上报"></a>错误处理和上报</h1><p>在用户代码中，有一些可以被合理地（reasonably）恢复的错误可以像往常一样使用<code>panic</code>，但是有一些情况下，<code>panic</code>可能导致立即的致命的错误，比如在系统栈中调用或者当执行<code>mallocgc</code>时。</p><p>大部分的 runtime 的错误是不可恢复的，对于这些不可恢复的错误应该使用<code>throw</code>，<code>throw</code>会打印出<code>traceback</code>并立即终止进程。<code>throw</code>应当被传入一个字符串常量以避免在该情况下还需要为 string 分配内存。根据约定，更多的信息应当在<code>throw</code>之前使用<code>print</code>或者<code>println</code>打印出来，并且应当以<code>runtime.</code>开头。</p><p>为了进行 runtime 的错误调试，有一个很实用的方法是设置<code>GOTRACEBACK=system</code> 或 <code>GOTRACEBACK=crash</code>。</p><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>runtime 中有多种同步机制，这些同步机制不仅是语义上不同，和 go 调度器以及操作系统调度器之间的交互也是不一样的。</p><p>最简单的就是<code>mutex</code>，可以使用<code>lock</code>和<code>unlock</code>来操作。这种方法主要用来短期（长期的话性能差）地保护一些共享的数据。在<code>mutex</code>上阻塞会直接阻塞整个<code>M</code>，而不会和 go 的调度器进行交互。因此，在 runtime 中的最底层使用 <code>mutex</code>是安全的，因为它还会阻止相关联的<code>G</code>和<code>P</code>被重新调度（<code>M</code>都阻塞了，无法执行调度了）。<code>rwmutex</code>也是类似的。</p><p>如果是要进行一次性的通知，可以使用<code>note</code>。<code>note</code>提供了<code>notesleep</code>和<code>notewakeup</code>。不像传统的 UNIX 的<code>sleep/wakeup</code>，<code>note</code>是无竞争的（race-free），所以如果<code>notewakeup</code>已经发生了，那么<code>notesleep</code>将会立即返回。<code>note</code>可以在使用后通过<code>noteclear</code>来重置，但是要注意<code>noteclear</code>和<code>notesleep</code>、<code>notewakeup</code>不能发生竞争。类似<code>mutex</code>，阻塞在<code>note</code>上会阻塞整个<code>M</code>。然而，<code>note</code>提供了不同的方式来调用<code>sleep</code>：<code>notesleep</code>会阻止相关联的<code>G</code>和<code>P</code>被重新调度；<code>notetsleepg</code>的表现却像一个阻塞的系统调用一样，允许<code>P</code>被重用去运行另一个<code>G</code>。尽管如此，这仍然比直接阻塞一个<code>G</code>要低效，因为这需要消耗一个<code>M</code>。</p><p>如果需要直接和 go 调度器交互，可以使用<code>gopark</code>和<code>goready</code>。<code>gopark</code>挂起当前的 goroutine——把它变成<code>waiting</code>状态，并从调度器的运行队列中移除——然后调度另一个 goroutine 到当前的<code>M</code>或者<code>P</code>。<code>goready</code>将一个被挂起的 goroutine 恢复到<code>runnable</code>状态并将它放到运行队列中。</p><p>总结起来如下表：</p><table><tbody><tr><th></th><th colspan="3">Blocks</th></tr><tr><th>Interface</th><th>G</th><th>M</th><th>P</th></tr><tr><td>(rw)mutex</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>note</td><td>Y</td><td>Y</td><td>Y/N</td></tr><tr><td>park</td><td>Y</td><td>N</td><td>N</td></tr></tbody></table><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>runtime 使用<code>runtime/internal/atomic</code>中自有的一些原子操作。这个和<code>sync/atomic</code>是对应的，除了方法名由于历史原因有一些区别，并且有一些额外的 runtime 需要的方法。</p><p>总的来说，我们对于 runtime 中 atomic 的使用非常谨慎，并且尽可能避免不需要的原子操作。如果对于一个变量的访问已经被另一种同步机制所保护，那么这个已经被保护的访问一般就不需要是原子的。这么做主要有以下原因：</p><ol><li>合理地使用非原子和原子操作使得代码更加清晰可读，对于一个变量的原子操作意味着在另一处可能会有并发的对于这个变量的操作。</li><li>非原子的操作允许自动的竞争检测。runtime 本身目前并没有一个竞争检测器，但是未来可能会有。原子操作会使得竞争检测器忽视掉这个检测，但是非原子的操作可以通过竞争检测器来验证你的假设（是否会发生竞争）。</li><li>非原子的操作可以提高性能。</li></ol><p>当然，所有对于一个共享变量的非原子的操作都应当在文档中注明该操作是如何被保护的。</p><p>有一些比较普遍的将原子操作和非原子操作混合在一起的场景有：</p><ul><li>大部分操作都是读，且写操作被锁保护的变量。在锁保护的范围内，读操作没必要是原子的，但是写操作必须是原子的。在锁保护的范围外，读操作必须是原子的。</li><li>仅仅在 STW 期间发生的读操作，且 STW 期间不会有写操作。那么这个时候，读操作不需要是原子的。</li></ul><p>话虽如此，<code>Go Memory Model</code>给出的建议仍然成立<code>Don&#39;t be [too] clever</code>。runtime 的性能固然重要，但是鲁棒性（robustness）却更加重要。</p><h1 id="堆外内存（Unmanaged-memory）"><a href="#堆外内存（Unmanaged-memory）" class="headerlink" title="堆外内存（Unmanaged memory）"></a>堆外内存（Unmanaged memory）</h1><p>一般情况下，runtime 会尝试使用普通的方法来申请内存（堆上内存，gc 管理的），然而在某些情况 runtime 必须申请一些不被 gc 所管理的堆外内存（unmanaged memory）。这是很必要的，因为有可能该片内存就是内存管理器自身，或者说调用者没有一个<code>P</code>（译者注：比如在调度器初始化之前，是不存在<code>P</code>的）。</p><p>有三种方式可以申请堆外内存：</p><ul><li><code>sysAlloc</code>直接从操作系统获取内存，申请的内存必须是系统页表长度的整数倍。可以通过<code>sysFree</code>来释放。</li><li><code>persistentalloc</code>将多个小的内存申请合并在一起为一个大的<code>sysAlloc</code>以避免内存碎片（fragmentation）。然而，顾名思义，通过<code>persistentalloc</code>申请的内存是无法被释放的。</li><li><code>fixalloc</code>是一个<a href="https://en.wikipedia.org/wiki/Slab_allocation"><code>SLAB</code></a>风格的内存分配器，分配固定大小的内存。通过<code>fixalloc</code>分配的对象可以被释放，但是内存仅可以被相同的<code>fixalloc</code>池所重用。所以<code>fixalloc</code>适合用于相同类型的对象。</li></ul><p>普遍来说，使用以上三种方法分配内存的类型都应该被标记为<code>//go:notinheap</code>（见后文）。</p><p>在堆外内存所分配的对象<strong>不应该</strong>包含堆上的指针对象，除非同时遵守了以下的规则：</p><ol><li>所有在堆外内存指向堆上的指针都必须是垃圾回收的根（garbage collection roots）。也就是说，所有指针必须可以通过一个全局变量所访问到，或者显式地使用<code>runtime.markroot</code>来标记。</li><li>如果内存被重用了，堆上的指针在被标记为 GC 根并且对 GC 可见前必须 以 0 初始化（zero-initialized，见后文）。不然的话，GC 可能会观察到过期的（stale）堆指针。可以参见下文<code>Zero-initialization versus zeroing</code>.</li></ol><h1 id="Zero-initialization-versus-zeroing"><a href="#Zero-initialization-versus-zeroing" class="headerlink" title="Zero-initialization versus zeroing"></a>Zero-initialization versus zeroing</h1><p>在 runtime 中有两种类型的零初始化，取决于内存是否已经初始化为了一个类型安全的状态。</p><p>如果内存不在一个类型安全的状态，意思是可能由于刚被分配，并且第一次初始化使用，会含有一些垃圾值（译者注：这个概念在日常的 Go 代码中是遇不到的，如果学过 C 语言的同学应该能理解什么意思），那么这片内存必须使用<code>memclrNoHeapPointers</code>进行<code>zero-initialized</code>或者无指针的写。这不会触发写屏障（译者注：写屏障是 GC 中的一个概念）。</p><p>内存可以通过<code>typedmemclr</code>或者<code>memclrHasPointers</code>来写入零值，设置为类型安全的状态。这会触发写屏障。</p><h1 id="Runtime-only-编译指令（compiler-directives）"><a href="#Runtime-only-编译指令（compiler-directives）" class="headerlink" title="Runtime-only 编译指令（compiler directives）"></a>Runtime-only 编译指令（compiler directives）</h1><p>除了<code>go doc compile</code>中注明的<code>//go:</code>编译指令外，编译器在 runtime 包中支持了额外的一些指令。</p><h2 id="go-systemstack"><a href="#go-systemstack" class="headerlink" title="go:systemstack"></a>go:systemstack</h2><p><code>go:systemstack</code>表明一个函数必须在系统栈上运行，这个会通过一个特殊的函数前引（prologue）动态地验证。</p><h2 id="go-nowritebarrier"><a href="#go-nowritebarrier" class="headerlink" title="go:nowritebarrier"></a>go:nowritebarrier</h2><p><code>go:nowritebarrier</code>告知编译器如果以下函数包含了写屏障，触发一个错误（这不会阻止写屏障的生成，只是单纯一个假设）。</p><p>一般情况下你应该使用<code>go:nowritebarrierrec</code>。<code>go:nowritebarrier</code>当且仅当“最好不要”写屏障，但是非正确性必须的情况下使用。</p><h2 id="go-nowritebarrierrec-与-go-yeswritebarrierrec"><a href="#go-nowritebarrierrec-与-go-yeswritebarrierrec" class="headerlink" title="go:nowritebarrierrec 与 go:yeswritebarrierrec"></a>go:nowritebarrierrec 与 go:yeswritebarrierrec</h2><p><code>go:nowritebarrierrec</code>告知编译器如果以下函数以及它调用的函数（递归下去），直到一个<code>go:yeswritebarrierrec</code>为止，包含了一个写屏障的话，触发一个错误。</p><p>逻辑上，编译器会在生成的调用图上从每个<code>go:nowritebarrierrec</code>函数出发，直到遇到了<code>go:yeswritebarrierrec</code>的函数（或者结束）为止。如果其中遇到一个函数包含写屏障，那么就会产生一个错误。</p><p><code>go:nowritebarrierrec</code>主要用来实现写屏障自身，用来避免死循环。</p><p>这两种编译指令都在调度器中所使用。写屏障需要一个活跃的<code>P</code>(<code>getg().m.p != nil</code>)，然而调度器相关代码有可能在没有一个活跃的<code>P</code>的情况下运行。在这种情况下，<code>go:nowritebarrierrec</code>会用在一些释放<code>P</code>或者没有<code>P</code>的函数上运行，<code>go:yeswritebarrierrec</code>会用在重新获取到了<code>P</code>的代码上。因为这些都是函数级别的注释，所以释放<code>P</code>和获取<code>P</code>的代码必须被拆分成两个函数。</p><h2 id="go-notinheap"><a href="#go-notinheap" class="headerlink" title="go:notinheap"></a>go:notinheap</h2><p><code>go:notinheap</code>适用于类型声明，表明了一个类型必须不被分配在 GC 堆上。特别的，指向该类型的指针总是应当在<code>runtime.inheap</code>判断中失败。这个类型可能被用于全局变量、栈上变量，或者堆外内存上的对象（比如通过<code>sysAlloc</code>、<code>persistentalloc</code>、<code>fixalloc</code>或者其它手动管理的<code>span</code>进行分配）。特别的：</p><ol><li><code>new(T)</code>、<code>make([]T)</code>、<code>append([]T, ...)</code>和隐式的对于<code>T</code>的堆上分配是不允许的（尽管隐式的分配在 runtime 中是从来不被允许的）。</li><li>一个指向普通类型的指针（除了<code>unsafe.Pointer</code>）不能被转换成一个指向<code>go:notinheap</code>类型的指针，就算它们有相同的底层类型（underlying type）。</li><li>任何一个包含了<code>go:notinheap</code>类型的类型自身也是<code>go:notinheap</code>的。如果结构体和数组包含<code>go:notinheap</code>的元素，那么它们自身也是<code>go:notinheap</code>类型。map 和 channel 不允许有<code>go:notinheap</code>类型。为了使得事情更加清晰，任何隐式的<code>go:notinheap</code>类型都应该显式地标明<code>go:notinheap</code>。</li><li>指向<code>go:notinheap</code>类型的指针的写屏障可以被忽略。</li></ol><p>最后一点是<code>go:notinheap</code>类型真正的好处。runtime 在底层结构中使用这个来避免调度器和内存分配器的内存屏障以避免非法检查或者单纯提高性能。这种方法是适度的安全（reasonably safe）的并且不会使得 runtime 的可读性降低。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在研究性能优化的时候，看到了 golang runtime 包下的一个文档&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/HACKING.md&quot;&gt;&lt;code&gt;HACKING.md&lt;/code&gt;&lt;/a&gt;觉得颇有意思，读完之后觉得对于 runtime 的理解更上一层，于是想着翻译一下。&lt;/p&gt;
&lt;p&gt;本章内容会有一定深度，需要有一定基础的读者，限于篇幅在这里不可能完全展开各个细节。&lt;/p&gt;
&lt;p&gt;这一篇文档面向的读者是 runtime 的开发者，所以有很多内容在我们普通使用中是接触不到的。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
    <category term="asm" scheme="https://www.purewhite.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>一种基于 gitlab 的适用于版本发布的 git-flow 协作规范</title>
    <link href="https://www.purewhite.io/2019/11/06/new-gitlab-git-flow-spec/"/>
    <id>https://www.purewhite.io/2019/11/06/new-gitlab-git-flow-spec/</id>
    <published>2019-11-06T09:09:25.000Z</published>
    <updated>2021-12-02T12:51:07.229Z</updated>
    
    <content type="html"><![CDATA[<p>最近自己搞了一个基于 gitlab 的适用于版本发布（非持续集成）的脱胎于 git-flow 的协作规范，发布出来大家可以作为借鉴。</p><span id="more"></span><h1 id="Branch-规范"><a href="#Branch-规范" class="headerlink" title="Branch 规范"></a>Branch 规范</h1><p>一共拥有以下几个（种）branch：</p><ol><li>master：master 上的都是 production-ready 的 stable 的代码。</li><li>develop：作为开发的主分支，<u><strong>所有的 mr 都应当（先）合并到 develop 分支</strong></u>，定期 merge 到 master 发版。</li><li>release-*：LTS 版本需要有独立的 branch，以作为后续（万一）hotfix 使用，精确到 minor version，如 release-v1.2，为长期保留的分支。</li><li>feature/*：所有新的 feature（如新功能、性能优化）都应当先 checkout 到一个新的 feature 分支开发，原则上必须且只能 merge 到 develop 分支。</li><li>bugfix/*：bug 的修复分支，原则上必须且只能 merge 到 develop 分支。</li><li>test/*：test 分支主要做以下三件事：1. 增加 unit test；2. 修改仓库级别配置文件（如 .gitlab-ci.yml）；3. 用来承载一些一次性的测试（不合入 develop）。</li><li>hotfix/*：用来发布 hotfix 的分支，详见下节。</li><li>release/*：用来做发版工作（如更新版本号，bugfix）的分支，还有一个作用是 freeze feature，<u><strong>不允许合入 feature，可以合入 bugfix</strong></u>，详见下节。</li></ol><p><u>branch name 应当采用 下划线命名法。</u>会在 ci 中对于 branch name 做强制检查，如果不合规会直接 fail。留出 test/* 的 branch 也是为了能够支持一些测试性的工作能够通过 ci 检查。</p><h1 id="协作流程"><a href="#协作流程" class="headerlink" title="协作流程"></a>协作流程</h1><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><ol><li><p>首先，确认自己在 develop 分支上；</p></li><li><p><code>git checkout -b feature/your_feature</code>；</p></li><li><p>开发完成后，push 到 origin；</p></li><li><p>提 mr（如果是 性能优化，请在 description 中附带上 benchcmp 的结果），target branch 为 develop，并勾选最下方两个选项：</p><p><img data-src="https://static.purewhite.io/images/2019-11-06-092017.png!webp_90" alt="image-20191106172016506"></p></li><li><p>等待 review 通过，通过后点击 merge，请再次确认 squash 和 delete branch 被勾选：</p><p><img data-src="https://static.purewhite.io/images/2019-11-06-092101.png!webp_90" alt="image-20191106172100840"></p></li><li><p>如果 merge request 有 description，可以点击 “Modify commit message” 并点击最下方的 include description，然后再点击 merge：</p><p><img data-src="https://static.purewhite.io/images/2019-11-06-092136.png!webp_90" alt="image-20191106172136296"></p></li><li><p>done。</p></li></ol><h2 id="bugfix-流程"><a href="#bugfix-流程" class="headerlink" title="bugfix 流程"></a>bugfix 流程</h2><h3 id="develop-上-bugfix"><a href="#develop-上-bugfix" class="headerlink" title="develop 上 bugfix"></a>develop 上 bugfix</h3><ol><li>首先，确认自己在 develop 分支上；</li><li><code>git checkout -b bugfix/your_bugfix</code>；</li><li>开发完成后，push 到 origin；</li><li>提 mr，target branch 为 develop，并如<a href="#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B">开发流程</a>一样勾选最下方两个选项；</li><li>等待 review 通过，通过后点击 merge，请再次确认 squash 和 delete branch 被勾选；</li><li>如果 merge request 有 description，可以点击 “Modify commit message” 并点击最下方的 include description，然后再点击 merge；</li><li>done。</li></ol><h3 id="release-上-bugfix"><a href="#release-上-bugfix" class="headerlink" title="release/* 上 bugfix"></a>release/* 上 bugfix</h3><p>这里不需要直接 merge 回 develop 是因为 release/* 最终会 merge 回 develop。</p><ol><li>首先，确认自己在 release/vX.Y.Z 分支上；</li><li><code>git checkout -b bugfix/your_bugfix</code>；</li><li>开发完成后，push 到 origin；</li><li>提 mr，target branch 为 release/vX.Y.Z，并如<a href="#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B">开发流程</a>一样勾选最下方两个选项；</li><li>等待 review 通过，通过后点击 merge，请再次确认 squash 和 delete branch 被勾选；</li><li>如果 merge request 有 description，可以点击 “Modify commit message” 并点击最下方的 include description，然后再点击 merge；</li><li>done。</li></ol><h2 id="hotfix-流程"><a href="#hotfix-流程" class="headerlink" title="hotfix 流程"></a>hotfix 流程</h2><h3 id="需要-merge-到-develop"><a href="#需要-merge-到-develop" class="headerlink" title="需要 merge 到 develop"></a>需要 merge 到 develop</h3><ol><li>按照 <em>普通 bugfix 流程</em> 完成 bug 修复，记得要更新代码中的版本号（为了防止 merge 到 master 后忘记 merge 回 develop）；</li><li>切换到 master 分支上；</li><li><code>git checkout -b hotfix/your_hotfix</code>；</li><li>cherry-pick bugfix 的 commit；</li><li>检查无误后，push 到 origin；</li><li>提 mr，target branch 为 master，并如<a href="#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B">开发流程</a>一样勾选最下方两个选项；</li><li>等待 review 通过，通过后点击 merge，请再次确认 squash 和 delete branch 被勾选；</li><li>如果 merge request 有 description，可以点击 “Modify commit message” 并点击最下方的 include description，然后再点击 merge；</li><li>切换到 master 分支上，打一个新的 tag；</li><li>done。</li></ol><h3 id="仅需要-merge-到-master"><a href="#仅需要-merge-到-master" class="headerlink" title="仅需要 merge 到 master"></a>仅需要 merge 到 master</h3><p>适用于需要修复的 bug 在 develop 分支上已不存在的情况。</p><p>版本号的更新不需要同步到develop，在下次merge的时候解决冲突即可。</p><ol><li>首先，确认自己在 master 分支上；</li><li><code>git checkout -b hotfix/your_hotfix</code>；</li><li>修复完成后，<u><strong>新增一个独立的commit，更新代码中版本号</strong></u>，push 到 origin；</li><li>提 mr，target branch 为 master，并如<a href="#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B">开发流程</a>一样勾选最下方两个选项；</li><li>等待 review 通过，通过后点击 merge，请再次确认 squash 和 delete branch 被勾选；</li><li>如果 merge request 有 description，可以点击 “Modify commit message” 并点击最下方的 include description，然后再点击 merge；</li><li>切换到 master 分支上，打一个新的 tag；</li><li>将第三步中更新版本号的独立的commit cherry-pick到develop分支上；</li><li>done。</li></ol><h3 id="需要-merge-到-LTS-release-branch"><a href="#需要-merge-到-LTS-release-branch" class="headerlink" title="需要 merge 到 LTS release branch"></a>需要 merge 到 LTS release branch</h3><ol><li>根据情况，完成<a href="#%E9%9C%80%E8%A6%81-merge-%E5%88%B0-develop">需要 merge 到 develop</a>或者<a href="#%E4%BB%85%E9%9C%80%E8%A6%81-merge-%E5%88%B0-master">仅需要 merge 到 master</a>中的一个；</li><li>切换到 release-vX.Y 分支上（待修复的分支）；</li><li><code>git checkout -b hotfix/your_hotfix</code>；</li><li>cherry-pick hotfix 的 commit；</li><li>更新代码中版本号，检查无误后，push 到 origin；</li><li>提 mr，target branch 为 release-vX.Y，并如<a href="#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B">开发流程</a>一样勾选最下方两个选项；</li><li>等待 review 通过，通过后点击 merge，请再次确认 squash 和 delete branch 被勾选；</li><li>如果 merge request 有 description，可以点击 “Modify commit message” 并点击最下方的 include description，然后再点击 merge；</li><li>切换到 release-vX.Y 分支上，打一个 tag；</li><li>done。</li></ol><h2 id="发版流程"><a href="#发版流程" class="headerlink" title="发版流程"></a>发版流程</h2><p>发版流程比较特殊，和其它流程有较大区别，请注意细节。</p><p>这么做的原因是，如果先把 release branch merge 到 develop 分支上，再将 develop 分支 merge 进 master 的话，可能会带上预料之外的 commit（在整理 release 的时候有新的 mr 被 merge 到 develop）。</p><ol><li>首先，确认自己在 develop 分支上；</li><li><code>git checkout -b release/vX.Y.Z</code>；</li><li>做一些发版需要的工作（如更新版本号等）；</li><li>完成后，push 到 origin；</li><li>提 mr，target branch 为 master，**<u>不勾选 squash 和 remove source branch</u>**；</li><li>等待 review 通过，通过后点击 merge，<u>请再次确认 squash 和 delete branch <strong>未</strong>被勾选</u>；</li><li>如果 merge request 有 description，可以点击 “Modify commit message” 并点击最下方的 include description，然后再点击 merge；</li><li>切换到 master，打一个 vX.Y.Z 的 tag。</li><li>再提一个 mr，target branch 为 develop，**<u>不勾选 squash，勾选 remove source branch</u>**；</li><li>等待 review 通过，通过后点击 merge，<u>再次确认不勾选 squash，但 delete branch <strong>被</strong>勾选</u>；</li><li>如果 merge request 有 description，可以点击 “Modify commit message” 并点击最下方的 include description，然后再点击 merge；</li><li>done。</li></ol><h1 id="CI-check-script"><a href="#CI-check-script" class="headerlink" title="CI check script"></a>CI check script</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;branch name is: $1&quot;</span><br><span class="line">if [[ ! $1 =~ ^(((feature|bugfix|test|hotfix)/.+)|(master|develop)|(release-v[0-9]+\.[0-9]+)|(release/v[0-9]+\.[0-9]+\.[0-9]+(-[a-z0-9.]+(\+[a-z0-9.]+)?)?))$ ]]; then</span><br><span class="line">  echo &quot;branch name invalid!&quot; &gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近自己搞了一个基于 gitlab 的适用于版本发布（非持续集成）的脱胎于 git-flow 的协作规范，发布出来大家可以作为借鉴。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://www.purewhite.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.purewhite.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="git" scheme="https://www.purewhite.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Thrift相关概念学习笔记</title>
    <link href="https://www.purewhite.io/2019/09/23/thrift-concepts-notes/"/>
    <id>https://www.purewhite.io/2019/09/23/thrift-concepts-notes/</id>
    <published>2019-09-23T06:14:02.000Z</published>
    <updated>2021-12-02T12:51:07.230Z</updated>
    
    <content type="html"><![CDATA[<p>一直在工作中使用 Apache Thrift，但是一直对其中的一些概念一知半解，于是终于抽空学习了一下，记录下来作为学习笔记。</p><span id="more"></span><h2 id="Thrift-网络层级"><a href="#Thrift-网络层级" class="headerlink" title="Thrift 网络层级"></a>Thrift 网络层级</h2><p>简单示意图如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+-------------------------------------------+</span></span><br><span class="line">| Server                                    |</span><br><span class="line"><span class="section">| (single-threaded, event-driven etc)       |</span></span><br><span class="line"><span class="section">+-------------------------------------------+</span></span><br><span class="line">| Processor                                 |</span><br><span class="line"><span class="section">| (compiler generated)                      |</span></span><br><span class="line"><span class="section">+-------------------------------------------+</span></span><br><span class="line">| Protocol                                  |</span><br><span class="line"><span class="section">| (JSON, compact etc)                       |</span></span><br><span class="line"><span class="section">+-------------------------------------------+</span></span><br><span class="line">| Transport                                 |</span><br><span class="line"><span class="section">| (raw TCP, HTTP etc)                       |</span></span><br><span class="line"><span class="section">+-------------------------------------------+</span></span><br></pre></td></tr></table></figure><h2 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h2><p>Transport层提供了一个读写底层网络的简单抽象，这使得Thrift可以把底层的网络传输和其它部分（比如序列化、反序列化）解耦开。</p><p>Transport主要包含以下接口：</p><ul><li>open</li><li>close</li><li>read</li><li>write</li><li>flush</li></ul><p>除了上面这个Transport的接口，Thrift还提供了一个ServerTransport的接口，用来accept或者create上面的Transport对象。顾名思义，ServerTransport主要用在服务端，用来接受连接并创建Transport对象。</p><p>ServerTransport主要包含以下接口：</p><ul><li>open</li><li>listen</li><li>accept</li><li>close</li></ul><p>Thrift主要支持的语言中有的部分接口示例如下：</p><ul><li>file: read/write to/from a file on disk</li><li>http: 顾名思义</li></ul><h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>Protocol层定义了序列化、反序列化的格式和方法，比如json、xml、plain text、compact binary等等。</p><p>Protocol的接口定义如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">write<span class="constructor">MessageBegin(<span class="params">name</span>, <span class="params">type</span>, <span class="params">seq</span>)</span></span><br><span class="line">write<span class="constructor">MessageEnd()</span></span><br><span class="line">write<span class="constructor">StructBegin(<span class="params">name</span>)</span></span><br><span class="line">write<span class="constructor">StructEnd()</span></span><br><span class="line">write<span class="constructor">FieldBegin(<span class="params">name</span>, <span class="params">type</span>, <span class="params">id</span>)</span></span><br><span class="line">write<span class="constructor">FieldEnd()</span></span><br><span class="line">write<span class="constructor">FieldStop()</span></span><br><span class="line">write<span class="constructor">MapBegin(<span class="params">ktype</span>, <span class="params">vtype</span>, <span class="params">size</span>)</span></span><br><span class="line">write<span class="constructor">MapEnd()</span></span><br><span class="line">write<span class="constructor">ListBegin(<span class="params">etype</span>, <span class="params">size</span>)</span></span><br><span class="line">write<span class="constructor">ListEnd()</span></span><br><span class="line">write<span class="constructor">SetBegin(<span class="params">etype</span>, <span class="params">size</span>)</span></span><br><span class="line">write<span class="constructor">SetEnd()</span></span><br><span class="line">write<span class="constructor">Bool(<span class="params">bool</span>)</span></span><br><span class="line">write<span class="constructor">Byte(<span class="params">byte</span>)</span></span><br><span class="line">write<span class="constructor">I16(<span class="params">i16</span>)</span></span><br><span class="line">write<span class="constructor">I32(<span class="params">i32</span>)</span></span><br><span class="line">write<span class="constructor">I64(<span class="params">i64</span>)</span></span><br><span class="line">write<span class="constructor">Double(<span class="params">double</span>)</span></span><br><span class="line">write<span class="constructor">String(<span class="params">string</span>)</span></span><br><span class="line"></span><br><span class="line">name, <span class="keyword">type</span>, seq = read<span class="constructor">MessageBegin()</span></span><br><span class="line">                  read<span class="constructor">MessageEnd()</span></span><br><span class="line">name = read<span class="constructor">StructBegin()</span></span><br><span class="line">       read<span class="constructor">StructEnd()</span></span><br><span class="line">name, <span class="keyword">type</span>, id = read<span class="constructor">FieldBegin()</span></span><br><span class="line">                 read<span class="constructor">FieldEnd()</span></span><br><span class="line">k, v, size = read<span class="constructor">MapBegin()</span></span><br><span class="line">             read<span class="constructor">MapEnd()</span></span><br><span class="line">etype, size = read<span class="constructor">ListBegin()</span></span><br><span class="line">              read<span class="constructor">ListEnd()</span></span><br><span class="line">etype, size = read<span class="constructor">SetBegin()</span></span><br><span class="line">              read<span class="constructor">SetEnd()</span></span><br><span class="line"><span class="built_in">bool</span> = read<span class="constructor">Bool()</span></span><br><span class="line">byte = read<span class="constructor">Byte()</span></span><br><span class="line">i16 = read<span class="constructor">I16()</span></span><br><span class="line">i32 = read<span class="constructor">I32()</span></span><br><span class="line">i64 = read<span class="constructor">I64()</span></span><br><span class="line">double = read<span class="constructor">Double()</span></span><br><span class="line"><span class="built_in">string</span> = read<span class="constructor">String()</span></span><br></pre></td></tr></table></figure><p>Thrift Protocol在设计上就是以流为目标的，所以不需要任何显式的帧。比如，当我们在序列化一个string之前，我们不需要知道它有多长；同样的，当我们序列化一个list之前，不需要知道里面有几个item。部分Thrift主要支持语言所常用的Protocol如下：</p><ul><li>binary: 非常简单的二进制编码，先编码长度和类型，然后编码真实的值。</li><li>compact: 参考<a href="https://issues.apache.org/jira/browse/THRIFT-110">THRIFT-110</a></li><li>json</li></ul><h2 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h2><p>Processor提供了从输入流读取数据以及写出到输出流的能力，输入和输出流都是由Protocol层实现，Processor本身很简单：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="symbol">TProcessor</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> process(TProtocol <span class="keyword">in</span>, TProtocol <span class="keyword">out</span>) throws TException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个服务的Processor都是由compiler生成的，Processor从输入流读取数据，扔给用户的handler处理，再把response写回输出流。</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>Server把上述所有的特性组合在一起：</p><ul><li>创建一个Transport</li><li>根据Transport创建输入输出流（Protocol）</li><li>基于输入输出流创建Processor</li><li>等待并处理连接</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直在工作中使用 Apache Thrift，但是一直对其中的一些概念一知半解，于是终于抽空学习了一下，记录下来作为学习笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.purewhite.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="随笔" scheme="https://www.purewhite.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="开源" scheme="https://www.purewhite.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>验证golang中unsafe包不安全</title>
    <link href="https://www.purewhite.io/2019/04/02/golang-validate-unsafe-is-unsafe/"/>
    <id>https://www.purewhite.io/2019/04/02/golang-validate-unsafe-is-unsafe/</id>
    <published>2019-04-02T05:32:28.000Z</published>
    <updated>2021-12-02T12:51:07.226Z</updated>
    
    <content type="html"><![CDATA[<p>在go中，uintptr不能持有对象，unsafe包不安全，但是我之前一直没有时间验证，今天写了段代码验证了一下。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := f()</span><br><span class="line">b := f2()</span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">d := <span class="number">1</span></span><br><span class="line">p := unsafe.Pointer(&amp;d)</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">d := <span class="number">1</span></span><br><span class="line">p := <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;d))</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>根据逃逸分析可以看出来f和f2这两个函数中的d变量分别分配在哪里：</p><h3 id="编译参数方法"><a href="#编译参数方法" class="headerlink" title="编译参数方法"></a>编译参数方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build -gcflags <span class="string">&#x27;-m -m&#x27;</span> unsafe.go</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> command-line-arguments</span></span><br><span class="line">./unsafe.go:16:6: cannot inline f: marked go:noinline</span><br><span class="line">./unsafe.go:23:6: cannot inline f2: marked go:noinline</span><br><span class="line">./unsafe.go:8:6: cannot inline main: function too complex: cost 260 exceeds budget 80</span><br><span class="line">./unsafe.go:11:13: inlining call to fmt.Println func(...interface &#123;&#125;) (int, error) &#123; return fmt.Fprintln(io.Writer(os.Stdout), fmt.a...) &#125;</span><br><span class="line">./unsafe.go:12:13: inlining call to fmt.Println func(...interface &#123;&#125;) (int, error) &#123; return fmt.Fprintln(io.Writer(os.Stdout), fmt.a...) &#125;</span><br><span class="line">./unsafe.go:18:22: &amp;d escapes to heap</span><br><span class="line">./unsafe.go:18:22: from p (assigned) at ./unsafe.go:18:4</span><br><span class="line">./unsafe.go:18:22: from ~r0 (return) at ./unsafe.go:19:2</span><br><span class="line">./unsafe.go:17:2: moved to heap: d</span><br><span class="line">./unsafe.go:25:30: f2 &amp;d does not escape</span><br><span class="line">./unsafe.go:11:13: a escapes to heap</span><br><span class="line">./unsafe.go:11:13: from ~arg0 (assign-pair) at ./unsafe.go:11:13</span><br><span class="line">./unsafe.go:11:13: io.Writer(os.Stdout) escapes to heap</span><br><span class="line">./unsafe.go:11:13: from io.Writer(os.Stdout) (passed to call[argument escapes]) at ./unsafe.go:11:13</span><br><span class="line">./unsafe.go:12:13: io.Writer(os.Stdout) escapes to heap</span><br><span class="line">./unsafe.go:12:13: from io.Writer(os.Stdout) (passed to call[argument escapes]) at ./unsafe.go:12:13</span><br><span class="line">./unsafe.go:12:13: b escapes to heap</span><br><span class="line">./unsafe.go:12:13: from ~arg0 (assign-pair) at ./unsafe.go:12:13</span><br><span class="line">./unsafe.go:12:13: from []interface &#123;&#125; literal (slice-literal-element) at ./unsafe.go:12:13</span><br><span class="line">./unsafe.go:12:13: from fmt.a (assigned) at ./unsafe.go:12:13</span><br><span class="line">./unsafe.go:12:13: from *fmt.a (indirection) at ./unsafe.go:12:13</span><br><span class="line">./unsafe.go:12:13: from fmt.a (passed to call[argument content escapes]) at ./unsafe.go:12:13</span><br><span class="line">./unsafe.go:11:13: main []interface &#123;&#125; literal does not escape</span><br><span class="line">./unsafe.go:12:13: main []interface &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:1: os.(*File).close .this does not escape</span><br></pre></td></tr></table></figure><p>可以看出来在函数f中，d逃逸到堆上；但是在函数f2中，d没有发生逃逸，uintptr没有持有对象。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>再来看看汇编的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ go tool compile -S unsafe.go | grep unsafe.go:24</span><br><span class="line">0x000e 00014 (unsafe.go:24)PCDATA$2, $0</span><br><span class="line">0x000e 00014 (unsafe.go:24)PCDATA$0, $0</span><br><span class="line">0x000e 00014 (unsafe.go:24)MOVQ$1, &quot;&quot;.d(SP)</span><br><span class="line">$ go tool compile -S unsafe.go | grep unsafe.go:17</span><br><span class="line">0x001d 00029 (unsafe.go:17)PCDATA$2, $1</span><br><span class="line">0x001d 00029 (unsafe.go:17)PCDATA$0, $0</span><br><span class="line">0x001d 00029 (unsafe.go:17)LEAQtype.int(SB), AX</span><br><span class="line">0x0024 00036 (unsafe.go:17)PCDATA$2, $0</span><br><span class="line">0x0024 00036 (unsafe.go:17)MOVQAX, (SP)</span><br><span class="line">0x0028 00040 (unsafe.go:17)CALLruntime.newobject(SB)</span><br><span class="line">0x002d 00045 (unsafe.go:17)PCDATA$2, $1</span><br><span class="line">0x002d 00045 (unsafe.go:17)MOVQ8(SP), AX</span><br><span class="line">0x0032 00050 (unsafe.go:17)MOVQ$1, (AX)</span><br></pre></td></tr></table></figure><p>可以看出来，结果也是一样的，f中的d调用了newobject，但是f2中没有。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以为什么说unsafe包不安全呢，原因之一就是因为go不保证地址一定是有效的，当然还有其它的原因，有时间再验证分享。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在go中，uintptr不能持有对象，unsafe包不安全，但是我之前一直没有时间验证，今天写了段代码验证了一下。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
    <category term="asm" scheme="https://www.purewhite.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>golang 的 GC 如何处理 unsafe.Pointer？</title>
    <link href="https://www.purewhite.io/2019/04/01/golang-gc-consider-unsafe/"/>
    <id>https://www.purewhite.io/2019/04/01/golang-gc-consider-unsafe/</id>
    <published>2019-04-01T12:42:37.000Z</published>
    <updated>2021-12-02T12:51:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>最近在golang的邮件列表中看到了一篇关于GC如何处理<code>unsafe.Pointer</code>的讨论，觉得应当记录一下。</p><span id="more"></span><hr><p>问题1：如果一个对象只被<code>unsafe.Pointer</code>所指向，那么这个对象会被回收么？</p><p>回答1：不会。如果<code>unsafe.Pointer</code>指向了一个对象，那么go的GC会知道有这个对象，并且不会释放这个对象的内存。</p><p>但是注意，有一个例外：如果这个对象的内存是在go外被分配的（比如<code>C.malloc</code>），那么以上的规则不生效。</p><hr><p>问题2：如果这个对象内部也有一些指针，那么GC会如何处理这些指针？</p><p>回答2：如果这个对象是在go内部分配的，那么GC也会遍历这些指针（也就是不会被释放）。</p><hr><p>问题3：如果在以上两个问题中，对象都不会被释放，那么GC是怎么处理的？<code>unsafe.Pointer</code>会存对象的类型信息么？</p><p>回答3：不会存类型信息，但是如果对象是在go中申请的，那么在对应的内存中是会存有类型信息的；如果没有类型信息，那么GC会采用非常保守的策略：遍历整个对象，只要其中有8bit的值是合法的内存地址（在栈范围内，或者在堆上），就认为是指针，不会进行回收。</p><hr><p>问题4：有没有一种情况<code>unsafe.Pointer</code>会变成非法的（野指针）？</p><p>回答4：在go中，只要<code>unsafe.Pointer</code>有一刻是合法的，并且它的值没有修改，那么go会保证它在整个程序的生命周期中都是合法的。在<code>unsafe.Pointer</code>和<code>unsafe.Pointer</code>间的赋值一定是安全的，但是间接的赋值（比如同过uintptr）可能是非法的，因为uintptr不被认为持有了对象。</p><hr><p>go会忽视所有非go分配的对象（比如C.malloc），所以如果在C中有一个指针指向的地址包含了go的对象，那么必须保证这个指针在go中也被一个对象存储下来。</p><p><a href="https://groups.google.com/d/msg/golang-nuts/yNis7bQG_rY/yaJFoSx1hgIJ">原文</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在golang的邮件列表中看到了一篇关于GC如何处理&lt;code&gt;unsafe.Pointer&lt;/code&gt;的讨论，觉得应当记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>源码剖析golang中sync.Mutex</title>
    <link href="https://www.purewhite.io/2019/03/28/golang-mutex-source/"/>
    <id>https://www.purewhite.io/2019/03/28/golang-mutex-source/</id>
    <published>2019-03-28T13:01:18.000Z</published>
    <updated>2021-12-02T12:51:07.226Z</updated>
    
    <content type="html"><![CDATA[<p>go语言以并发作为其特性之一，并发必然会带来对于资源的竞争，这时候我们就需要使用go提供的<code>sync.Mutex</code>这把互斥锁来保证临界资源的访问互斥。</p><p>既然经常会用这把锁，那么了解一下其内部实现，就能了解这把锁适用什么场景，特性如何了。</p><span id="more"></span><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在看<code>sync.Mutex</code>的代码的时候，一定要记住，同时会有多个goroutine会来要这把锁，所以锁的状态<code>state</code>是可能会一直更改的。</p><h2 id="锁的性质"><a href="#锁的性质" class="headerlink" title="锁的性质"></a>锁的性质</h2><p>先说结论：<code>sync.Mutex</code>是把公平锁。</p><p>在源代码中，有一段注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutex fairness.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Mutex can be in 2 modes of operations: normal and starvation.</span></span><br><span class="line"><span class="comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span></span><br><span class="line"><span class="comment">// does not own the mutex and competes with new arriving goroutines over</span></span><br><span class="line"><span class="comment">// the ownership. New arriving goroutines have an advantage -- they are</span></span><br><span class="line"><span class="comment">// already running on CPU and there can be lots of them, so a woken up</span></span><br><span class="line"><span class="comment">// waiter has good chances of losing. In such case it is queued at front</span></span><br><span class="line"><span class="comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span></span><br><span class="line"><span class="comment">// it switches mutex to the starvation mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In starvation mode ownership of the mutex is directly handed off from</span></span><br><span class="line"><span class="comment">// the unlocking goroutine to the waiter at the front of the queue.</span></span><br><span class="line"><span class="comment">// New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span></span><br><span class="line"><span class="comment">// to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span></span><br><span class="line"><span class="comment">// the tail of the wait queue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If a waiter receives ownership of the mutex and sees that either</span></span><br><span class="line"><span class="comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span></span><br><span class="line"><span class="comment">// it switches mutex back to normal operation mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Normal mode has considerably better performance as a goroutine can acquire</span></span><br><span class="line"><span class="comment">// a mutex several times in a row even if there are blocked waiters.</span></span><br><span class="line"><span class="comment">// Starvation mode is important to prevent pathological cases of tail latency.</span></span><br></pre></td></tr></table></figure><p>看懂这段注释对于我们理解mutex这把锁有很大的帮助，这里面讲了这把锁的设计理念。大致意思如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 锁有两种模式：正常模式和饥饿模式。</span></span><br><span class="line"><span class="comment">// 在正常模式下，所有的等待锁的goroutine都会存在一个先进先出的队列中（轮流被唤醒）</span></span><br><span class="line"><span class="comment">// 但是一个被唤醒的goroutine并不是直接获得锁，而是仍然需要和那些新请求锁的（new arrivial）</span></span><br><span class="line"><span class="comment">// 的goroutine竞争，而这其实是不公平的，因为新请求锁的goroutine有一个优势——它们正在CPU上</span></span><br><span class="line"><span class="comment">// 运行，并且数量可能会很多。所以一个被唤醒的goroutine拿到锁的概率是很小的。在这种情况下，</span></span><br><span class="line"><span class="comment">// 这个被唤醒的goroutine会加入到队列的头部。如果一个等待的goroutine有超过1ms（写死在代码中）</span></span><br><span class="line"><span class="comment">// 都没获取到锁，那么就会把锁转变为饥饿模式。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在饥饿模式中，锁的所有权会直接从释放锁(unlock)的goroutine转交给队列头的goroutine，</span></span><br><span class="line"><span class="comment">// 新请求锁的goroutine就算锁是空闲状态也不会去获取锁，并且也不会尝试自旋。它们只是排到队列的尾部。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果一个goroutine获取到了锁之后，它会判断以下两种情况：</span></span><br><span class="line"><span class="comment">// 1. 它是队列中最后一个goroutine；</span></span><br><span class="line"><span class="comment">// 2. 它拿到锁所花的时间小于1ms；</span></span><br><span class="line"><span class="comment">// 以上只要有一个成立，它就会把锁转变回正常模式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常模式会有比较好的性能，因为即使有很多阻塞的等待锁的goroutine，</span></span><br><span class="line"><span class="comment">// 一个goroutine也可以尝试请求多次锁。</span></span><br><span class="line"><span class="comment">// 饥饿模式对于防止尾部延迟来说非常的重要。</span></span><br></pre></td></tr></table></figure><p>在下一步真正看源代码之前，我们必须要理解一点：当一个goroutine获取到锁的时候，有可能没有竞争者，也有可能会有很多竞争者，那么我们就需要站在不同的goroutine的角度上去考虑goroutine看到的锁的状态和实际状态、期望状态之间的转化。</p><h2 id="字段定义"><a href="#字段定义" class="headerlink" title="字段定义"></a>字段定义</h2><p><code>sync.Mutex</code>只包含两个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="keyword">int32</span></span><br><span class="line">sema<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">mutexWoken</span><br><span class="line">mutexStarving</span><br><span class="line">mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中<code>state</code>是一个表示锁的状态的字段，这个字段会同时被多个goroutine所共用（使用atomic.CAS来保证原子性），第0个bit（1）表示锁已被获取，也就是已加锁，被某个goroutine拥有；第1个bit（2）表示有goroutine被唤醒，尝试获取锁；第2个bit（4）标记这把锁是否为饥饿状态。</p><p><code>sema</code>字段就是用来唤醒goroutine所用的信号量。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>在看代码之前，我们需要有一个概念：每个goroutine也有自己的状态，存在局部变量里面（也就是函数栈里面），goroutine有可能是新到的、被唤醒的、正常的、饥饿的。</p><h3 id="atomic-CAS"><a href="#atomic-CAS" class="headerlink" title="atomic.CAS"></a>atomic.CAS</h3><p>先看一下最基础的一行代码加锁的CAS操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock locks m.</span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">// blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是第一段代码，这段代码调用了<code>atomic</code>包中的<code>CompareAndSwapInt32</code>这个方法来尝试快速获取锁，这个方法的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure><p>意思是，如果addr指向的地址中存的值和old一样，那么就把addr中的值改为new并返回true；否则什么都不做，返回false。由于是<code>atomic</code>中的函数，所以是保证了原子性的。</p><p>我们来具体看看CAS的实现（<code>src/runtime/internal/atomic/asm_amd64.s</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// bool Cas(int32 *val, int32 old, int32 new)</span><br><span class="line">// Atomically:</span><br><span class="line">//if(*val == old)&#123;</span><br><span class="line">//*val = new;</span><br><span class="line">//return 1;</span><br><span class="line">//&#125; else</span><br><span class="line">//return 0;</span><br><span class="line">// 这里参数及返回值大小加起来是17，是因为一个指针在amd64下是8字节，</span><br><span class="line">// 然后int32分别是占用4字节，最后的返回值是bool占用1字节，所以加起来是17</span><br><span class="line">TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$0-17 </span><br><span class="line">// 为什么不把*val指针放到AX中呢？因为AX有特殊用处，</span><br><span class="line">// 在下面的CMPXCHGL里面，会从AX中读取要比较的其中一个数</span><br><span class="line">MOVQptr+0(FP), BX</span><br><span class="line">// 所以AX要用来存参数old</span><br><span class="line">MOVLold+8(FP), AX</span><br><span class="line">// 把new中的数存到寄存器CX中</span><br><span class="line">MOVLnew+12(FP), CX</span><br><span class="line">// 注意这里了，这里使用了LOCK前缀，所以保证操作是原子的</span><br><span class="line">LOCK</span><br><span class="line">// 0(BX) 可以理解为 *val</span><br><span class="line">// 把 AX中的数 和 第二个操作数 0(BX)——也就是BX寄存器所指向的地址中存的值 进行比较</span><br><span class="line">// 如果相等，就把 第一个操作数 CX寄存器中存的值 赋给 第二个操作数 BX寄存器所指向的地址</span><br><span class="line">// 并将标志寄存器ZF设为1</span><br><span class="line">// 否则将标志寄存器ZF清零</span><br><span class="line">CMPXCHGLCX, 0(BX)</span><br><span class="line">// SETE的作用是：</span><br><span class="line">// 如果Zero Flag标志寄存器为1，那么就把操作数设为1</span><br><span class="line">// 否则把操作数设为0</span><br><span class="line">// 也就是说，如果上面的比较相等了，就返回true，否则为false</span><br><span class="line">// ret+16(FP)代表了返回值的地址</span><br><span class="line">SETEQret+16(FP)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>如果看不懂也没太大关系，只要知道这个函数的作用，以及这个函数是原子性的即可。</p><p>那么这段代码的意思就是：先看看这把锁是不是空闲状态，如果是的话，直接原子性地修改一下<code>state</code>为已被获取就行了。多么简洁（虽然后面的代码并不是……）！</p><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>接下来具体看主流程的代码，代码中有一些位运算看起来比较晕，我会试着用伪代码在边上注释。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock locks m.</span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">// blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存当前goroutine等待的时间</span></span><br><span class="line"><span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line"><span class="comment">// 用来存当前goroutine是否饥饿</span></span><br><span class="line">starving := <span class="literal">false</span></span><br><span class="line"><span class="comment">// 用来存当前goroutine是否已唤醒</span></span><br><span class="line">awoke := <span class="literal">false</span></span><br><span class="line"><span class="comment">// 用来存当前goroutine的循环次数(想一想一个goroutine如果循环了2147483648次咋办……)</span></span><br><span class="line">iter := <span class="number">0</span></span><br><span class="line"><span class="comment">// 复制一下当前锁的状态</span></span><br><span class="line">old := m.state</span><br><span class="line"><span class="comment">// 自旋</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 如果是饥饿情况之下，就不要自旋了，因为锁会直接交给队列头部的goroutine</span></span><br><span class="line"><span class="comment">// 如果锁是被获取状态，并且满足自旋条件（canSpin见后文分析），那么就自旋等锁</span></span><br><span class="line"><span class="comment">// 伪代码：if isLocked() and isNotStarving() and canSpin()</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line"><span class="comment">// 将自己的状态以及锁的状态设置为唤醒，这样当Unlock的时候就不会去唤醒其它被阻塞的goroutine了</span></span><br><span class="line"><span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进行自旋(分析见后文)</span></span><br><span class="line">runtime_doSpin()</span><br><span class="line">iter++</span><br><span class="line"><span class="comment">// 更新锁的状态(有可能在自旋的这段时间之内锁的状态已经被其它goroutine改变)</span></span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当走到这一步的时候，可能会有以下的情况：</span></span><br><span class="line"><span class="comment">// 1. 锁被获取+饥饿</span></span><br><span class="line"><span class="comment">// 2. 锁被获取+正常</span></span><br><span class="line"><span class="comment">// 3. 锁空闲+饥饿</span></span><br><span class="line"><span class="comment">// 4. 锁空闲+正常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine的状态可能是唤醒以及非唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制一份当前的状态，目的是根据当前状态设置出期望的状态，存在new里面，</span></span><br><span class="line"><span class="comment">// 并且通过CAS来比较以及更新锁的状态</span></span><br><span class="line"><span class="comment">// old用来存锁的当前状态</span></span><br><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果说锁不是饥饿状态，就把期望状态设置为被获取(获取锁)</span></span><br><span class="line"><span class="comment">// 也就是说，如果是饥饿状态，就不要把期望状态设置为被获取</span></span><br><span class="line"><span class="comment">// 新到的goroutine乖乖排队去</span></span><br><span class="line"><span class="comment">// 伪代码：if isNotStarving()</span></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 伪代码：newState = locked</span></span><br><span class="line"><span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果锁是被获取状态，或者饥饿状态</span></span><br><span class="line"><span class="comment">// 就把期望状态中的等待队列的等待者数量+1(实际上是new + 8)</span></span><br><span class="line"><span class="comment">// (会不会可能有三亿个goroutine等待拿锁……)</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果说当前的goroutine是饥饿状态，并且锁被其它goroutine获取</span></span><br><span class="line"><span class="comment">// 那么将期望的锁的状态设置为饥饿状态</span></span><br><span class="line"><span class="comment">// 如果锁是释放状态，那么就不用切换了</span></span><br><span class="line"><span class="comment">// Unlock期望一个饥饿的锁会有一些等待拿锁的goroutine，而不只是一个</span></span><br><span class="line"><span class="comment">// 这种情况下不会成立</span></span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 期望状态设置为饥饿状态</span></span><br><span class="line"><span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果说当前goroutine是被唤醒状态，我们需要reset这个状态</span></span><br><span class="line"><span class="comment">// 因为goroutine要么是拿到锁了，要么是进入sleep了</span></span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line"><span class="comment">// 如果说期望状态不是woken状态，那么肯定出问题了</span></span><br><span class="line"><span class="comment">// 这里看不懂没关系，wake的逻辑在下面</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这句就是把new设置为非唤醒状态</span></span><br><span class="line"><span class="comment">// &amp;^的意思是and not</span></span><br><span class="line"><span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过CAS来尝试设置锁的状态</span></span><br><span class="line"><span class="comment">// 这里可能是设置锁，也有可能是只设置为饥饿状态和等待数量</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line"><span class="comment">// 如果说old状态不是饥饿状态也不是被获取状态</span></span><br><span class="line"><span class="comment">// 那么代表当前goroutine已经通过CAS成功获取了锁</span></span><br><span class="line"><span class="comment">// (能进入这个代码块表示状态已改变，也就是说状态是从空闲到被获取)</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果之前已经等待过了，那么就要放到队列头</span></span><br><span class="line">queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line"><span class="comment">// 如果说之前没有等待过，就初始化设置现在的等待时间</span></span><br><span class="line"><span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">waitStartTime = runtime_nanotime()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 既然获取锁失败了，就使用sleep原语来阻塞当前goroutine</span></span><br><span class="line"><span class="comment">// 通过信号量来排队获取锁</span></span><br><span class="line"><span class="comment">// 如果是新来的goroutine，就放到队列尾部</span></span><br><span class="line"><span class="comment">// 如果是被唤醒的等待锁的goroutine，就放到队列头部</span></span><br><span class="line">runtime_SemacquireMutex(&amp;m.sema, queueLifo)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里sleep完了，被唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前goroutine已经是饥饿状态了</span></span><br><span class="line"><span class="comment">// 或者当前goroutine已经等待了1ms（在上面定义常量）以上</span></span><br><span class="line"><span class="comment">// 就把当前goroutine的状态设置为饥饿</span></span><br><span class="line">starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line"><span class="comment">// 再次获取一下锁现在的状态</span></span><br><span class="line">old = m.state</span><br><span class="line"><span class="comment">// 如果说锁现在是饥饿状态，就代表现在锁是被释放的状态，当前goroutine是被信号量所唤醒的</span></span><br><span class="line"><span class="comment">// 也就是说，锁被直接交给了当前goroutine</span></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果说当前锁的状态是被唤醒状态或者被获取状态，或者说等待的队列为空</span></span><br><span class="line"><span class="comment">// 那么是不可能的，肯定是出问题了，因为当前状态肯定应该有等待的队列，锁也一定是被释放状态且未唤醒</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前的goroutine获得了锁，那么就把等待队列-1</span></span><br><span class="line">delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"><span class="comment">// 如果当前goroutine非饥饿状态，或者说当前goroutine是队列中最后一个goroutine</span></span><br><span class="line"><span class="comment">// 那么就退出饥饿模式，把状态设置为正常</span></span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Exit starvation mode.</span></span><br><span class="line"><span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line"><span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line"><span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line"><span class="comment">// to starvation mode.</span></span><br><span class="line">delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子性地加上改动的状态</span></span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果锁不是饥饿模式，就把当前的goroutine设为被唤醒</span></span><br><span class="line"><span class="comment">// 并且重置iter(重置spin)</span></span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果CAS不成功，也就是说没能成功获得锁，锁被别的goroutine获得了或者锁一直没被释放</span></span><br><span class="line"><span class="comment">// 那么就更新状态，重新开始循环尝试拿锁</span></span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为什么CAS能拿到锁呢？因为CAS会原子性地判断<code>old state</code>和当前锁的状态是否一致；而总有一个goroutine会满足以上条件成功拿锁。</p><h3 id="canSpin"><a href="#canSpin" class="headerlink" title="canSpin"></a>canSpin</h3><p>接下来我们来看看上文提到的<code>canSpin</code>条件如何：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Active spinning for sync.Mutex.</span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_canSpin sync.runtime_canSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里的active_spin是个常量，值为4</span></span><br><span class="line"><span class="comment">// 简单来说，sync.Mutex是有可能被多个goroutine竞争的，所以不应该大量自旋(消耗CPU)</span></span><br><span class="line"><span class="comment">// 自旋的条件如下：</span></span><br><span class="line"><span class="comment">// 1. 自旋次数小于active_spin(这里是4)次；</span></span><br><span class="line"><span class="comment">// 2. 在多核机器上；</span></span><br><span class="line"><span class="comment">// 3. GOMAXPROCS &gt; 1并且至少有一个其它的处于运行状态的P；</span></span><br><span class="line"><span class="comment">// 4. 当前P没有其它等待运行的G；</span></span><br><span class="line"><span class="comment">// 满足以上四个条件才可以进行自旋。</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="keyword">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以看出来，并不是一直无限自旋下去的，当自旋次数到达4次或者其它条件不符合的时候，就改为信号量拿锁了。</p><h3 id="doSpin"><a href="#doSpin" class="headerlink" title="doSpin"></a>doSpin</h3><p>然后我们来看看<code>doSpin</code>的实现（其实也没啥好看的）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname sync_runtime_doSpin sync.runtime_doSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个汇编实现的函数，简单看两眼amd64上的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$0-0</span><br><span class="line">MOVLcycles+0(FP), AX</span><br><span class="line">again:</span><br><span class="line">PAUSE</span><br><span class="line">SUBL$1, AX</span><br><span class="line">JNZagain</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>看起来没啥好看的，直接跳过吧。</p><h2 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h2><p>接下来我们来看看Unlock的实现，对于Unlock来说，有两个比较关键的特性：</p><ol><li>如果说锁不是处于locked状态，那么对锁执行Unlock会导致panic；</li><li>锁和goroutine没有对应关系，所以我们完全可以在goroutine 1中获取到锁，然后在goroutine 2中调用Unlock来释放锁（这是什么骚操作！）（虽然不推荐大家这么干……）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = m.state</span><br><span class="line">race.Release(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line"><span class="comment">// 这里获取到锁的状态，然后将状态减去被获取的状态(也就是解锁)，称为new(期望)状态</span></span><br><span class="line"><span class="comment">// 注意以上两个操作是原子的，所以不用担心多个goroutine并发的问题</span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line"><span class="comment">// 如果说，期望状态加上被获取的状态，不是被获取的话</span></span><br><span class="line"><span class="comment">// 那么就panic</span></span><br><span class="line"><span class="comment">// 在这里给大家提一个问题：干嘛要这么大费周章先减去再加上，直接比较一下原来锁的状态是否被获取不就完事了？</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果说new状态(也就是锁的状态)不是饥饿状态</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 复制一下原先状态</span></span><br><span class="line">old := <span class="built_in">new</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 如果说锁没有等待拿锁的goroutine</span></span><br><span class="line"><span class="comment">// 或者锁被获取了(在循环的过程中被其它goroutine获取了)</span></span><br><span class="line"><span class="comment">// 或者锁是被唤醒状态(表示有goroutine被唤醒，不需要再去尝试唤醒其它goroutine)</span></span><br><span class="line"><span class="comment">// 或者锁是饥饿模式(会直接转交给队列头的goroutine)</span></span><br><span class="line"><span class="comment">// 那么就直接返回，啥都不用做了</span></span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 走到这一步的时候，说明锁目前还是空闲状态，并且没有goroutine被唤醒且队列中有goroutine等待拿锁</span></span><br><span class="line"><span class="comment">// 那么我们就要把锁的状态设置为被唤醒，等待队列-1</span></span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line"><span class="comment">// 又是熟悉的CAS</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line"><span class="comment">// 如果状态设置成功了，我们就通过信号量去唤醒goroutine</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环结束的时候，更新一下状态，因为有可能在执行的过程中，状态被修改了(比如被Lock改为了饥饿状态)</span></span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果是饥饿状态下，那么我们就直接把锁的所有权通过信号量移交给队列头的goroutine就好了</span></span><br><span class="line"><span class="comment">// handoff = true表示直接把锁交给队列头部的goroutine</span></span><br><span class="line"><span class="comment">// 注意：在这个时候，锁被获取的状态没有被设置，会由被唤醒的goroutine在唤醒后设置</span></span><br><span class="line"><span class="comment">// 但是当锁处于饥饿状态的时候，我们也认为锁是被获取的(因为我们手动指定了获取的goroutine)</span></span><br><span class="line"><span class="comment">// 所以说新来的goroutine不会尝试去获取锁(在Lock中有体现)</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据以上代码的分析，可以看出，<code>sync.Mutex</code>这把锁在你的工作负载（所需时间）比较低，比如只是对某个关键变量赋值的时候，性能还是比较好的，但是如果说对于临界资源的操作耗时很长（特别是单个操作就大于1ms）的话，实际上性能上会有一定的问题，这也就是我们经常看到“的锁一直处于饥饿状态”的问题，对于这种情况，可能就需要另寻他法了。</p><p>好了，至此整个<code>sync.Mutex</code>的分析就此结束了，虽然只有短短200行代码（包括150行注释，实际代码估计就50行），但是其中的算法、设计的思想、编程的理念却是值得感悟，所谓大道至简、少即是多可能就是如此吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;go语言以并发作为其特性之一，并发必然会带来对于资源的竞争，这时候我们就需要使用go提供的&lt;code&gt;sync.Mutex&lt;/code&gt;这把互斥锁来保证临界资源的访问互斥。&lt;/p&gt;
&lt;p&gt;既然经常会用这把锁，那么了解一下其内部实现，就能了解这把锁适用什么场景，特性如何了。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
    <category term="asm" scheme="https://www.purewhite.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>golang逃逸分析</title>
    <link href="https://www.purewhite.io/2019/03/25/golang-escape-check/"/>
    <id>https://www.purewhite.io/2019/03/25/golang-escape-check/</id>
    <published>2019-03-24T16:22:51.000Z</published>
    <updated>2021-12-02T12:51:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>带GC语言给我们程序的编写带来了极大的便利，但是与此同时屏蔽了很多底层的细节，比如一个对象是在栈上分配还是在堆上分配。对于普通的代码来说虽然不需要关心这么多，但是作为强迫症程序猿，还是希望能让自己写出来的代码性能最优，所以还是需要了解什么是逃逸，以及如何判断是否发生了逃逸。</p><span id="more"></span><h2 id="什么是堆和栈？"><a href="#什么是堆和栈？" class="headerlink" title="什么是堆和栈？"></a>什么是堆和栈？</h2><p>首先需要知道，我们说的堆和栈是啥。这个可不是数据结构里面的”堆”和”栈”，而是操作系统里面的概念。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>在程序中，每个函数块都会有自己的内存区域用来存自己的局部变量（内存占用少）、返回地址、返回值之类的数据，这一块内存区域有特定的结构和寻址方式，大小在编译时已经确定，寻址起来也十分迅速，开销很少。这一块内存地址称为栈。栈是线程级别的，大小在创建的时候已经确定，所以当数据太大的时候，就会发生”stack overflow”。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>在程序中，全局变量、内存占用大的局部变量、发生了逃逸的局部变量存在的地方就是堆，这一块内存没有特定的结构，也没有固定的大小，可以根据需要进行调整。简单来说，有大量数据要存的时候，就存在堆里面。堆是进程级别的。当一个变量需要分配在堆上的时候，开销会比较大，对于go这种带GC的语言来说，也会增加gc压力，同时也容易造成内存碎片。</p><h2 id="为什么有的变量要分配在堆，有的要分配在栈？"><a href="#为什么有的变量要分配在堆，有的要分配在栈？" class="headerlink" title="为什么有的变量要分配在堆，有的要分配在栈？"></a>为什么有的变量要分配在堆，有的要分配在栈？</h2><p>这个问题要从C++说起了。在C++中，假设我们有以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="built_in">f1</span>();</span><br><span class="line">  *i = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候程序结果是无法预期的，因为在函数f1中，i是一个局部变量，会分配在栈上，而栈在函数返回之后就失效了(Plan9 汇编中SP指针被修改)，于是i的地址所存的值是不可预期的，后续在main中对返回的i的地址中的值的修改可能会修改掉程序运行的数据，造成结果无法预期。</p><p>所以对于需要返回一个地址回去的情况，在C++中需要用new来分配一块堆上的内存才行，因为堆是进程级别的，也就是全局的，除非程序猿手动释放，否则不会被回收（释放不好会段错误，忘了释放会内存泄漏），于是就可以使得这个地址不会再被使用到，可以安全地返回。</p><h2 id="如何进行逃逸分析？"><a href="#如何进行逃逸分析？" class="headerlink" title="如何进行逃逸分析？"></a>如何进行逃逸分析？</h2><p>在golang中，所有内存都是由runtime管理的，程序猿不需要关心具体变量分配在哪里，什么时候回收，但是编译器需要知道这一点，这样才能确定函数栈帧大小、哪些变量需要”new”在堆上，所以编译器需要进行<code>逃逸分析</code>。简单来说，<code>逃逸分析</code>决定了一个变量是分配在栈上还是分配在堆上。</p><p>golang逃逸分析最基本的原则是：<code>如果一个函数返回的是一个（局部）变量的地址，那么这个变量就发生逃逸</code>。</p><p>在golang里面，变量分配在何处和是否使用new无关，意味着程序猿无法手动指定某个变量必须分配在栈上或者堆上(自己撸asm的当我没说)，所以我们需要通过一些方法来确定某个变量到底是分配在了栈上还是堆上。</p><p>我们用以下代码作为例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := f1()</span><br><span class="line">*a++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，给f1增加了noinline标记，让go编译器不要将函数内联。</p><h3 id="使用编译参数"><a href="#使用编译参数" class="headerlink" title="使用编译参数"></a>使用编译参数</h3><p>golang提供了编译的参数让我们可以直观地看到变量是否发生了逃逸，只需要在go build时指定 <code>-gcflags &#39;-m&#39;</code>即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build -gcflags <span class="string">&#x27;-m&#x27;</span> escape.go</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> command-line-arguments</span></span><br><span class="line">./escape.go:3:6: can inline main</span><br><span class="line">./escape.go:11:9: &amp;i escapes to heap</span><br><span class="line">./escape.go:10:2: moved to heap: i</span><br></pre></td></tr></table></figure><p>这样可以很直观地看到在第10、11行，i发生了逃逸，内存会分配在堆上。</p><p>除了使用编译参数之外，我们还可以使用一种更底层的，更硬核，也更准确的方式来判断一个对象是否逃逸，那就是：直接看汇编！</p><h3 id="使用汇编"><a href="#使用汇编" class="headerlink" title="使用汇编"></a>使用汇编</h3><p>我们使用<code>go tool compile -S</code>生成汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go tool compile -S escape.go | grep escape.go:10</span><br><span class="line">0x001d 00029 (escape.go:10)PCDATA$2, $1</span><br><span class="line">0x001d 00029 (escape.go:10)PCDATA$0, $0</span><br><span class="line">0x001d 00029 (escape.go:10)LEAQtype.int(SB), AX</span><br><span class="line">0x0024 00036 (escape.go:10)PCDATA$2, $0</span><br><span class="line">0x0024 00036 (escape.go:10)MOVQAX, (SP)</span><br><span class="line">0x0028 00040 (escape.go:10)CALLruntime.newobject(SB)</span><br><span class="line">0x002d 00045 (escape.go:10)PCDATA$2, $1</span><br><span class="line">0x002d 00045 (escape.go:10)MOVQ8(SP), AX</span><br><span class="line">0x0032 00050 (escape.go:10)MOVQ$1, (AX)</span><br></pre></td></tr></table></figure><p>可以看到，这里的00040有调用<code>runtime.newobject(SB)</code>这个方法，看到这个方法大家就应该懂了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上提供了两种方法可以用来判断某个变量是否发生了逃逸，其中使用编译参数比较简单，使用汇编比较硬核。通过这两种方法分析完逃逸，就能进一步优化堆上内存数量，减轻GC压力了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;带GC语言给我们程序的编写带来了极大的便利，但是与此同时屏蔽了很多底层的细节，比如一个对象是在栈上分配还是在堆上分配。对于普通的代码来说虽然不需要关心这么多，但是作为强迫症程序猿，还是希望能让自己写出来的代码性能最优，所以还是需要了解什么是逃逸，以及如何判断是否发生了逃逸。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
    <category term="asm" scheme="https://www.purewhite.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>算法详解：最长上升子序列</title>
    <link href="https://www.purewhite.io/2018/07/25/lis/"/>
    <id>https://www.purewhite.io/2018/07/25/lis/</id>
    <published>2018-07-24T16:46:52.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个长度为n的数列<code>a0, a1, a2...an-1</code>，求出这个序列中的最长的上升子序列的长度，上升子序列的定义为：对于任意的<code>i&lt;j</code>，都满足<code>ai&lt;aj</code>。</p><span id="more"></span><p><strong>限制条件：</strong>1≤n≤1000，0≤a≤1000000</p><p><strong>样例：</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = 5</span><br><span class="line">a = &#123;4, 2, 3, 1, 5&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">3</span>（a<span class="number">1</span>, a<span class="number">2</span>, a<span class="number">4</span>构成的子序列<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>最长）</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这个问题就是著名的最长上升子序列（LIS，Longest  Increasing Subsequence）问题，这个问题有两种解法，第一种解法是O(n²)的DP解法，第二种解法是O(nlogn)的DP加二分解法。</p><h2 id="O-n²-算法"><a href="#O-n²-算法" class="headerlink" title="O(n²)算法"></a>O(n²)算法</h2><p>首先我们可以来建立一下DP的递推关系：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义dp<span class="selector-attr">[i]</span>:=以ai为末尾的最长上升子序列的长度</span><br></pre></td></tr></table></figure><p>以ai结尾的上升子序列是：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只包含ai的子序列</span><br><span class="line">在满足j&lt;i并且<span class="built_in">aj</span>&lt;ai的以<span class="built_in">aj</span>为结尾的上升子列末尾，追加上ai后得到的子序列</span><br></pre></td></tr></table></figure><p>这二者之一。这样就能得到如下的递推关系：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dp</span>[i]=<span class="built_in">max</span>&#123;<span class="number">1</span>, <span class="keyword">dp</span>[<span class="keyword">j</span>]+<span class="number">1</span>|<span class="keyword">j</span>&lt;i且aj&lt;ai&#125;</span><br></pre></td></tr></table></figure><p>使用这个递推公式可以在O(n²)时间内解决这个问题。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，但是时间复杂度也比较高。下面我们来看看更优的解法。</p><h2 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h2><p>之前我们的思路是求出以第i个元素为结尾的最长上升子序列长度，我们可以换个思路，考虑一下<code>dp[i]</code>为<code>最长上升子序列长度为i情况下最小的元素</code>，这样我们就可以通过二分来进行优化，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dp, dp+n, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        *<span class="built_in">lower_bound</span>(dp, dp + n, a[i]) = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lower_bound</span>(dp, dp + n, INF) - dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个长度为n的数列&lt;code&gt;a0, a1, a2...an-1&lt;/code&gt;，求出这个序列中的最长的上升子序列的长度，上升子序列的定义为：对于任意的&lt;code&gt;i&amp;lt;j&lt;/code&gt;，都满足&lt;code&gt;ai&amp;lt;aj&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.purewhite.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.purewhite.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://www.purewhite.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 428. x的n次幂</title>
    <link href="https://www.purewhite.io/2018/07/11/lintcode-powx-n/"/>
    <id>https://www.purewhite.io/2018/07/11/lintcode-powx-n/</id>
    <published>2018-07-11T08:43:16.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>实现 pow(x,n)</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>不用担心精度，当答案和标准输出差绝对值小于<code>1e-3</code>时都算正确</p><span id="more"></span><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Pow</span>(<span class="number">2</span>.<span class="number">1</span>, <span class="number">3</span>) = <span class="number">9</span>.<span class="number">261</span></span><br><span class="line"><span class="attribute">Pow</span>(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">0</span></span><br><span class="line"><span class="attribute">Pow</span>(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>从数学上来说，<code>(x)的4次方</code> 等于 <code>(x的平方)的平方</code>。我们使用这个思想来做这道题就行了。</p><p>其实就和把十进制数转成二进制的思想是一样的。</p><p>需要注意的地方是，n可能为负数。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: x: the base number</span></span><br><span class="line"><span class="string">    @param: n: the power number</span></span><br><span class="line"><span class="string">    @return: the result</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        t = x</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            t = <span class="number">1</span> / t</span><br><span class="line">            n = -n</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                ans *= t</span><br><span class="line">            t *= t</span><br><span class="line">            n = <span class="built_in">int</span>(n / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;实现 pow(x,n)&lt;/p&gt;
&lt;h5 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h5&gt;&lt;p&gt;不用担心精度，当答案和标准输出差绝对值小于&lt;code&gt;1e-3&lt;/code&gt;时都算正确&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.purewhite.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.purewhite.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LintCode" scheme="https://www.purewhite.io/tags/LintCode/"/>
    
    <category term="数据结构" scheme="https://www.purewhite.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 460.在排序数组中找最接近的K个数</title>
    <link href="https://www.purewhite.io/2018/07/11/lintcode-find-k-closest-elements/"/>
    <id>https://www.purewhite.io/2018/07/11/lintcode-find-k-closest-elements/</id>
    <published>2018-07-11T08:15:34.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个目标数 target, 一个非负整数 <code>k</code>, 一个按照升序排列的数组 A。在A中找与target最接近的k个整数。返回这k个数并按照与target的接近程度从小到大排序，如果接近程度相当，那么小的数排在前面。</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>The value k is a non-negative integer and will always be smaller than the length of the sorted array.</p><p>Length of the given array is positive and will not exceed 10^4</p><p>Absolute value of elements in the array and x will not exceed 10^4</p><span id="more"></span><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>如果 A = <code>[1, 2, 3]</code>, target = <code>2</code> and k = <code>3</code>, 那么返回 <code>[2, 1, 3]</code>.</p><p>如果 A = <code>[1, 4, 6, 8]</code>, target = <code>3</code> and k = <code>3</code>, 那么返回 <code>[4, 1, 6]</code>.</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题的一般解法都很容易想出来，暴力出奇迹嘛，这里我们只说最优解，也就是 O(logn + k) 的时间复杂度 的解法。</p><p>这道题的解题关键是数组A是有序的，只要有序就可以考虑用二分。</p><p>我们通过对A进行二分，找到最接近target的数，找到之后用双指针的思想，依次从找到的那个数向两边扩散，直到满足k个数为止。</p><p>思路较为简单，编码过程注意一些边界条件的判断即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param A: an integer array</span></span><br><span class="line"><span class="string">    @param target: An integer</span></span><br><span class="line"><span class="string">    @param k: An integer</span></span><br><span class="line"><span class="string">    @return: an integer array</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosestNumbers</span>(<span class="params">self, A, target, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        lp = <span class="literal">None</span></span><br><span class="line">        rp = <span class="literal">None</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = <span class="built_in">int</span>(start + (end - start) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> A[mid] == target:</span><br><span class="line">                start = mid</span><br><span class="line">                end = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> A[mid] &lt; target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(A[start] - target) &lt;= <span class="built_in">abs</span>(A[start] - target):</span><br><span class="line">            lp = start</span><br><span class="line">            rp = end</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lp = end</span><br><span class="line">            rp = end + <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> cnt &lt; k:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lp &lt; <span class="number">0</span> <span class="keyword">and</span> rp &gt;= <span class="built_in">len</span>(A):</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">elif</span> lp &lt; <span class="number">0</span>:</span><br><span class="line">                ans.append(A[rp])</span><br><span class="line">                rp += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> rp &gt;= <span class="built_in">len</span>(A):</span><br><span class="line">                ans.append(A[lp])</span><br><span class="line">                lp -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(A[lp] - target) &lt;= <span class="built_in">abs</span>(A[rp] - target):</span><br><span class="line">                ans.append(A[lp])</span><br><span class="line">                lp -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(A[rp])</span><br><span class="line">                rp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给一个目标数 target, 一个非负整数 &lt;code&gt;k&lt;/code&gt;, 一个按照升序排列的数组 A。在A中找与target最接近的k个整数。返回这k个数并按照与target的接近程度从小到大排序，如果接近程度相当，那么小的数排在前面。&lt;/p&gt;
&lt;h5 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h5&gt;&lt;p&gt;The value k is a non-negative integer and will always be smaller than the length of the sorted array.&lt;/p&gt;
&lt;p&gt;Length of the given array is positive and will not exceed 10^4&lt;/p&gt;
&lt;p&gt;Absolute value of elements in the array and x will not exceed 10^4&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.purewhite.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.purewhite.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LintCode" scheme="https://www.purewhite.io/tags/LintCode/"/>
    
    <category term="数据结构" scheme="https://www.purewhite.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Service Mesh Istio 初探</title>
    <link href="https://www.purewhite.io/2018/06/27/service-mesh-0/"/>
    <id>https://www.purewhite.io/2018/06/27/service-mesh-0/</id>
    <published>2018-06-27T03:41:13.000Z</published>
    <updated>2021-12-02T12:51:07.230Z</updated>
    
    <content type="html"><![CDATA[<p>早在去年，Service Mesh这个概念就开始火起来了，今年的时候Service Mesh更是爆发式地发展，Service Mesh中的明星项目Istio更是只用了几个月的时间就已经从0.1到了0.8 LTS了。由于工作和毕业的压力，之前一直没有时间深入研究Service Mesh。现在稍微有些时间了，所以打算写点什么关于Service Mesh的。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>首先，我们需要了解一下什么是Service Mesh。今天我们的主角是Istio，Istio的背景我不过多介绍，G家等大厂搞出来并且在后面推动支持的肯定不会弱。</p><p>根据Istio的官方文档，是这么定义自己的：一个用来连接、管理和加密微服务（流量）的开放平台。</p><blockquote><p>an open platform to connect, manage, and secure microservices</p></blockquote><p>Istio可以让你在不修改微服务源代码的情况之下，很轻松地给微服务加上诸如负载均衡、身份验证、监控等等的功能。Istio通过在你的微服务中部署一个sidecar作为所有流量的代理来达成这个目标。</p><p>总结下来，Istio提供了以下功能：</p><ul><li>流量管理（Traffic Management）</li><li>服务的身份认证和安全（Service Identity and Security）</li><li>策略配置（Policy Enforcement）</li><li>遥感（Telemetry）</li></ul><p>除了这些之外，Istio还支持很多不同的平台（尤其是Kubernetes），并且支持自定义的组件和集成。</p><p>通过这些功能，微服务的开发和迁移会变得非常容易，而运维人员也可以更方便的更改部署的策略。</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Istio是两层架构的，分别是<strong>数据层</strong>和<strong>控制层</strong>：</p><ul><li>数据层是由所有的部署为sidecar的Envoy所组成的。</li><li>控制层有三个组件：Pilot、Mixer和Citadel，顾名思义是用来控制Service Mesh的行为的。</li></ul><p>总体的架构如下图：</p><p><img data-src="https://istio.io/docs/concepts/what-is-istio/img/overview/arch.svg" alt="Istio Architecture"></p><h2 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h2><p>Istio用了一个扩展版本的Envoy作为底层的代理。Envoy是一个用C++开发的高性能的代理，具有非常多功能，具体的可以参考官方文档，在此不做赘述。</p><p>Envoy在Istio中是以sidecar模式部署在pod里面的，Istio通过控制Envoy来控制所有的流量，获取监控数据等。</p><h2 id="Mixer"><a href="#Mixer" class="headerlink" title="Mixer"></a>Mixer</h2><p>Mixer是一个平台无关的组件，用来控制访问策略和使用策略，同时会收集监控信息，将收集到的信息传给用户可以自定义的后端进行处理。</p><h2 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h2><p>Pilot为Envoy提供服务发现、智能路由（如AB测试、金丝雀部署）和弹性流量管理功能（如超时、重试、熔断）。它负责将高层的抽象的路由规则转化成低级的envoy的配置。</p><h2 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h2><p>Citadel提供了服务间和服务到终端用户的认证，同时可以直接将http流量升级成https流量。具体的可以查看官方文档。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在这里我打算使用helm进行安装。</p><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><p>首先，你得有一个可运行的k8s集群，我是在gke上开了一个三节点的集群作为测试使用。</p><p>其次，你得需要有helm的客户端。mac用户可以通过brew来安装。</p><h2 id="下载release"><a href="#下载release" class="headerlink" title="下载release"></a>下载release</h2><p>Istio提供了一个很方便的脚本来下载并解压最新版的Istio，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L https://git.io/getLatestIstio | sh -</span></span><br></pre></td></tr></table></figure><p>等下载完之后，我们可以进入文件夹，并把bin目录加到path里面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> istio-0.8.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PWD</span>/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><h2 id="使用helm进行安装"><a href="#使用helm进行安装" class="headerlink" title="使用helm进行安装"></a>使用helm进行安装</h2><p>要使用helm来安装istio，首先需要在集群里面配置好helm和tiller，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f install/kubernetes/helm/helm-service-account.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> helm init --service-account tiller</span></span><br></pre></td></tr></table></figure><p>等helm和tiller配置完之后，就可以使用helm来一键安装Istio了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> helm install install/kubernetes/helm/istio --name istio --namespace istio-system</span></span><br></pre></td></tr></table></figure><p>这样，Istio就安装好了。</p><p>为了验证安装是否成功，我们可以看一下是否部署了以下的service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc -n istio-system</span></span><br><span class="line">NAME                       TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                                                               AGE</span><br><span class="line">istio-citadel              ClusterIP      10.19.247.33    &lt;none&gt;            8060/TCP,9093/TCP                                                     2m</span><br><span class="line">istio-egressgateway        ClusterIP      10.19.244.143   &lt;none&gt;            80/TCP,443/TCP                                                        2m</span><br><span class="line">istio-ingress              LoadBalancer   10.19.248.42    104.199.155.220   80:32000/TCP,443:30434/TCP                                            2m</span><br><span class="line">istio-ingressgateway       LoadBalancer   10.19.254.155   35.229.183.83     80:31380/TCP,443:31390/TCP,31400:31400/TCP                            2m</span><br><span class="line">istio-pilot                ClusterIP      10.19.252.30    &lt;none&gt;            15003/TCP,15005/TCP,15007/TCP,15010/TCP,15011/TCP,8080/TCP,9093/TCP   2m</span><br><span class="line">istio-policy               ClusterIP      10.19.242.187   &lt;none&gt;            9091/TCP,15004/TCP,9093/TCP                                           2m</span><br><span class="line">istio-sidecar-injector     ClusterIP      10.19.252.155   &lt;none&gt;            443/TCP                                                               2m</span><br><span class="line">istio-statsd-prom-bridge   ClusterIP      10.19.246.99    &lt;none&gt;            9102/TCP,9125/UDP                                                     2m</span><br><span class="line">istio-telemetry            ClusterIP      10.19.240.18    &lt;none&gt;            9091/TCP,15004/TCP,9093/TCP,42422/TCP                                 2m</span><br><span class="line">prometheus                 ClusterIP      10.19.255.53    &lt;none&gt;            9090/TCP                                                              2m</span><br></pre></td></tr></table></figure><p>并且确认以下的Pod是否在running状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -n istio-system</span></span><br><span class="line">NAME                                       READY     STATUS      RESTARTS   AGE</span><br><span class="line">istio-citadel-7bdc7775c7-ntfkf             1/1       Running     0          3m</span><br><span class="line">istio-egressgateway-795fc9b47-2hw69        1/1       Running     0          3m</span><br><span class="line">istio-ingress-84659cf44c-dkgf4             1/1       Running     0          3m</span><br><span class="line">istio-ingressgateway-7d89dbf85f-9kgth      1/1       Running     0          3m</span><br><span class="line">istio-mixer-post-install-vg5gh             0/1       Completed   0          3m</span><br><span class="line">istio-pilot-66f4dd866c-nwr2j               2/2       Running     0          3m</span><br><span class="line">istio-policy-76c8896799-7l9nz              2/2       Running     0          3m</span><br><span class="line">istio-sidecar-injector-645c89bc64-6rs5k    1/1       Running     0          3m</span><br><span class="line">istio-statsd-prom-bridge-949999c4c-mpk6d   1/1       Running     0          3m</span><br><span class="line">istio-telemetry-6554768879-vqmjd           2/2       Running     0          3m</span><br><span class="line">prometheus-86cb6dd77c-vhf9s                1/1       Running     0          3m</span><br></pre></td></tr></table></figure><p>当然，我们也可以自定义一些参数，具体的请看[官方文档]($ helm install <a href="https://raw.githubusercontent.com/istio/istio/release-0.8/install/kubernetes/helm/istio">install/kubernetes/helm/istio</a> –name istio –namespace istio-system)。</p><h1 id="样例应用"><a href="#样例应用" class="headerlink" title="样例应用"></a>样例应用</h1><p>让我们部署我们的一个样例应用来看看Istio到底干了啥。</p><p>我们的样例应用叫做BookInfo，这个应用由四个微服务所组成，具体架构图如下：</p><p><img data-src="https://istio.io/docs/guides/img/bookinfo/noistio.svg" alt="Bookinfo Application without Istio"></p><p>这个应用是用不同的语言所写的，让我们来见识一下Istio的魔力吧。</p><p>安装这个应用非常简单，我们只要执行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f samples/bookinfo/kube/bookinfo.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> istioctl create -f samples/bookinfo/routing/bookinfo-gateway.yaml</span></span><br></pre></td></tr></table></figure><p>我们可以注意一下，在<code>bookinfo.yaml</code>中的manifest如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright 2017 Istio Authors</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">#   you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">#   You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">#   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">#   See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">#   limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################################################</span></span><br><span class="line"><span class="comment"># Details service</span></span><br><span class="line"><span class="comment">##################################################################################################</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">details</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">details</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9080</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">details</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">details-v1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">details</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">details</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">istio/examples-bookinfo-details-v1:1.5.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9080</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>但是我们真正部署出来后，变成了这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">sidecar.istio.io/status:</span> <span class="string">&#x27;&#123;&quot;version&quot;:&quot;55c9e544b52e1d4e45d18a58d0b34ba4b72531e45fb6d1572c77191422556ffc&quot;,&quot;initContainers&quot;:[&quot;istio-init&quot;],&quot;containers&quot;:[&quot;istio-proxy&quot;],&quot;volumes&quot;:[&quot;istio-envoy&quot;,&quot;istio-certs&quot;],&quot;imagePullSecrets&quot;:null&#125;&#x27;</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="number">2018-07-05T09:10:55Z</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">details-v1-5f94c6d66b-</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">details</span></span><br><span class="line">    <span class="attr">pod-template-hash:</span> <span class="string">&quot;1950728226&quot;</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">details-v1-5f94c6d66b-jj6lz</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">details-v1-5f94c6d66b</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">528aa360-8033-11e8-8cec-0e04fb7e7092</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;15620&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/details-v1-5f94c6d66b-jj6lz</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">528d5618-8033-11e8-8cec-0e04fb7e7092</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">istio/examples-bookinfo-details-v1:1.5.0</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">details</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9080</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">    <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">default-token-f9mls</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">proxy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sidecar</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--configPath</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/istio/proxy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--binaryPath</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/usr/local/bin/envoy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--serviceCluster</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">details</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--drainDuration</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">45s</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--parentShutdownDuration</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">1m0s</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--discoveryAddress</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">istio-pilot.istio-system:15007</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--discoveryRefreshDelay</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">10s</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--zipkinAddress</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zipkin.istio-system:9411</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--connectTimeout</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">10s</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--statsdUdpAddress</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">istio-statsd-prom-bridge.istio-system:9125</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--proxyAdminPort</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;15000&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--controlPlaneAuthPolicy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">NONE</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">fieldRef:</span></span><br><span class="line">          <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">          <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAMESPACE</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">fieldRef:</span></span><br><span class="line">          <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">          <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">INSTANCE_IP</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">fieldRef:</span></span><br><span class="line">          <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">          <span class="attr">fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ISTIO_META_POD_NAME</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">fieldRef:</span></span><br><span class="line">          <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">          <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ISTIO_META_INTERCEPTION_MODE</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">REDIRECT</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/istio/proxyv2:0.8.0</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">istio-proxy</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">128Mi</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">runAsUser:</span> <span class="number">1337</span></span><br><span class="line">    <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">    <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/istio/proxy</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">istio-envoy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/certs/</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">istio-certs</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">default-token-f9mls</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-p</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;15001&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-u</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;1337&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-m</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">REDIRECT</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-i</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-x</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-b</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9080</span><span class="string">,</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-d</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/istio/proxy_init:0.8.0</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">istio-init</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">capabilities:</span></span><br><span class="line">        <span class="attr">add:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">    <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">default-token-f9mls</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">ip-172-31-39-23</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">  <span class="attr">securityContext:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">serviceAccount:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">emptyDir:</span></span><br><span class="line">      <span class="attr">medium:</span> <span class="string">Memory</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">istio-envoy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">istio-certs</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">      <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">istio.default</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default-token-f9mls</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">default-token-f9mls</span></span><br></pre></td></tr></table></figure><p>可以看到，本来只有一个container的，现在里面多了一个container和initContainer。这个就是Istio的Auto Injection，可以自动把sidecar注入到Pod里面，让我们不需要手动一个一个修改yaml文件，也防止手动修改过程中出错的可能。</p><h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><p>这里我们以路由设置为例子。</p><p>首先我们打开刚才部署好的这个应用的网页，可以看到页面右方的Book Reviews部分里面每次刷新都会随机性地出现黑星星、红星星和没有星星三种情况，这是因为我们有三个不同的backend，路由在默认情况下会随机路由到任意一个backend上。</p><p>我们先尝试把所有的路由都路由到v1版本上（就是没有星星的版本），路由规则如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">details</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">details</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">details</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">productpage</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><p>命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> istioctl create -f samples/bookinfo/routing/route-rule-all-v1.yaml</span></span><br></pre></td></tr></table></figure><p>然后我们再去刷新，就会发现不管怎么刷新星星都不见了。</p><p>接着，假如我们有一个用户是jason，我们希望他能测试v2的backend，就可以用下面的路由规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">cookie:</span></span><br><span class="line">          <span class="attr">regex:</span> <span class="string">^(.*?;)?(user=jason)(;.*)?$</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure><p>命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> istioctl replace -f samples/bookinfo/routing/route-rule-reviews-test-v2.yaml</span></span><br></pre></td></tr></table></figure><p>这时候，我们打开网页，以jason这个用户登录（密码随便填），就会发现每一次访问到的都是带有黑星星的版本。</p><p>这就是Istio提供的路由功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文中我们简单讲了Service Mesh的概念，如何创建Istio以及简单的使用过程，如果大家有兴趣探索Istio更多的功能，可以直接访问<a href="https://istio.io/">Istio的官网</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;早在去年，Service Mesh这个概念就开始火起来了，今年的时候Service Mesh更是爆发式地发展，Service Mesh中的明星项目Istio更是只用了几个月的时间就已经从0.1到了0.8 LTS了。由于工作和毕业的压力，之前一直没有时间深入研究Service Mesh。现在稍微有些时间了，所以打算写点什么关于Service Mesh的。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
    <category term="Service Mesh" scheme="https://www.purewhite.io/tags/Service-Mesh/"/>
    
  </entry>
  
  <entry>
    <title>如何用技术变现 —— 左耳朵耗子专栏记录</title>
    <link href="https://www.purewhite.io/2018/06/14/skill-sell-off/"/>
    <id>https://www.purewhite.io/2018/06/14/skill-sell-off/</id>
    <published>2018-06-14T05:35:58.000Z</published>
    <updated>2021-12-02T12:51:07.230Z</updated>
    
    <content type="html"><![CDATA[<p>昨天购买了左耳朵耗子的<a href="http://stuq.com/a/100aD">付费专栏</a>，拜读了前几篇文章，受益匪浅，故总结并写下此文作为记录。</p><span id="more"></span><p>程序员是手艺人，是靠手艺靠技术吃饭的人，那么怎么样能通过自己的手艺自己的技术赚钱呢？简单来说，就是别人不行的，你可以，这才是核心。在别的文章中也看到过类似概念，大同小异，强调的都是<strong>不可替代性</strong>。</p><p>那么问题就变成了：如何让自己的“手艺”更值钱，更无法替代？</p><p>耗子哥总结下来，一共是有以下几点：</p><ol><li><p>千里之行，积于跬步。不可能一蹴而就，肯定需要脚踏实地一点一点积累才可以，厚积而薄发。需要自己比别人更多地去学习新的技术和技能，有别人没有的经验和经历。</p></li><li><p>关注有价值的东西。这一段我认为我无法总结得更好，所以直接引用原文：</p><blockquote><p>什么是有价值的东西？价值其实是受供需关系影响的，供大于求，就没什么价值，供不应求，就有价值。这意味着你不仅要看到市场，还要看到技术的趋势，能够分辨出什么是主流技术，什么是过渡式的技术。当你比别人有更好的嗅觉时，你就能起动得更快，也就比别人有先发优势。</p><ul><li><strong>关于市场需求</strong>。要看清市场，就需要看看各个公司在做什么，他们的难题是什么。简单来说，现在的每家公司无论大小都缺人。是真的缺人吗？中国是人口大国，不缺写代码搬砖的，真正缺的是有能力能够解决技术难题的人，能够提高团队人效的人。所以，从这些方面思考，你会知道哪些技能才是真正的“供不应求”，这样可以让你更有价值。</li><li><strong>关于技术趋势</strong>。要看清技术趋势，你需要了解历史，就像一个球运动一样，你要知道这个球未来运动的地方，是需要观察球的已经完成运动的轨迹才知道的。因此，了解技术发展轨迹是一件很重要的事。要看一个新的技术是否顺应技术发展趋势，你需要将一些老技术的本质吃得很透。</li></ul><p>因此，在学习技术的过程一定要多问自己两个问题：“1. 这个技术解决什么问题？为什么别的同类技术做不到？2. 为什么是这样解决的？有没有更好的方式？”另外，还有一个简单的判断方法，如果一个新的技术顺应技术发展趋势，那么在这个新的技术出现时，后面一定会有大型的商业公司支持，这类公司支持得越多，就说明你越需要关注。</p></blockquote></li><li><p>找到能体现价值的地方。在一家高速发展的公司中，技术人员的价值可以最大化。这就要求自己一定要能找到一个高速发展的公司以及一个高速发展的领域。</p></li><li><p>动手能力很重要。简单来说，就是要会写代码！细节是魔鬼！而不是做一个ppt架构师！</p></li><li><p>关注技术付费点。技术付费点在耗子哥的总结里面有两个地方：一个是能帮别人挣钱的地方，一个是能帮别人省钱的地方。这也是所有技术的核心竞争力。</p></li><li><p>提升自己的能力和经历。别人要付费给你，前提是信任你，所以你需要提升自己的能力和经历才可以使得别人愿意信任你付费给你。</p></li><li><p>找到有价值的信息源。这个是程序猿基本功了，不再赘述。</p></li><li><p>输出观点和价值观。同样的，需要积跬步，厚积而薄发。</p></li><li><p>朋友圈很重要。你和谁在一起，就会成为什么样的人。物以类聚，人以群分。</p></li></ol><p>最后套用耗子哥的结束语吧，我也认为无法提炼地更好了：</p><blockquote><p>总之，就一句话，<strong>会挣钱的人一定是会投资的人</strong>。我一直认为，<strong>最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱你不用还在那里，而时间你不用就浪费掉了。你把你的时间投资在哪些地方，就意味着你未来会走什么样的路。所以，利用好你的时间，投到一些有意义的地方吧</strong>。</p></blockquote><p>最后附上耗子哥专栏海报：</p><p><img data-src="https://static.purewhite.io/images/2018-06-14-063400.png!webp_50" alt="image-20180614143359989"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天购买了左耳朵耗子的&lt;a href=&quot;http://stuq.com/a/100aD&quot;&gt;付费专栏&lt;/a&gt;，拜读了前几篇文章，受益匪浅，故总结并写下此文作为记录。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://www.purewhite.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.purewhite.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="心得" scheme="https://www.purewhite.io/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>若饭液体版v3.1评测</title>
    <link href="https://www.purewhite.io/2018/06/13/ruffood-evaluate/"/>
    <id>https://www.purewhite.io/2018/06/13/ruffood-evaluate/</id>
    <published>2018-06-13T06:32:51.000Z</published>
    <updated>2021-12-02T12:51:07.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>很久之前就看到大学室友有吃过若饭，当时还推荐给我不过我当时忙于写（撸）代（啊）码（撸）并没有理，昨天在网上又碰巧看到了若饭，于是抱着吃螃蟹的心态打算买来尝一尝。</p><p>若饭是一种代餐食品（饮料？），是为了那些忙的没时间吃饭的人所设计的，据说创始人原来也是程序猿，忙的没法吃饭，于是自己瞎鼓捣出了一些用来解决吃饭问题的混合物，自己吃下来觉得不错，于是想以此创业。</p><span id="more"></span><p>若饭目前有三个产品线，分别是：</p><ol><li>V1.x，代餐豆</li><li>V2.x，粉末版</li><li>V3.x，液体版</li></ol><p>昨天我买了粉末版和液体版的，付完钱已经4点了，联系客服说3点30快递走得第二天发货，但是我就说我之后不方便收快递，于是客服马上联系了仓库，仓库说已经下班了，客服说给我叫个顺丰发货，在这里赞一个 饭桶@若饭 。</p><p>发了顺丰今天早上8点多就送到了，速度飞快，一共就花了大概十几个小时从湖州发货到上海。</p><h1 id="初见"><a href="#初见" class="headerlink" title="初见"></a>初见</h1><p>本来以为再怎么也得等下班回家才能拿到，没想到一早上刚准备出门上班就遇上了来送若饭的快递小哥。</p><p>若饭包装如下：</p><p><img data-src="https://static.purewhite.io/images/2018-06-13-065035.png!webp_50" alt="image-20180613145034726"></p><p>粉末版的包装如下：</p><p><img data-src="https://static.purewhite.io/images/2018-06-13-065109.png!webp_50" alt="image-20180613145108927"></p><p><img data-src="https://static.purewhite.io/images/2018-06-13-065129.png!webp_50" alt="image-20180613145128818"></p><p>买了粉末版，套餐里面还送了一个搅拌杯和量勺：</p><p><img data-src="https://static.purewhite.io/images/2018-06-13-065229.png!webp_50" alt="image-20180613145228863"></p><p><img data-src="https://static.purewhite.io/images/2018-06-13-065318.png!webp_50" alt="image-20180613145318586"></p><p><img data-src="https://static.purewhite.io/images/2018-06-13-065357.png!webp_50" alt="image-20180613145357287"></p><p>对于粉末版而言，需要自己冲泡。由于时间关系，今天打算使用的是V3.1液体版：</p><p><img data-src="https://static.purewhite.io/images/2018-06-13-065538.png!webp_50" alt="image-20180613145537598"></p><p><img data-src="https://static.purewhite.io/images/2018-06-13-065614.png!webp_50" alt="image-20180613145614640"></p><h1 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h1><p>总算等到中午了，可以开始吃若饭了。今天带了一瓶液体版的来公司当做午餐。液体版的瓶口有密封措施，不过有缺口，很容易打开，设计的不错。</p><p>摇晃均匀后，打开瓶盖，颜色是咖啡色的。尝了第一口，感觉里面有点粉末状的东西没有溶解在液体中，应该是各种蛋白粉之类的物质，口感由于有粉末状的物质在里面混着，所以多多少少受了一点影响，不是我预计中的丝滑或者类似饮料的口感。味道比较淡，带有一点点的咖啡的味道，还有豆奶的味道混杂在一起，其中豆制品的味道较为明显，应该和其中有豆类成分是相关的。</p><p>虽然前几口喝下去并没有什么惊艳的感觉，味道也不是那种特别出众的味道，但是还是挺经喝的，因为在喝完几口之后品味了一下，有种欲望想要接着去再喝几口。仔细思考下来，应该是口味特意做成这样的，不容易让人腻。</p><p>人体每天需要多少营养，若饭配比如何在这里不论，官网和包装上都有很多数据，而且在没有各种仪器测量的情况之下无法得出结论；但是若饭确实能给人带来饱腹感——虽然不知道原理是什么——在喝了半瓶之后就已经觉得自己饱了，这样看来可能确实一瓶的量是能给人带来3-4小时饱腹感的，并没有夸大其词。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>若饭作为新型代餐类食品（饮料），抓住了人们吃饭的这个痛点问题，并且提出了一种解决方案，从方便和健康的角度尝试解决这个问题，主要的好处还是食用方便而且营养科学合理，能够节省下来吃饭的时间，比如像我现在可以写一段代码，在思考的时候喝几口若饭就能解决午餐，同时也不用去考虑吃的是否健康。如果是对口味口感上要求很高的话，也许若饭并不能在口味口感上做得很好。</p><p>接着，聊一下价格相关的事情，除了若饭的V2.x的袋装粉末版（需要自己冲泡及清洗杯子）价格还属于尚可之外，别的产品（比如瓶装粉末版，喝完直接扔瓶子）的价格对我这种工薪阶层的人来说还是偏贵一些，不过这也正常，毕竟现在越来越多的消费是拿去买了方便的体验，而并非仅仅是物质上的价值。若饭的本质其实就是医院肠胃科的肠内营养素，只不过医院不会把这种东西做得这么方便人们食用，也不会卖给健康人，而若饭做到了将科学合理配比的饮食做得非常方便去食用，从这个角度来说我认为若饭其实属于附加价值高的商品，而不是类似于大多数的别的零食饮料，是以成本为主的。</p><p>总而言之，若饭可以使得吃饭变得简单、健康、快速，但是吃久了可能会觉得口腹之欲没能满足，还是会想要吃一些好吃的口味重的东西。若饭可以在工作特别忙的时候用来应急当做快速午餐，平时不忙的时候去吃普通的饭菜，这样交替的去食用可能是更好的方案。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;p&gt;很久之前就看到大学室友有吃过若饭，当时还推荐给我不过我当时忙于写（撸）代（啊）码（撸）并没有理，昨天在网上又碰巧看到了若饭，于是抱着吃螃蟹的心态打算买来尝一尝。&lt;/p&gt;
&lt;p&gt;若饭是一种代餐食品（饮料？），是为了那些忙的没时间吃饭的人所设计的，据说创始人原来也是程序猿，忙的没法吃饭，于是自己瞎鼓捣出了一些用来解决吃饭问题的混合物，自己吃下来觉得不错，于是想以此创业。&lt;/p&gt;</summary>
    
    
    
    <category term="好吃的" scheme="https://www.purewhite.io/categories/%E5%A5%BD%E5%90%83%E7%9A%84/"/>
    
    
    <category term="随笔" scheme="https://www.purewhite.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="好吃的" scheme="https://www.purewhite.io/tags/%E5%A5%BD%E5%90%83%E7%9A%84/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 415.有效回文串</title>
    <link href="https://www.purewhite.io/2018/03/30/lintcode-valid-palindrome/"/>
    <id>https://www.purewhite.io/2018/03/30/lintcode-valid-palindrome/</id>
    <published>2018-03-30T10:02:44.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>你是否考虑过，字符串有可能是空字符串？这是面试过程中，面试官常常会问的问题。</p><p>在这个题目中，我们将空字符串判定为有效回文。</p><span id="more"></span><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><code>&quot;A man, a plan, a canal: Panama&quot;</code> 是一个回文。</p><p><code>&quot;race a car&quot;</code> 不是一个回文。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题的思路很简单，先把给定字符串预处理一下，先只选择其中的字母和数据，再全部变成小写（大写），然后根据回文串的性质左右两边进行比较即可。</p><p>坑点在于题意中的注意事项说的，如果是空串的情况。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param s: A string</span></span><br><span class="line"><span class="string">    @return: Whether the string is a valid palindrome</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># edge condition</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># pre-process</span></span><br><span class="line">        real = [ch.lower() <span class="keyword">for</span> ch <span class="keyword">in</span> s <span class="keyword">if</span> ch.isalnum()]</span><br><span class="line">        <span class="comment"># solve</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(real) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> real[i] != real[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。&lt;/p&gt;
&lt;h5 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h5&gt;&lt;p&gt;你是否考虑过，字符串有可能是空字符串？这是面试过程中，面试官常常会问的问题。&lt;/p&gt;
&lt;p&gt;在这个题目中，我们将空字符串判定为有效回文。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.purewhite.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.purewhite.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LintCode" scheme="https://www.purewhite.io/tags/LintCode/"/>
    
    <category term="数据结构" scheme="https://www.purewhite.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 627.最长回文串</title>
    <link href="https://www.purewhite.io/2018/03/30/lintcode-longest-palindrome/"/>
    <id>https://www.purewhite.io/2018/03/30/lintcode-longest-palindrome/</id>
    <published>2018-03-30T09:10:06.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个包含大小写字母的字符串。求出由这些字母构成的最长的回文串的长度是多少。</p><p>数据是大小写敏感的，也就是说，<code>&quot;Aa&quot;</code> 并不会被认为是一个回文串。</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>假设字符串的长度不会超过 <code>1010</code>。</p><span id="more"></span><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>给出 s = <code>&quot;abccccdd&quot;</code> 返回 <code>7</code></p><p>一种可以构建出来的最长回文串方案是 <code>&quot;dccaccd&quot;</code>。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>看到题目，第一个关键是看到，这道题只要求长度即可，不需要求出具体的回文串，所以会方便很多。</p><p>既然只要求出长度，那么一定是有一些简单的方法算出来不用求出具体的回文串到底如何的。</p><p>那我们就思考，要组成回文串需要什么样的条件呢？</p><ol><li>单个字母，放在回文串中间，一定是回文串</li><li>两个相同的字母，一定能组成回文串</li><li>两个或者多个不同的字母，一定不能组成回文串</li></ol><p>这里的关键是第二点，两个相同的字母一定能组成回文串，所以我们就先考虑一下，如果一个字母在给定字符串中出现了偶数次数，那么一定能组成回文串。</p><p>那如果一个字母出现了奇数次呢？</p><p>思考一下就能想到，奇数次的出现次数，等于偶数次+1。</p><p>根据上面的第一和第三点，如果说有出现奇数次的字母，那么这些字母中可以选择一个放在回文串中间，这样长度可以+1。</p><p>最后剩下的就是一些边界情况处理了，比如，如果所有的字母都出现偶数次。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param s: a string which consists of lowercase or uppercase letters</span></span><br><span class="line"><span class="string">    @return: the length of the longest palindromes that can be built</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        odd = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> odd:</span><br><span class="line">                odd.append(ch)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                odd.remove(ch)</span><br><span class="line"></span><br><span class="line">        num = <span class="built_in">len</span>(odd)</span><br><span class="line">        <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            num -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s) - num</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给出一个包含大小写字母的字符串。求出由这些字母构成的最长的回文串的长度是多少。&lt;/p&gt;
&lt;p&gt;数据是大小写敏感的，也就是说，&lt;code&gt;&amp;quot;Aa&amp;quot;&lt;/code&gt; 并不会被认为是一个回文串。&lt;/p&gt;
&lt;h5 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h5&gt;&lt;p&gt;假设字符串的长度不会超过 &lt;code&gt;1010&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.purewhite.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.purewhite.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LintCode" scheme="https://www.purewhite.io/tags/LintCode/"/>
    
    <category term="数据结构" scheme="https://www.purewhite.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Helm进行本地开发</title>
    <link href="https://www.purewhite.io/2018/01/17/helm-local-dev/"/>
    <id>https://www.purewhite.io/2018/01/17/helm-local-dev/</id>
    <published>2018-01-17T04:49:30.000Z</published>
    <updated>2021-12-02T12:51:07.226Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://helm.sh/">Helm</a>是kubernetes的官方包管理工具。根据官网上的描述<code>Helm is the best way to find, share, and use software built for Kubernetes.</code>可以看出helm在kubernetes社区中的定位。</p><p>这篇文章并不是helm的入门文章，而是着重于如何在本地开发chart。希望进行helm入门的同学可以参考官方文档。</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文会分为两个部分来探讨如何在本地开发chart，分别是：</p><ul><li>Chart的规范</li><li>Helm提供的本地开发功能</li></ul><h1 id="Chart的规范"><a href="#Chart的规范" class="headerlink" title="Chart的规范"></a>Chart的规范</h1><p>根据定义，一个Chart是一些有相关性的Kubernetes资源的集合。一个chart可以是一个简单的应用，比如memcached，或者是一个复杂的集合，比如一个full-stack的web的应用，含有server，ui，database，cache等等。</p><p>Chart从本质上只不过是一些文件，不过这些文件需要满足一定的规范，比如目录的规范和文件名的规范。</p><h2 id="Chart的目录结构"><a href="#Chart的目录结构" class="headerlink" title="Chart的目录结构"></a>Chart的目录结构</h2><p>根据规定，符合如下目录结构的目录就是一个Chart，目录名即为Chart名（不包含版本信息）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wordpress/</span><br><span class="line">  Chart.yaml          <span class="comment"># A YAML file containing information about the chart</span></span><br><span class="line">  LICENSE             <span class="comment"># OPTIONAL: A plain text file containing the license for the chart</span></span><br><span class="line">  README.md           <span class="comment"># OPTIONAL: A human-readable README file</span></span><br><span class="line">  requirements.yaml   <span class="comment"># OPTIONAL: A YAML file listing dependencies for the chart</span></span><br><span class="line">  values.yaml         <span class="comment"># The default configuration values for this chart</span></span><br><span class="line">  charts/             <span class="comment"># OPTIONAL: A directory containing any charts upon which this chart depends.</span></span><br><span class="line">  templates/          <span class="comment"># OPTIONAL: A directory of templates that, when combined with values,</span></span><br><span class="line">                      <span class="comment"># will generate valid Kubernetes manifest files.</span></span><br><span class="line">  templates/NOTES.txt <span class="comment"># OPTIONAL: A plain text file containing short usage notes</span></span><br></pre></td></tr></table></figure><p>虽然这里看到charts和templates文件夹都是optional的，但是至少需要有一个存在，chart才是合法的。</p><h2 id="Chart-yaml文件"><a href="#Chart-yaml文件" class="headerlink" title="Chart.yaml文件"></a>Chart.yaml文件</h2><p>每个Chart都必须有一个<code>Chart.yaml</code>文件，这个文件的内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">The</span> <span class="string">name</span> <span class="string">of</span> <span class="string">the</span> <span class="string">chart</span> <span class="string">(required)</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">A</span> <span class="string">SemVer</span> <span class="number">2</span> <span class="string">version</span> <span class="string">(required)</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">single-sentence</span> <span class="string">description</span> <span class="string">of</span> <span class="string">this</span> <span class="string">project</span> <span class="string">(optional)</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">A</span> <span class="string">list</span> <span class="string">of</span> <span class="string">keywords</span> <span class="string">about</span> <span class="string">this</span> <span class="string">project</span> <span class="string">(optional)</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">The</span> <span class="string">URL</span> <span class="string">of</span> <span class="string">this</span> <span class="string">project&#x27;s</span> <span class="string">home</span> <span class="string">page</span> <span class="string">(optional)</span></span><br><span class="line"><span class="attr">sources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">A</span> <span class="string">list</span> <span class="string">of</span> <span class="string">URLs</span> <span class="string">to</span> <span class="string">source</span> <span class="string">code</span> <span class="string">for</span> <span class="string">this</span> <span class="string">project</span> <span class="string">(optional)</span></span><br><span class="line"><span class="attr">maintainers:</span> <span class="comment"># (optional)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">The</span> <span class="string">maintainer&#x27;s</span> <span class="string">name</span> <span class="string">(required</span> <span class="string">for</span> <span class="string">each</span> <span class="string">maintainer)</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">The</span> <span class="string">maintainer&#x27;s</span> <span class="string">email</span> <span class="string">(optional</span> <span class="string">for</span> <span class="string">each</span> <span class="string">maintainer)</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">A</span> <span class="string">URL</span> <span class="string">for</span> <span class="string">the</span> <span class="string">maintainer</span> <span class="string">(optional</span> <span class="string">for</span> <span class="string">each</span> <span class="string">maintainer)</span></span><br><span class="line"><span class="attr">engine:</span> <span class="string">gotpl</span> <span class="comment"># The name of the template engine (optional, defaults to gotpl)</span></span><br><span class="line"><span class="attr">icon:</span> <span class="string">A</span> <span class="string">URL</span> <span class="string">to</span> <span class="string">an</span> <span class="string">SVG</span> <span class="string">or</span> <span class="string">PNG</span> <span class="string">image</span> <span class="string">to</span> <span class="string">be</span> <span class="string">used</span> <span class="string">as</span> <span class="string">an</span> <span class="string">icon</span> <span class="string">(optional).</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="string">The</span> <span class="string">version</span> <span class="string">of</span> <span class="string">the</span> <span class="string">app</span> <span class="string">that</span> <span class="string">this</span> <span class="string">contains</span> <span class="string">(optional).</span> <span class="string">This</span> <span class="string">needn&#x27;t</span> <span class="string">be</span> <span class="string">SemVer.</span></span><br><span class="line"><span class="attr">deprecated:</span> <span class="string">Whether</span> <span class="string">or</span> <span class="string">not</span> <span class="string">this</span> <span class="string">chart</span> <span class="string">is</span> <span class="string">deprecated</span> <span class="string">(optional,</span> <span class="string">boolean)</span></span><br><span class="line"><span class="attr">tillerVersion: The version of Tiller that this chart requires. This should be expressed as a SemVer range:</span> <span class="string">&quot;&gt;2.0.0&quot;</span> <span class="string">(optional)</span></span><br></pre></td></tr></table></figure><h2 id="Chart的版本"><a href="#Chart的版本" class="headerlink" title="Chart的版本"></a>Chart的版本</h2><p>每个Chart都必须有一个版本号，版本号必须遵守<a href="http://semver.org/">语义化版本规范V2</a>。每个package（Chart打包后的东西）同时由name和version来唯一确定。</p><p>比如，一个叫做<code>nginx</code>的版本为<code>1.2.3</code>的Chart，打包后就是<code>nginx-1.2.3.tgz</code>。</p><p>更复杂的语义化版本号是被支持的，比如<code>version: 1.2.3-alpha.1+ef365</code>但是非语义化的版本是不被允许的。</p><p>Helm和Tiller都会使用Chart的名称+版本来唯一标识一个package，所以Chart.yaml里面的版本一定要对应package的文件名。</p><h2 id="appVersion"><a href="#appVersion" class="headerlink" title="appVersion"></a>appVersion</h2><p>appVersion其实并没啥用，只是指定了Chart包含的应用的版本，对helm和tiller来说并不会有啥影响，也不需要和Chart的version一致。自己随便写都可以……</p><h2 id="Deprecating-Chart"><a href="#Deprecating-Chart" class="headerlink" title="Deprecating Chart"></a>Deprecating Chart</h2><p>可以通过在<code>Chart.yaml</code>里面把<code>deprecated</code>设为<code>true</code>来标识一个Chart已经是deprecated状态。</p><h2 id="License，ReadME和Notes"><a href="#License，ReadME和Notes" class="headerlink" title="License，ReadME和Notes"></a>License，ReadME和Notes</h2><p>一个Chart还可以有License来标识License信息，README.md来包含一些介绍信息，以及一个templates/NOTES.txt文件来指导如何去安装或者使用。</p><p>templates/NOTES.txt文件会被当做普通的template来对待（意味着其中可以有变量），并且会在每次<code>helm status</code>之后和<code>helm install</code>之后被打印到STDOUT。</p><p>比如<code>stable/mysql</code>的NOTES.txt如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">MySQL can be accessed via<span class="built_in"> port </span>3306 on the following<span class="built_in"> DNS </span>name <span class="keyword">from</span> within your cluster:</span><br><span class="line">&#123;&#123; template <span class="string">&quot;mysql.fullname&quot;</span> . &#125;&#125;.&#123;&#123; .Release.Namespace &#125;&#125;.svc.cluster.local</span><br><span class="line"></span><br><span class="line"><span class="keyword">To</span> <span class="builtin-name">get</span> your root password run:</span><br><span class="line"></span><br><span class="line">    <span class="attribute">MYSQL_ROOT_PASSWORD</span>=$(kubectl <span class="builtin-name">get</span><span class="built_in"> secret </span>--namespace &#123;&#123; .Release.Namespace &#125;&#125; &#123;&#123; template <span class="string">&quot;mysql.fullname&quot;</span> . &#125;&#125; -o <span class="attribute">jsonpath</span>=<span class="string">&quot;&#123;.data.mysql-root-password&#125;&quot;</span> | base64 --decode; echo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">To</span> connect <span class="keyword">to</span> your database:</span><br><span class="line"></span><br><span class="line">1. <span class="builtin-name">Run</span> an Ubuntu pod that you can use as a client:</span><br><span class="line"></span><br><span class="line">    kubectl <span class="builtin-name">run</span> -i --tty ubuntu <span class="attribute">--image</span>=ubuntu:16.04 <span class="attribute">--restart</span>=Never -- bash -il</span><br><span class="line"></span><br><span class="line">2. Install the mysql client:</span><br><span class="line"></span><br><span class="line">    $ apt-<span class="builtin-name">get</span> update &amp;&amp; apt-<span class="builtin-name">get</span> install mysql-client -y</span><br><span class="line"></span><br><span class="line">3. Connect using the mysql cli, then provide your password:</span><br><span class="line">    $ mysql -h &#123;&#123; template <span class="string">&quot;mysql.fullname&quot;</span> . &#125;&#125; -p</span><br><span class="line"></span><br><span class="line"><span class="keyword">To</span> connect <span class="keyword">to</span> your database directly <span class="keyword">from</span> outside the K8s cluster:</span><br><span class="line">    &#123;&#123;- <span class="keyword">if</span> contains <span class="string">&quot;NodePort&quot;</span> .Values.service.type &#125;&#125;</span><br><span class="line">    <span class="attribute">MYSQL_HOST</span>=$(kubectl <span class="builtin-name">get</span> nodes --namespace &#123;&#123; .Release.Namespace &#125;&#125; -o <span class="attribute">jsonpath</span>=<span class="string">&#x27;&#123;.items[0].status.addresses[0].address&#125;&#x27;</span>)</span><br><span class="line">    <span class="attribute">MYSQL_PORT</span>=$(kubectl <span class="builtin-name">get</span> svc --namespace &#123;&#123; .Release.Namespace &#125;&#125; &#123;&#123; template <span class="string">&quot;mysql.fullname&quot;</span> . &#125;&#125; -o <span class="attribute">jsonpath</span>=<span class="string">&#x27;&#123;.spec.ports[0].nodePort&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    &#123;&#123;- <span class="keyword">else</span> <span class="keyword">if</span> contains <span class="string">&quot;ClusterIP&quot;</span> .Values.service.type &#125;&#125;</span><br><span class="line">    <span class="attribute">MYSQL_HOST</span>=127.0.0.1</span><br><span class="line">    MYSQL_PORT=&#123;&#123;<span class="built_in"> default </span><span class="string">&quot;3306&quot;</span> .Values.service.port &#125;&#125;</span><br><span class="line"></span><br><span class="line">    # Execute the following commands <span class="keyword">to</span><span class="built_in"> route </span>the connection:</span><br><span class="line">    <span class="builtin-name">export</span> <span class="attribute">POD_NAME</span>=$(kubectl <span class="builtin-name">get</span> pods --namespace &#123;&#123; .Release.Namespace &#125;&#125; -l <span class="string">&quot;app=&#123;&#123; template &quot;</span>mysql.fullname<span class="string">&quot; . &#125;&#125;&quot;</span> -o <span class="attribute">jsonpath</span>=<span class="string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)</span><br><span class="line">    kubectl port-forward <span class="variable">$POD_NAME</span> &#123;&#123;<span class="built_in"> default </span><span class="string">&quot;3306&quot;</span> .Values.service.port &#125;&#125;:&#123;&#123;<span class="built_in"> default </span><span class="string">&quot;3306&quot;</span> .Values.service.port &#125;&#125;</span><br><span class="line"></span><br><span class="line">    &#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br><span class="line">    mysql -h <span class="variable">$&#123;MYSQL_HOST&#125;</span> -P<span class="variable">$&#123;MYSQL_PORT&#125;</span> -u root -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br></pre></td></tr></table></figure><p>可以看出来，NOTES.txt是用来给用户作使用上的指导的。</p><h2 id="Chart的依赖"><a href="#Chart的依赖" class="headerlink" title="Chart的依赖"></a>Chart的依赖</h2><p>我们都知道，软件开发过程中，复用是一个很重要的概念，同样的，Chart也可以依赖于其它的Chart，可以复用其它的Chart的内容。</p><h3 id="使用requirements-yaml"><a href="#使用requirements-yaml" class="headerlink" title="使用requirements.yaml"></a>使用requirements.yaml</h3><p>Helm提供了两种对Chart复用的方法，第一种是在<code>requirements.yaml</code>中指定依赖的Chart，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.2</span><span class="number">.3</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">http://example.com/charts</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">3.2</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">http://another.example.com/charts</span></span><br></pre></td></tr></table></figure><p>如果说需要对一个chart复用多次，可以这么干：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parentchart/requirements.yaml</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">subchart</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">http://localhost:10191</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">new-subchart-1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">subchart</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">http://localhost:10191</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">new-subchart-2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">subchart</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">http://localhost:10191</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>除此之外，Helm还可以选择性的去使用依赖的chart，具体可以参考<a href="https://docs.helm.sh/developing_charts/#tags-and-condition-fields-in-requirements-yaml">tags and condition</a>。</p><h3 id="直接使用charts来手动管理"><a href="#直接使用charts来手动管理" class="headerlink" title="直接使用charts来手动管理"></a>直接使用charts来手动管理</h3><p>第二种是直接把需要用的Chart放到<code>charts</code>文件夹下。一般情况下推荐使用第一种，第二种是在需要对依赖的chart做魔改的情况下用到的。</p><p>Helm还提供了<code>helm dep</code>这个命令来方便对依赖的管理，之后会介绍到。</p><h3 id="依赖的一些实现细节"><a href="#依赖的一些实现细节" class="headerlink" title="依赖的一些实现细节"></a>依赖的一些实现细节</h3><p>在<code>helm install</code>和<code>helm upgrade</code>的时候，helm会把依赖和当前chart打包成一个集合一起送给tiller，然后（目前是）按照类型+字母顺序来apply，并不是先去install依赖再去install当前的chart。</p><p>例如，我们有一个chart，会有以下三个东西：</p><ul><li>namespace “A-Namespace”</li><li>statefulset “A-StatefulSet”</li><li>service “A-Service”</li></ul><p>这个chart依赖于另一个chart，有如下三个东西：</p><ul><li>namespace “B-Namespace”</li><li>replicaset “B-ReplicaSet”</li><li>service “B-Service”</li></ul><p>那么在安装或者升级的过程中，顺序如下：</p><ul><li>A-Namespace</li><li>B-Namespace</li><li>A-StatefulSet</li><li>B-ReplicaSet</li><li>A-Service</li><li>B-Service</li></ul><h1 id="Helm客户端提供的和本地开发相关的功能"><a href="#Helm客户端提供的和本地开发相关的功能" class="headerlink" title="Helm客户端提供的和本地开发相关的功能"></a>Helm客户端提供的和本地开发相关的功能</h1><p>Helm的客户端提供了一些和本地开发相关的命令，这里简单介绍一下。</p><h2 id="helm-completion"><a href="#helm-completion" class="headerlink" title="helm completion"></a>helm completion</h2><p>顾名思义，提供了命令补全，使用方式也比较简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> &lt;(helm completion zsh)</span></span><br></pre></td></tr></table></figure><h2 id="helm-create"><a href="#helm-create" class="headerlink" title="helm create"></a>helm create</h2><p>可以通过这个命令直接创建出一个符合Chart规范的目录出来，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> helm create myweb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree myweb</span></span><br><span class="line">myweb</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── charts</span><br><span class="line">├── templates</span><br><span class="line">│   ├── NOTES.txt</span><br><span class="line">│   ├── _helpers.tpl</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── ingress.yaml</span><br><span class="line">│   └── service.yaml</span><br><span class="line">└── values.yaml</span><br><span class="line"></span><br><span class="line">2 directories, 7 files</span><br></pre></td></tr></table></figure><h2 id="helm-dependency"><a href="#helm-dependency" class="headerlink" title="helm dependency"></a>helm dependency</h2><p>顾名思义，是用来进行依赖管理的，可以被简写为<code>helm dep</code>，具体使用如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> helm dep</span></span><br><span class="line">Manage the dependencies of a chart.</span><br><span class="line"></span><br><span class="line">Helm charts store their dependencies in &#x27;charts/&#x27;. For chart developers, it is</span><br><span class="line">often easier to manage a single dependency file (&#x27;requirements.yaml&#x27;)</span><br><span class="line">which declares all dependencies.</span><br><span class="line"></span><br><span class="line">The dependency commands operate on that file, making it easy to synchronize</span><br><span class="line">between the desired dependencies and the actual dependencies stored in the</span><br><span class="line">&#x27;charts/&#x27; directory.</span><br><span class="line"></span><br><span class="line">A &#x27;requirements.yaml&#x27; file is a YAML file in which developers can declare chart</span><br><span class="line">dependencies, along with the location of the chart and the desired version.</span><br><span class="line">For example, this requirements file declares two dependencies:</span><br><span class="line"></span><br><span class="line">    # requirements.yaml</span><br><span class="line">    dependencies:</span><br><span class="line">    - name: nginx</span><br><span class="line">      version: &quot;1.2.3&quot;</span><br><span class="line">      repository: &quot;https://example.com/charts&quot;</span><br><span class="line">    - name: memcached</span><br><span class="line">      version: &quot;3.2.1&quot;</span><br><span class="line">      repository: &quot;https://another.example.com/charts&quot;</span><br><span class="line"></span><br><span class="line">The &#x27;name&#x27; should be the name of a chart, where that name must match the name</span><br><span class="line">in that chart&#x27;s &#x27;Chart.yaml&#x27; file.</span><br><span class="line"></span><br><span class="line">The &#x27;version&#x27; field should contain a semantic version or version range.</span><br><span class="line"></span><br><span class="line">The &#x27;repository&#x27; URL should point to a Chart Repository. Helm expects that by</span><br><span class="line">appending &#x27;/index.yaml&#x27; to the URL, it should be able to retrieve the chart</span><br><span class="line">repository&#x27;s index. Note: &#x27;repository&#x27; can be an alias. The alias must start</span><br><span class="line">with &#x27;alias:&#x27; or &#x27;@&#x27;.</span><br><span class="line"></span><br><span class="line">Starting from 2.2.0, repository can be defined as the path to the directory of</span><br><span class="line">the dependency charts stored locally. The path should start with a prefix of</span><br><span class="line">&quot;file://&quot;. For example,</span><br><span class="line"></span><br><span class="line">    # requirements.yaml</span><br><span class="line">    dependencies:</span><br><span class="line">    - name: nginx</span><br><span class="line">      version: &quot;1.2.3&quot;</span><br><span class="line">      repository: &quot;file://../dependency_chart/nginx&quot;</span><br><span class="line"></span><br><span class="line">If the dependency chart is retrieved locally, it is not required to have the</span><br><span class="line">repository added to helm by &quot;helm add repo&quot;. Version matching is also supported</span><br><span class="line">for this case.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  helm dependency [command]</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  dependency, dep, dependencies</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  build       rebuild the charts/ directory based on the requirements.lock file</span><br><span class="line">  list        list the dependencies for the given chart</span><br><span class="line">  update      update charts/ based on the contents of requirements.yaml</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help   help for dependency</span><br><span class="line"></span><br><span class="line">Use &quot;helm dependency [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><h2 id="helm-fetch"><a href="#helm-fetch" class="headerlink" title="helm fetch"></a>helm fetch</h2><p>一看这就是个下载别的chart的命令，为啥我要说和本地开发有关系呢？</p><p>因为我认为，helm的官方repo里面的chart最大的作用就是作为一个best practice来展示给使用者一个示例。</p><p>所以，当不知道该怎么写的时候，去抄吧😁。</p><h2 id="helm-lint"><a href="#helm-lint" class="headerlink" title="helm lint"></a>helm lint</h2><p>顾名思义，用来检查一个Chart是否存在问题。</p><p>如果说有错误，会报出error，并返回非零值。</p><p>我们就用刚才的myweb来试手：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> helm lint myweb</span></span><br><span class="line">==&gt; Linting myweb</span><br><span class="line">[INFO] Chart.yaml: icon is recommended</span><br><span class="line"></span><br><span class="line">1 chart(s) linted, no failures</span><br></pre></td></tr></table></figure><h2 id="helm-package"><a href="#helm-package" class="headerlink" title="helm package"></a>helm package</h2><p>这个命令是当一个chart写完后用来把一个chart打包成<code>chartName-version.tgz</code>的。一般只有在发布的时候使用，提供了比较多的功能，比如sign之类的，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> helm package --<span class="built_in">help</span></span></span><br><span class="line">This command packages a chart into a versioned chart archive file. If a path</span><br><span class="line">is given, this will look at that path for a chart (which must contain a</span><br><span class="line">Chart.yaml file) and then package that directory.</span><br><span class="line"></span><br><span class="line">If no path is given, this will look in the present working directory for a</span><br><span class="line">Chart.yaml file, and (if found) build the current directory into a chart.</span><br><span class="line"></span><br><span class="line">Versioned chart archives are used by Helm package repositories.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  helm package [flags] [CHART_PATH] [...]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -u, --dependency-update    update dependencies from &quot;requirements.yaml&quot; to dir &quot;charts/&quot; before packaging</span><br><span class="line">  -d, --destination string   location to write the chart. (default &quot;.&quot;)</span><br><span class="line">      --key string           name of the key to use when signing. Used if --sign is true</span><br><span class="line">      --keyring string       location of a public keyring (default &quot;/Users/daniel/.gnupg/pubring.gpg&quot;)</span><br><span class="line">      --save                 save packaged chart to local chart repository (default true)</span><br><span class="line">      --sign                 use a PGP private key to sign this package</span><br><span class="line">      --version string       set the version on the chart to this semver version</span><br></pre></td></tr></table></figure><p>我们还是用刚才的myweb作为例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> helm package myweb</span></span><br><span class="line">Successfully packaged chart and saved it to: /Users/daniel/Works/k8s/helm/myweb-0.1.0.tgz</span><br></pre></td></tr></table></figure><h2 id="helm-serve"><a href="#helm-serve" class="headerlink" title="helm serve"></a>helm serve</h2><p>这个命令是用来在本地开启一个repo server的，可以用来本地测试使用。</p><h2 id="helm-template"><a href="#helm-template" class="headerlink" title="helm template"></a>helm template</h2><p>这个命令可以在本地渲染出template来检查是否正确，具体使用如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> helm template --<span class="built_in">help</span></span></span><br><span class="line">Render chart templates locally and display the output.</span><br><span class="line"></span><br><span class="line">This does not require Tiller. However, any values that would normally be</span><br><span class="line">looked up or retrieved in-cluster will be faked locally. Additionally, none</span><br><span class="line">of the server-side testing of chart validity (e.g. whether an API is supported)</span><br><span class="line">is done.</span><br><span class="line"></span><br><span class="line">To render just one template in a chart, use &#x27;-x&#x27;:</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> helm template mychart -x templates/deployment.yaml</span></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  helm template [flags] CHART</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -x, --execute stringArray    only execute the given templates</span><br><span class="line">      --kube-version string    override the Kubernetes version used as Capabilities.KubeVersion.Major/Minor (e.g. 1.7)</span><br><span class="line">  -n, --name string            release name (default &quot;RELEASE-NAME&quot;)</span><br><span class="line">      --name-template string   specify template used to name the release</span><br><span class="line">      --namespace string       namespace to install the release into</span><br><span class="line">      --notes                  show the computed NOTES.txt file as well</span><br><span class="line">      --set stringArray        set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)</span><br><span class="line">  -f, --values valueFiles      specify values in a YAML file (can specify multiple) (default [])</span><br></pre></td></tr></table></figure><p>我们仍然以myweb作为例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> helm template myweb</span></span><br><span class="line">---</span><br><span class="line"><span class="meta">#</span><span class="bash"> Source: myweb/templates/service.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: RELEASE-NAME-myweb</span><br><span class="line">  labels:</span><br><span class="line">    app: myweb</span><br><span class="line">    chart: myweb-0.1.0</span><br><span class="line">    release: RELEASE-NAME</span><br><span class="line">    heritage: Tiller</span><br><span class="line">spec:</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      targetPort: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">      name: nginx</span><br><span class="line">  selector:</span><br><span class="line">    app: myweb</span><br><span class="line">    release: RELEASE-NAME</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="meta">#</span><span class="bash"> Source: myweb/templates/deployment.yaml</span></span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: RELEASE-NAME-myweb</span><br><span class="line">  labels:</span><br><span class="line">    app: myweb</span><br><span class="line">    chart: myweb-0.1.0</span><br><span class="line">    release: RELEASE-NAME</span><br><span class="line">    heritage: Tiller</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myweb</span><br><span class="line">        release: RELEASE-NAME</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: myweb</span><br><span class="line">          image: &quot;nginx:stable&quot;</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br><span class="line">          livenessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /</span><br><span class="line">              port: 80</span><br><span class="line">          readinessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /</span><br><span class="line">              port: 80</span><br><span class="line">          resources:</span><br><span class="line">            &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="meta">#</span><span class="bash"> Source: myweb/templates/ingress.yaml</span></span><br></pre></td></tr></table></figure><h2 id="helm-verify"><a href="#helm-verify" class="headerlink" title="helm verify"></a>helm verify</h2><p>这个命令是用来验证一个给定的chart是否被sign。在对安全性要求高的环境下有用。</p><h2 id="helm-plugin"><a href="#helm-plugin" class="headerlink" title="helm plugin"></a>helm plugin</h2><p>最后是这个<code>helm plugin</code>，看到这个我们就能感觉到，helm瞬间有了无数的扩展性，需要什么功能如果helm不提供咱们就自己干一个加上去。</p><p>helm目前现在已经有了一些比较好的plugin，比如有一个plugin支持用template render出来之后再进行验证查错之类的。</p><p>如果有一些别的定制化的需求也可以通过自己写个plugin来完成。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://helm.sh/&quot;&gt;Helm&lt;/a&gt;是kubernetes的官方包管理工具。根据官网上的描述&lt;code&gt;Helm is the best way to find, share, and use software built for Kubernetes.&lt;/code&gt;可以看出helm在kubernetes社区中的定位。&lt;/p&gt;
&lt;p&gt;这篇文章并不是helm的入门文章，而是着重于如何在本地开发chart。希望进行helm入门的同学可以参考官方文档。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Helm中如何传递value</title>
    <link href="https://www.purewhite.io/2018/01/17/helm-provide-value/"/>
    <id>https://www.purewhite.io/2018/01/17/helm-provide-value/</id>
    <published>2018-01-17T03:25:15.000Z</published>
    <updated>2021-12-02T12:51:07.226Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://helm.sh/">Helm</a>是kubernetes的官方包管理工具。根据官网上的描述<code>Helm is the best way to find, share, and use software built for Kubernetes.</code>可以看出helm在kubernetes社区中的定位。</p><p>这篇文章并不是helm的入门文章，而是着重于helm中的chart之间如何传递value。希望进行helm入门的同学可以参考官方文档。</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在helm的使用过程中，经常会出现两种需求：</p><ol><li>在父chart中<strong>读取</strong>子chart的某些value的值</li><li>在父chart中<strong>修改</strong>子chart的某些value的值</li></ol><p>helm对于这两种场景提供了比较完备的支持，下面我们来具体讲一下解决方案。</p><h1 id="在父chart中读取子chart的值"><a href="#在父chart中读取子chart的值" class="headerlink" title="在父chart中读取子chart的值"></a>在父chart中读取子chart的值</h1><p>helm提供了两种方法来应对这种情况：</p><h2 id="使用export格式"><a href="#使用export格式" class="headerlink" title="使用export格式"></a>使用export格式</h2><p>如果说一个child的chart在values的root下有一个叫做<code>export</code>的key，那么它的parent chart就可以直接在requirements里面通过指定需要import的key来将值import到自身的values里面，例子如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s requirements.yaml file</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="attr">import-values:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># child&#x27;s values.yaml file</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">exports:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">myint:</span> <span class="number">99</span></span><br></pre></td></tr></table></figure><p>helm会发现，我们指定了要import <code>data</code>这个key，所以就去child的values.yaml里面寻找，发现了这个key有被export，于是就import了它的内容。</p><p>这时候的parent的values如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s values file</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">myint:</span> <span class="number">99</span></span><br></pre></td></tr></table></figure><p>需要注意，在parent的values中<code>data</code>这个key不会被import进来，只会import <code>data</code>的内容。如果希望把这个key也一起import进来，可以使用下面说的方法。</p><h2 id="使用child-parent格式"><a href="#使用child-parent格式" class="headerlink" title="使用child/parent格式"></a>使用child/parent格式</h2><p>如果我们想要获得一些不在exports这个key下面的值，我们就必须指定在child中要import的路径，以及在parent中的对应路径，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s requirements.yaml file</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">subchart1</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">http://localhost:10191</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="attr">import-values:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">child:</span> <span class="string">default.data</span></span><br><span class="line">        <span class="attr">parent:</span> <span class="string">myimports</span></span><br></pre></td></tr></table></figure><p>根据如上的这个requirements文件，helm将会在child的chart中寻找default.data的值，并导入到parent中的myimports这个路径下。</p><p>假设parent和child初始的values如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s values.yaml file</span></span><br><span class="line"></span><br><span class="line"><span class="attr">myimports:</span></span><br><span class="line">  <span class="attr">myint:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">mybool:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mystring:</span> <span class="string">&quot;helm rocks!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># subchart1&#x27;s values.yaml file</span></span><br><span class="line"></span><br><span class="line"><span class="attr">default:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">myint:</span> <span class="number">999</span></span><br><span class="line">    <span class="attr">mybool:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>那么导入之后，真正渲染出来的parent的values的值为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s final values</span></span><br><span class="line"></span><br><span class="line"><span class="attr">myimports:</span></span><br><span class="line">  <span class="attr">myint:</span> <span class="number">999</span></span><br><span class="line">  <span class="attr">mybool:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mystring:</span> <span class="string">&quot;helm rocks!&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出来，parent中的values把myint和mybool从subchart1里面import了进来。</p><h1 id="在父chart中修改子chart的值"><a href="#在父chart中修改子chart的值" class="headerlink" title="在父chart中修改子chart的值"></a>在父chart中修改子chart的值</h1><p>想要再父chart中修改子chart的值比较容易，假设子chart的名字是<code>mychartabc</code>，那么我们可以很简单地在父chart的values中通过以下方式进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in parent&#x27;s values.yaml</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mychartabc:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure><p>这样就可以修改子chart的值了。</p><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p><a href="https://docs.helm.sh/developing_charts/#importing-child-values-via-requirements-yaml">https://docs.helm.sh/developing_charts/#importing-child-values-via-requirements-yaml</a></p><p><a href="https://docs.helm.sh/chart_template_guide/#overriding-values-from-a-parent-chart">https://docs.helm.sh/chart_template_guide/#overriding-values-from-a-parent-chart</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://helm.sh/&quot;&gt;Helm&lt;/a&gt;是kubernetes的官方包管理工具。根据官网上的描述&lt;code&gt;Helm is the best way to find, share, and use software built for Kubernetes.&lt;/code&gt;可以看出helm在kubernetes社区中的定位。&lt;/p&gt;
&lt;p&gt;这篇文章并不是helm的入门文章，而是着重于helm中的chart之间如何传递value。希望进行helm入门的同学可以参考官方文档。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes中的Network</title>
    <link href="https://www.purewhite.io/2018/01/08/kubernetes-network/"/>
    <id>https://www.purewhite.io/2018/01/08/kubernetes-network/</id>
    <published>2018-01-08T08:01:50.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes 处理网络的方式和Docker不同，主要需要解决四种问题：</p><ol><li>高度耦合的Container之间的网络通信：这个由Pod和localhost通信解决了；</li><li>Pod和Pod之间的网络通信，这个是本篇的主要内容；</li><li>Pod和Service之间的通信，这个是由Service解决的；</li><li>外部Service和内部Service之间的通信，这个也是由Service解决的。</li></ol><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Kubernetes 假设 Pod 之间可以互相通信，无论它们在哪个主机上。我们给每个Pod一个单独的IP地址，那么我们就不用专门在Pod之间创建链接，或者映射container的port到主机的port来使得外部可以访问到container了。这使得我们创建了一个非常干净，向后兼容的模型，在这个模型里面Pod可以就被当做为一个VM或者甚至一个物理机，这给了我们很多方面的方便，比如port的分配，命名，服务注册、发现，负载均衡，应用程序设置和迁移等。</p><p>为了达成这个目标，我们必须规定如何设置集群的网络。</p><h1 id="Docker的模型"><a href="#Docker的模型" class="headerlink" title="Docker的模型"></a>Docker的模型</h1><p>在讨论Kubernetes处理网络的方法之前，我们需要先复习一下Docker是如何处理网络的。在默认情况下，Docker用的是主机私有的网络，默认情况下会创建一个叫做docker0的虚拟网桥，并且分配一段子网给它。对于每个Docker创建的container，都会分配一个虚拟的附加于这个网桥的网络设备（被称为<code>veth</code>），这个<code>veth</code>其实是通过linux的namespace来映射到container里面的<code>eth0</code>的。这个容器里的<code>eth0</code>会被分配一个虚拟网桥的网段里面的IP地址。</p><p>结果就是，Docker的容器只能和在同一个机器（也就是在同一个网桥）里面的容器交流，不能和外部别的机器上的容器之间建立连接。事实上，不同机器上的容器，可能会有同样的网段和IP地址。</p><p>如果说要让Docker容器能跨Node交流，那么必须给他们分配主机上的port，并通过这个port和主机IP来唯一确定一个容器的地址，然后主机会把请求转发给container。这显然会带来很多的问题。</p><h1 id="Kubernetes的模型"><a href="#Kubernetes的模型" class="headerlink" title="Kubernetes的模型"></a>Kubernetes的模型</h1><p>在大量的开发者之间协调port的使用很明显是非常难以扩展和管理的。动态分配port又会给系统带来很大的复杂性——每一个应用程序都必须把port作为一个flag，API Server必须知道如何去把动态的port插入到配置块里面，Service必须知道如何去找到彼此，等等。与其解决这么多的问题，不如咱们自己干，重头设计。</p><p>Kubernetes规定了如下的网络实现规范（除非有意不这么做）：</p><ul><li>所有的container都可以在不使用NAT的情况下访问到任何别的container</li><li>所有的node都可以在不使用NAT的情况下访问到任何别的container（反之亦然）</li><li>每个container自己看到的自己的IP地址，和被人看到的是一样的</li></ul><p>这些要求其实就是说，你不能直接在两台机器上装上Docker，然后指望Kubernetes会工作，你必须保证这些基础要求被满足。</p><p>这个模型不止简单了很多，而且还吻合了Kubernetes对于把app从vm迁移到container的方便性要求。意思是，如果你之前的app是运行在vm里面的，那么vm和vm之间能通过IP地址互相通信是一个基本的要求。反之，放到container里面也是这样。</p><p>不过事实上，Kubernetes中并不是每一个container都会有自己的IP地址，其实Kubernetes是以Pod作为最小的分配IP地址的单位的——Pod中的container会共享同一个IP地址——也就是共享同一个network namespace。这使得所有的同一个Pod里面的container都能通过localhost直接访问到彼此。不过这个带来的问题是每个Pod里面的container需要协调好port的使用，防止冲突，但是这个和在VM里面是相同的，所以并不是什么太大的问题。我们称之为“IP-per-pod”模型。</p><p>在Docker里面，请求一个host port是可行的，但是这个模型使得操作更加简单。我们会在每个host Node上分配一个port，并把所有的traffic都转发给Pod。Pod本身并不需要知道这些，只当自己是一个vm或者甚至物理机就好了。</p><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><p>目前有很多方法能实现这个网络模型，比如说如下的这些方案：</p><h2 id="Cilium"><a href="#Cilium" class="headerlink" title="Cilium"></a>Cilium</h2><p>Cilium是一个开源的网络模型，实现了L3-L7层的安全策略，具体的可以看一下文档。</p><h2 id="Contiv"><a href="#Contiv" class="headerlink" title="Contiv"></a>Contiv</h2><p>Contiv提供了可设置的网络模型。</p><h2 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h2><p>Flannel是一个非常简单的网络层，不过很多人都说好用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实现的方案非常多，我就不一一列举了，大家可以直接去参考官方文档中的内容。</p><p>网络是个很复杂的东西，很多时候问题都会出在网络上，不同的业务模型需要使用不同的网络插件，没有万金油的解决方案。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kubernetes 处理网络的方式和Docker不同，主要需要解决四种问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高度耦合的Container之间的网络通信：这个由Pod和localhost通信解决了；&lt;/li&gt;
&lt;li&gt;Pod和Pod之间的网络通信，这个是本篇的主要内容；&lt;/li&gt;
&lt;li&gt;Pod和Service之间的通信，这个是由Service解决的；&lt;/li&gt;
&lt;li&gt;外部Service和内部Service之间的通信，这个也是由Service解决的。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 中的 ingress</title>
    <link href="https://www.purewhite.io/2017/12/28/kubernetes-ingress/"/>
    <id>https://www.purewhite.io/2017/12/28/kubernetes-ingress/</id>
    <published>2017-12-28T08:56:45.000Z</published>
    <updated>2021-12-02T12:51:07.227Z</updated>
    
    <content type="html"><![CDATA[<p>在我之前的<a href="https://purewhite.io/2017/12/23/kubernetes-service/">kubernetes中的Service</a>中，我们可以看到如何使用Service来让我们的应用可以被集群外所访问到。但是在实际使用中，仍然存在一些问题。对于我们经常用的NodePort和LoadBalancer这两个type，LoadBalancer需要底层的infra支持，并且哪怕支持了我们也不能轻易用，因为LoadBalancer资源是有限的，而且最重要的是贵，贵，贵。而对于NodePort来说，我们需要经常更新我们的proxy设置，并且追踪哪些Port被使用了，所以也是很麻烦的。</p><p>万能的程序猿总是有解决方案，ingress应运而生。</p><span id="more"></span><h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><p>通过使用Service，路由的规则是直接附属到一个特定的Service上，并且生命周期和Service一样。如果说，我们能把路由规则和应用解耦，那么我们就可以随意的去更新应用而不影响访问，或者随意的去更改路由规则了。Ingress正是做这个的。</p><p>根据Kubernetes官方文档：</p><p><code>An Ingress is a collection of rules that allow inbound connections to reach the cluster Services.</code></p><p>Ingress实际上做了一个Layer 7的HTTP load balancer，并且提供了以下功能：</p><ul><li>TLS(Transport Layer Security)</li><li>Name-based virtual hosting</li><li>Path-based routing</li><li>Custom rules</li></ul><p><img data-src="https://static.purewhite.io/images/2017-12-28-AEE4364B-EE2F-451A-8361-DF5A6AE92116.png!webp_90" alt="AEE4364B-EE2F-451A-8361-DF5A6AE92116"></p><p>通过Ingress，用户不需要直接连接到Service，用户可以直接访问到ingress的endpoint，然后通过Ingress再转发到Service。样例Ingress配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">blue.myweb.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span> </span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">blue-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">green.myweb.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">green-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>根据这个配置，用户访问blue.myweb.com和green.myweb.com将会访问到同一个ingress的endpoint，并且再被转发到blue-service和green-service中。这个就是之前说的<code>Name-based virtual hosting</code>。</p><p>我们也可以用Fan Out Ingress rules，比如我们访问myweb.com/blue和myweb.com/green，然后这些也会被转发到blue-service和green-service：</p><p><img data-src="https://static.purewhite.io/images/2017-12-28-6E68B099-8D89-40B4-9744-475C4E1E61B0.png!webp_90" alt="6E68B099-8D89-40B4-9744-475C4E1E61B0"></p><p>Ingress这个Resource其实并不做转发，而是由Ingress Controller来做的。</p><h1 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h1><p>Ingress Controller其实就是一个监听master node上API Server对Ingress Resource的改变然后改变这个Layer 7 Load Balancer的Controller。Kubernetes有好多种不同的Ingress Controllers，比如说GCE L7 Load Balancer和Nginx Ingress Controller。当然，如果我们需要的话也可以写一个自己的。</p><p>需要保证Ingress Controller被启用，Ingress才可以使用。</p><h1 id="创建一个Ingress-Resource"><a href="#创建一个Ingress-Resource" class="headerlink" title="创建一个Ingress Resource"></a>创建一个Ingress Resource</h1><p>我们可以通过<code>kubectl create</code>来创建一个ingress资源，比如假设我们有一个叫做myweb-ingress.yaml的文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">blue.myweb.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span> </span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">blue-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">green.myweb.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">green-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>我们可以通过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f myweb-ingress.yaml</span></span><br></pre></td></tr></table></figure><p>来创建这个ingress的资源。然后只要修改我们的域名dns，指向ingress的endpoint即可（在本机上可以通过修改/etc/hosts来达成目的）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我之前的&lt;a href=&quot;https://purewhite.io/2017/12/23/kubernetes-service/&quot;&gt;kubernetes中的Service&lt;/a&gt;中，我们可以看到如何使用Service来让我们的应用可以被集群外所访问到。但是在实际使用中，仍然存在一些问题。对于我们经常用的NodePort和LoadBalancer这两个type，LoadBalancer需要底层的infra支持，并且哪怕支持了我们也不能轻易用，因为LoadBalancer资源是有限的，而且最重要的是贵，贵，贵。而对于NodePort来说，我们需要经常更新我们的proxy设置，并且追踪哪些Port被使用了，所以也是很麻烦的。&lt;/p&gt;
&lt;p&gt;万能的程序猿总是有解决方案，ingress应运而生。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 中的 ConfigMap 和 Secret</title>
    <link href="https://www.purewhite.io/2017/12/28/kubernetes-configmap-and-secret/"/>
    <id>https://www.purewhite.io/2017/12/28/kubernetes-configmap-and-secret/</id>
    <published>2017-12-28T07:50:20.000Z</published>
    <updated>2021-12-02T12:51:07.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要有这俩玩意儿？"><a href="#为什么要有这俩玩意儿？" class="headerlink" title="为什么要有这俩玩意儿？"></a>为什么要有这俩玩意儿？</h1><p>我们在kubernetes上部署应用的时候，经常会需要传一些配置给我们的应用，比如数据库地址啊，用户名密码啊之类的。我们要做到这个，有好多种方案，比如：</p><ul><li>我们可以直接在打包镜像的时候写在应用配置文件里面，但是这种方式的坏处显而易见而且非常明显。</li><li>我们可以在配置文件里面通过env环境变量传入，但是这样的话我们要修改env就必须去修改yaml文件，而且需要重启所有的container才行。</li><li>我们可以在应用启动的时候去数据库或者某个特定的地方拿，没问题！但是第一，实现起来麻烦；第二，如果配置的地方变了怎么办？</li></ul><p>当然还有别的方案，但是各种方案都有各自的问题。</p><p>而且，还有一个问题就是，如果说我的一个配置，是要多个应用一起使用的，以上除了第三种方案，都没办法进行配置的共享，就是说我如果要改配置的话，那得一个一个手动改。假如我们有100个应用，就得改100份配置，以此类推……</p><p>kubernetes对这个问题提供了一个很好的解决方案，就是用<strong>ConfigMap</strong>和<strong>Secret</strong>。</p><span id="more"></span><h1 id="创建ConfigMap"><a href="#创建ConfigMap" class="headerlink" title="创建ConfigMap"></a>创建ConfigMap</h1><p>ConfigMap让我们能够从容器镜像中把配置的详细信息给解耦出来。通过ConfigMap我们能够把配置以key-value对的形式传递到container或者别的系统组件（比如Controller）里面。我们可以通过两种方式来创建ConfigMap：</p><h2 id="From-Literal-Values"><a href="#From-Literal-Values" class="headerlink" title="From Literal Values"></a>From Literal Values</h2><p>我们可以用<code>kubectl create</code>来创建一个ConfigMap，然后通过<code>kubectl get</code>来获取：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Create the ConfigMap</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create configmap my-config --from-literal=key1=value1 --from-literal=key2=value2</span></span><br><span class="line">configmap &quot;my-config&quot; created </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Get the ConfigMap Details <span class="keyword">for</span> my-config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get configmaps my-config -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  key1: value1</span><br><span class="line">  key2: value2</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: 2017-05-31T07:21:55Z</span><br><span class="line">  name: my-config</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;241345&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/default/configmaps/my-config</span><br><span class="line">  uid: d35f0a3d-45d1-11e7-9e62-080027a46057</span><br></pre></td></tr></table></figure><p><code>-o yaml</code>的作用是通过yaml的形式来返回我们所要求的配置信息。</p><h2 id="From-Configuration-File"><a href="#From-Configuration-File" class="headerlink" title="From Configuration File"></a>From Configuration File</h2><p>除了上面的方式，我们还可以直接通过配置文件来创建（好吧，虽然我感觉是同一种，只不过是放到文件里面了而已……），首先，我们得有一个配置文件，假设名字叫做<code>myconfigmap.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">customer1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">TEXT1:</span> <span class="string">Customer1_Company</span></span><br><span class="line">  <span class="attr">TEXT2:</span> <span class="string">Welcomes</span> <span class="string">You</span></span><br><span class="line">  <span class="attr">COMPANY:</span> <span class="string">Customer1</span> <span class="string">Company</span> <span class="string">Technology</span> <span class="string">Pct.</span> <span class="string">Ltd.</span></span><br></pre></td></tr></table></figure><p>然后，我们可以通过<code>kubectl create -f</code>来创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f myconfigmap.yaml</span></span><br><span class="line">configmap &quot;customer1&quot; created</span><br></pre></td></tr></table></figure><h1 id="使用ConfigMap"><a href="#使用ConfigMap" class="headerlink" title="使用ConfigMap"></a>使用ConfigMap</h1><p>我们可以有两种方法来使用ConfigMap：</p><h2 id="通过env"><a href="#通过env" class="headerlink" title="通过env"></a>通过env</h2><p>我们可以设置env从ConfigMap读取：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">....</span></span><br><span class="line"> <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rsvp-app</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">teamcloudyuga/rsvpapp</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGODB_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">mongodb</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TEXT1</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">customer1</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">TEXT1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TEXT2</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">customer1</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">TEXT2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">COMPANY</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">customer1</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">COMPANY</span></span><br><span class="line"></span><br><span class="line"><span class="string">....</span></span><br></pre></td></tr></table></figure><p>这样，我们的container就可以读取到ConfigMap里面存储的信息了。</p><p>不过一般情况下，我个人推荐使用另一种方式：</p><h2 id="通过Volume"><a href="#通过Volume" class="headerlink" title="通过Volume"></a>通过Volume</h2><p>这种方式我比较推荐，因为随着ConfigMap被修改（比如你想要更新一些设置），container里面对应的文件内容也会被修改，这样可以不用重启Container就让应用能够得到最新的配置信息。</p><p>这个内容需要一些Volume相关的知识，在此不做更多讲解，大家可以去参考<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#adding-configmap-data-to-a-volume">官方文档</a>。</p><h1 id="创建Secret"><a href="#创建Secret" class="headerlink" title="创建Secret"></a>创建Secret</h1><p>通过上面的部分，我们可以看到ConfigMap是用来做一些配置信息的，那么如果我们有一些机密信息比如说密钥、密码之类的信息，应该存在哪里呢？看到这个名字大家应该就明白了吧，kubernetes提供了Secret来存储相关的信息。</p><p>具体为什么要存在Secret里面，Secret和ConfigMap有什么区别，后面会讲到。</p><h2 id="创建Secret-1"><a href="#创建Secret-1" class="headerlink" title="创建Secret"></a>创建Secret</h2><p>我们可以通过<code>kubectl create secret</code>来通过一个文件创建一个secret，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Create a file with password</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;mysqlpassword&#x27;</span> &gt; password.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Make sure there is no trailing newline <span class="keyword">in</span> the file, after our password.</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> To remove any newline, we can use the tr <span class="built_in">command</span>:</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tr -Ccsu <span class="string">&#x27;\n&#x27;</span> &lt; password.txt &gt; .strippedpassword.txt &amp;&amp; mv .strippedpassword.txt password.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Create the Secret</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create secret generic my-password --from-file=password.txt</span></span><br><span class="line">secret &quot;my-password&quot; created</span><br></pre></td></tr></table></figure><p>我们也可以手动创建一个Secret，不过要注意，所有的secret的data都要以base64进行加密：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat password.txt | base64</span></span><br><span class="line">bXlzcWxwYXN3b3JkCg==</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and <span class="keyword">then</span> use it <span class="keyword">in</span> the configuration file:</span></span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: my-password</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  password: bXlzcWxwYXN3b3JkCg==</span><br></pre></td></tr></table></figure><h1 id="使用Secret"><a href="#使用Secret" class="headerlink" title="使用Secret"></a>使用Secret</h1><h2 id="获取Secret"><a href="#获取Secret" class="headerlink" title="获取Secret"></a>获取Secret</h2><p>我们可以通过<code>get</code>和<code>describe</code>来获取Secret，不过我们发现，<code>kubectl</code>并没有向我们返回Secret具体的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get secret my-password</span></span><br><span class="line">NAME          TYPE     DATA   AGE </span><br><span class="line">my-password   Opaque   1      8m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe secret my-password</span></span><br><span class="line">Name:          my-password</span><br><span class="line">Namespace:     default</span><br><span class="line">Labels:        &lt;none&gt;</span><br><span class="line">Annotations:   &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Type  Opaque</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">password.txt:  13 bytes</span><br></pre></td></tr></table></figure><h2 id="在Pod里面使用"><a href="#在Pod里面使用" class="headerlink" title="在Pod里面使用"></a>在Pod里面使用</h2><p>和ConfigMap一样，我们可以通过设置成env或者挂载成volume来使容器可以使用我们的secret。</p><p>具体格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.....</span></span><br><span class="line">         <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">wordpress:4.7.3-apache</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">wordpress</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">wordpress-mysql</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">my-password</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">password.txt</span></span><br><span class="line"><span class="string">.....</span></span><br></pre></td></tr></table></figure><p>关于如何在Volume中使用的还是需要自行查询文档学习。</p><h1 id="扯淡的Secret"><a href="#扯淡的Secret" class="headerlink" title="扯淡的Secret"></a>扯淡的Secret</h1><p>好了，总算正文部分完了，可以讲讲Secret和ConfigMap的关系了，以及讲讲Secret到底有多扯淡……</p><p>其实目前Secret的实现，就是ConfigMap把value用base64 encode了一下……</p><p>所以，其实不存在任何安全性……</p><p>只要decode一下就能出现原来结果，相当于明文存储……</p><p>base64这玩意儿都不能叫做加密，只能叫做编码……</p><p>所以我们都不说encrypt，而是encode和decode……</p><p>当然，k8s社区有在计划对Secret进行下一步的安全性增强，当然这是后话了……</p><p>反正目前为止，Secret基本和ConfigMap一样是明文存储……</p><p>知道有多扯淡了吧……</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么要有这俩玩意儿？&quot;&gt;&lt;a href=&quot;#为什么要有这俩玩意儿？&quot; class=&quot;headerlink&quot; title=&quot;为什么要有这俩玩意儿？&quot;&gt;&lt;/a&gt;为什么要有这俩玩意儿？&lt;/h1&gt;&lt;p&gt;我们在kubernetes上部署应用的时候，经常会需要传一些配置给我们的应用，比如数据库地址啊，用户名密码啊之类的。我们要做到这个，有好多种方案，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以直接在打包镜像的时候写在应用配置文件里面，但是这种方式的坏处显而易见而且非常明显。&lt;/li&gt;
&lt;li&gt;我们可以在配置文件里面通过env环境变量传入，但是这样的话我们要修改env就必须去修改yaml文件，而且需要重启所有的container才行。&lt;/li&gt;
&lt;li&gt;我们可以在应用启动的时候去数据库或者某个特定的地方拿，没问题！但是第一，实现起来麻烦；第二，如果配置的地方变了怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然还有别的方案，但是各种方案都有各自的问题。&lt;/p&gt;
&lt;p&gt;而且，还有一个问题就是，如果说我的一个配置，是要多个应用一起使用的，以上除了第三种方案，都没办法进行配置的共享，就是说我如果要改配置的话，那得一个一个手动改。假如我们有100个应用，就得改100份配置，以此类推……&lt;/p&gt;
&lt;p&gt;kubernetes对这个问题提供了一个很好的解决方案，就是用&lt;strong&gt;ConfigMap&lt;/strong&gt;和&lt;strong&gt;Secret&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes中的Volume</title>
    <link href="https://www.purewhite.io/2017/12/25/kubernetes-volumes/"/>
    <id>https://www.purewhite.io/2017/12/25/kubernetes-volumes/</id>
    <published>2017-12-25T03:04:48.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，容器是一个短暂的不稳定的存在（随时可能挂掉），挂掉之后里面的所有数据都没了，但是我们会有很多数据是需要一直存下来（持久化）的，那怎么办呢？思路很简单，把容器里面的数据存到一个可以持久化的地方（比如s3上）。</p><span id="more"></span><h1 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h1><p>为了解决上面这个问题，kubernetes提供了Volume。一个Volume其实就是由一个存储中间件锁支持的一个directory，具体是什么存储中间件是由Volume的类型确定的。</p><p><img data-src="https://static.purewhite.io/images/2017-12-25-A00784D4-9D6B-4091-B78E-16834F743338.png!webp_90" alt="A00784D4-9D6B-4091-B78E-16834F743338"></p><p>如上图，在k8s里面，一个Volume会attach到一个Pod上，我们之前也有说过在Pod里面网络和存储是共享的，所以这个Volume可以被Pod中所有的container所共享。一个Volume和Pod的生命周期是一样的，不过却比containers要更长，这样可以使得数据可以在容器之间共享。</p><h1 id="Volume-Types"><a href="#Volume-Types" class="headerlink" title="Volume Types"></a>Volume Types</h1><p>一个mount到Pod里面的directory是由底层的Volume Type支持的，Volume Type决定了这个directory的属性，比如大小，内容等等。下面列举一部分的Volume Type：</p><h2 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h2><p>顾名思义，这就是一个“空的”Volume。这个空的Volume会在Pod被调度到node上的时候被创建。这种类型的Volume的生命周期和Pod一样，如果Pod挂了，那么这种Volume里面的所有数据也就没了。</p><h2 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h2><p>同样顾名思义，这就是把主机上的某个path映射到pod里面，如果Pod挂了，数据还在host上，不过如果host挂了，数据也就没了。</p><h2 id="gcePersistentDisk"><a href="#gcePersistentDisk" class="headerlink" title="gcePersistentDisk"></a>gcePersistentDisk</h2><p>顾名思义，强耦合gce，不多说了。</p><h2 id="awsElasticBlockStore"><a href="#awsElasticBlockStore" class="headerlink" title="awsElasticBlockStore"></a>awsElasticBlockStore</h2><p>同上</p><h2 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h2><p>通过nfs，我们可以mount一个nfs share到pod里。</p><h2 id="iscsi"><a href="#iscsi" class="headerlink" title="iscsi"></a>iscsi</h2><p>同上</p><h2 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h2><p>我们可以用这个type来把我们放在secret里面的那些比如密码呀token呀之类的信息挂载到pod上，让应用可以使用。</p><h2 id="persistentVolumeClaim"><a href="#persistentVolumeClaim" class="headerlink" title="persistentVolumeClaim"></a>persistentVolumeClaim</h2><p>这个是最重要的一种，也是最常用的一种，我们可以把一个<code>Persistent Volume(PV)</code>挂载到Pod里面，通过<code>persistentVolumeClaim(PVC)</code>。</p><h1 id="Persistent-Volumes"><a href="#Persistent-Volumes" class="headerlink" title="Persistent Volumes"></a>Persistent Volumes</h1><p>在传统的IT环境中，一般存储是由系统管理员来管理的，终端用户只是获得如何去使用的指导，但是不用管底层到底存储是怎么管理的。</p><p>在容器世界里面，也是一样的。Kubernetes有一个叫做Persistent Volumes的子系统，管理员通过Persistent Volume API向其中添加和管理Persistent Volume，然后用户使用Persistent Volume Claim API来使用。</p><p>一个PV就是一个通过网络挂载到集群上的存储。</p><p><img data-src="https://static.purewhite.io/images/2017-12-25-73BBB017-7870-4014-88E4-67B1AE5BC73F.png!webp_90" alt="73BBB017-7870-4014-88E4-67B1AE5BC73F"></p><p>PV可以通过StorageClass这个resource被静态地创建，也可以动态地被添加。一个StorageClass包含了预定义好的创建PV的初始化器和参数。</p><p>一些支持使用PV进行管理的Volume Types是：</p><ul><li>GCEPersistentDisk</li><li>AWSElasticBlockStore</li><li>AzureFile</li><li>NFS</li><li>iSCSI</li><li>CephFS</li><li>Cinder</li><li>etc.</li></ul><h1 id="Persistent-Volume-Claims"><a href="#Persistent-Volume-Claims" class="headerlink" title="Persistent Volume Claims"></a>Persistent Volume Claims</h1><p>一个Persistent Volume Claim(PVC)就是一个用户想要使用storage的请求。用户通过指定比如大小、访问权限等来申请PV资源，当有一个合适的资源(PV)被找到的时候，就会和PVC绑定在一起：</p><p><img data-src="https://static.purewhite.io/images/2017-12-25-CD52FF8E-EFFE-4519-AAD8-073BE55E97E5.png!webp_90" alt="CD52FF8E-EFFE-4519-AAD8-073BE55E97E5"></p><p>当bind成功之后，这个PVC就可以在Pod里面使用了：</p><p><img data-src="https://static.purewhite.io/images/2017-12-25-2AECAABF-FE93-4F51-9716-CDBB334BE549.png!webp_90" alt="2AECAABF-FE93-4F51-9716-CDBB334BE549"></p><p>当一个用户结束使用之后，绑定的PV就可以被归还(release)了，就可以重新被申明(reclaimed)和使用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们都知道，容器是一个短暂的不稳定的存在（随时可能挂掉），挂掉之后里面的所有数据都没了，但是我们会有很多数据是需要一直存下来（持久化）的，那怎么办呢？思路很简单，把容器里面的数据存到一个可以持久化的地方（比如s3上）。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes中的Service</title>
    <link href="https://www.purewhite.io/2017/12/23/kubernetes-service/"/>
    <id>https://www.purewhite.io/2017/12/23/kubernetes-service/</id>
    <published>2017-12-22T16:52:22.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<p>Service 是kubernetes中一个很重要的，也是很有用的概念，我们可以通过service来将pod进行分组，并提供外网的访问endpoint。在这个过程中还有比如<code>kube-proxy</code>提供了对service的访问。</p><span id="more"></span><h1 id="Connecting-Users-to-Pods"><a href="#Connecting-Users-to-Pods" class="headerlink" title="Connecting Users to Pods"></a>Connecting Users to Pods</h1><p>如果我们要让一个用户能够使用应用程序，用户需要能访问到pod，但是pod是一个短暂存在的东西，很可能突然挂了然后重启，这时候ip地址就会改变，所以pod的ip地址并不是静态的。比如说：</p><p><img data-src="https://static.purewhite.io/images/2017-12-23-E3FACD27-1617-40FE-A1EC-2099FD6AFF35.png!webp_90" alt="E3FACD27-1617-40FE-A1EC-2099FD6AFF35"></p><p>用户在这张图里面通过ip地址访问到了4个pod，突然其中有一个pod挂了，然后controller又起了一个pod：</p><p><img data-src="https://static.purewhite.io/images/2017-12-23-BE6386EA-2846-4AD8-ACD3-80A6163AD935.png!webp_90" alt="BE6386EA-2846-4AD8-ACD3-80A6163AD935"></p><p>这时候用户就访问不到了，因为用户不知道新的ip地址是多少。</p><p>kubernetes为了解决这个问题，提供了一个高层的抽象，叫做Service。Service从逻辑上把pod进行分组，并且设置访问的策略。一般我们是通过label和selector来达到分组的目的的。</p><h1 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h1><p>比如，我们用app作为key，db和frontend作为value来区分pod：</p><p><img data-src="https://static.purewhite.io/images/2017-12-23-23B63A0F-40BC-4FF7-AAEC-4D1C11C54970.png!webp_90" alt="23B63A0F-40BC-4FF7-AAEC-4D1C11C54970"></p><p>通过selector（app=frontend和app=db），我们就可以把这些pod分为两个逻辑组了。</p><p>这个时候，我们再给这两个逻辑组加上一个名称，比如<code>frontend-svc</code>和<code>db-svc</code>，就是service了：</p><p><img data-src="https://static.purewhite.io/images/2017-12-23-F67805E2-CE2D-40A8-9CFD-DE79CFD832E4.png!webp_90" alt="F67805E2-CE2D-40A8-9CFD-DE79CFD832E4"></p><h1 id="Service对象模型"><a href="#Service对象模型" class="headerlink" title="Service对象模型"></a>Service对象模型</h1><p>一个service对象模型大致如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>在这个对象模型中，我们创建了一个叫做<code>frontend-svc</code>的Service，这个service选择了所有的<code>app=frontend</code>的pod。在默认情况下，每个service都会有一个cluster内部可以访问到的ip地址，也被称为<code>ClusterIP</code>：</p><p><img data-src="https://static.purewhite.io/images/2017-12-23-3232AECF-82CA-45DF-B971-1EB278EFD552.png!webp_90" alt="3232AECF-82CA-45DF-B971-1EB278EFD552"></p><p>用户现在可以通过service的ip地址来访问到pod了，service会负责做负载均衡。</p><p>当转发请求的时候，我们可以选择pod上的目标端口，比如在我们的例子里面，frontend-svc通过80端口来接受用户的请求，然后转发到pod的5000端口。如果目标端口没有被显式声明，那么会默认转发到service接受请求的端口（和service端口一样）。</p><p>一个pod、ip地址和目标端口的元组代表了一个service的endpoint，比如在这个例子里面，frontend-svc有3个endpoints，分别是<code>10.0.1.3:5000</code>, <code>10.0.1.4:5000</code>和<code>10.0.1.5:5000</code>。</p><h1 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h1><p>所有的worker node都有一个后台任务，叫做<code>kube-proxy</code>。这个kube-proxy会检测API Server上对于service和endpoint的新增或者移除。对于每个新的service，在每个node上，kube-proxy都会设置相应的iptables的规则来记录应该转发的地址。当一个service被删除的时候，kube-proxy会在所有的pod上移除这些iptables的规则。</p><p><img data-src="https://static.purewhite.io/images/2017-12-23-0608F78E-6A96-403A-A9E1-3095AE3625F3.png!webp_90" alt="0608F78E-6A96-403A-A9E1-3095AE3625F3"></p><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>我们已经知道，Service是和kubernetes进行沟通的主要方式，那么我们就需要有一个办法来在运行的时候能够对已有的服务进行发现。Kubernetes提供了两种方法：</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>每个pod在worker node上启动的时候，kubelet都会通过环境变量把所有目前可用的service的信息传进去。举个例子，我们有一个叫做<code>redis-master</code>的service，这个service expose了6379的端口，并且ClusterIP是172.17.0.6，那么在一个新创建的pod上，我们可以看到以下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REDIS_MASTER_SERVICE_HOST=172.17.0.6</span><br><span class="line">REDIS_MASTER_SERVICE_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT=tcp://172.17.0.6:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP=tcp://172.17.0.6:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PROTO=tcp</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_ADDR=172.17.0.6</span><br></pre></td></tr></table></figure><p>如果使用这个解决方案，我们必须非常小心启动服务的顺序，因为pod不会获得自己启动之后的service的env。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>kubernetes有一些dns的addon，这些addon会自动为所有service创建一个类似<code>my-svc.my-namespace.svc.cluster.local</code>的dns解析，并且在同一个namespace里面的service可以直接用service name进行访问。这是最为推荐的方法。</p><h1 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h1><p>当我们定义一个service的时候，我们可以选择可访问的范围，比如：</p><ul><li>是否只能在cluster内部访问</li><li>是否同时可以被cluster内部和外部访问</li><li>是否是映射到一个集群外的entity上</li></ul><p>可访问的范围由service的类型决定，service的类型可以在创建service的时候声明。</p><h3 id="ClusterIP-和-NodePort"><a href="#ClusterIP-和-NodePort" class="headerlink" title="ClusterIP 和 NodePort"></a>ClusterIP 和 NodePort</h3><p>ClusterIP是默认的service type，一个service通过ClusterIP来获取自己的Virtual IP，这个IP是用来和别的service通信的，只能在集群内部被访问。</p><p>NodePort的service type除了会创建一个ClusterIP之外，还会把所有worker node上的一个30000-32767之间的端口映射到这个service，比如假设<code>32233</code>端口映射到了<code>frontend-svc</code>，那么不管我们连接到哪个worker node，我们都会被转发到service分配的ClusterIP——172.17.0.4。</p><p>默认情况下，当expose到有一个nodeport的时候，kubernetes master会自动随机选择一个30000-32767之间的port，当然，我们自己也可以手动指定这个port。</p><p><img data-src="https://static.purewhite.io/images/2017-12-23-A943E99B-5473-4177-B8AF-543939949F0B.png!webp_90" alt="A943E99B-5473-4177-B8AF-543939949F0B"></p><p>NodePort的这个service type在我们想要让外网访问我们服务的时候非常有用，用户通过访问node上指定的port就可以访问到这个service。管理员可以在kubernetes集群外再搭一个反向代理就可以更方便地进行访问了。</p><h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><p>对于LoadBalancer这个Servicetype：</p><ul><li>NodePort和ClusterIP会被自动创建，外部的load balancer会自动路由上去</li><li>service会在一个静态的端口上被暴露</li><li>通过底层的cloud provider提供的load balancer来暴露到外网</li></ul><p><img data-src="https://static.purewhite.io/images/2017-12-23-8C099E38-B51E-4688-B693-1FF2F46FCE0B.png!webp_90" alt="8C099E38-B51E-4688-B693-1FF2F46FCE0B"></p><p>LoadBalancer这个service type只有在底层的基础架构支持了自动创建load balancer的时候kubernetes才支持，比如Google Cloud Platform和aws。</p><h3 id="ExternalIP"><a href="#ExternalIP" class="headerlink" title="ExternalIP"></a>ExternalIP</h3><p>如果一个service可以路由到一个或者多个worker node上，那么它可以被映射到一个ExternalIP地址。通过这个ExternalIP进入到集群的流量会被路由到其中一个endpoint上。</p><p><img data-src="https://static.purewhite.io/images/2017-12-23-1B599B5F-0EA5-46A5-B505-2FC2658AC55C.png!webp_90" alt="1B599B5F-0EA5-46A5-B505-2FC2658AC55C"></p><p>需要注意的是，ExternalIP并不是由k8s自动管理的，是由管理员手动设置路由到其中的一个node上的。</p><h3 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h3><p>ExternalName是一个特定的service type，这种service type没有任何的selector也没有任何声明的endpoint。当在集群中访问到这个service的时候，会返回一个外部服务的CNAME。</p><p>这个service一般是用来让一个外部的服务在集群内部可以访问到的，比如我们有一个外部服务叫做<code>my-database.example.com</code>，那么我们可以通过设置ExternalName类型的Service，让内部的其它service通过<code>my-database</code>之类的名字访问到这个服务。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Service 是kubernetes中一个很重要的，也是很有用的概念，我们可以通过service来将pod进行分组，并提供外网的访问endpoint。在这个过程中还有比如&lt;code&gt;kube-proxy&lt;/code&gt;提供了对service的访问。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Building Blocks</title>
    <link href="https://www.purewhite.io/2017/12/22/kubernetes-building-blocks/"/>
    <id>https://www.purewhite.io/2017/12/22/kubernetes-building-blocks/</id>
    <published>2017-12-22T15:44:37.000Z</published>
    <updated>2021-12-02T12:51:07.227Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes中有很多积木（Building Blocks），比如object model，pod，rs，deployment，namespace之类，这些都是kubernetes中很重要的东西。</p><span id="more"></span><h1 id="Kubernetes-Object-Model"><a href="#Kubernetes-Object-Model" class="headerlink" title="Kubernetes Object Model"></a>Kubernetes Object Model</h1><p>kubernetes有一个非常完善的对象模型，kubernetes集群可以通过这个对象模型来表现出不同的持久化的整体，比如：</p><ul><li>我们是在哪个node上运行哪个容器化的应用程序？</li><li>应用程序资源消耗</li><li>应用程序不同的策略</li></ul><p>对于每个对象，我们用<code>spec</code>这个field声明我们期望的状态，随后kubernetes会通过<code>status</code>这个field记录对象实际的状态并加以管理。随后，kubernetes的controller manager会想办法让这个对象实际的状态和我们声明期望的状态相同。</p><p>kubernetes中的例子比如：Pods，Deployments，ReplicaSets之类。</p><p>如果我们要创建一个对象，我们需要把<code>spec</code>这个field提供给API Server，这个field会描述我们期望的状态以及一些基础的信息，比如名称。创建对象的API请求必须有<code>spec</code>这个field以及其它详细信息，并且需要是JSON的格式。一般情况下，我们用yaml格式来提供一个对象的声明，kubectl会把这个声明转换成JSON格式，然后传给API Server。</p><p>下面是一个Deployment对象的例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">             <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>插播一条广告：</p><blockquote><h3 id="Apps"><a href="#Apps" class="headerlink" title="Apps"></a>Apps</h3><p>The core workloads API, which is composed of the DaemonSet, Deployment, ReplicaSet, and StatefulSet kinds, has been promoted to GA stability in the apps/v1 group version. As such, the apps/v1beta2 group version is deprecated, and all new code should use the kinds in the apps/v1 group version.</p></blockquote><p>接着说，apiVersion指定了我们调用的api的endpoint；通过kind field，我们指定了我们要创建的对象的类型；通过metadata，我们给对象附加上了最基本的信息，比如名字；你可以发现这里面有两个<code>spec</code>的field（<code>spec</code>和<code>spec.template.spec</code>），通过 <code>spec</code>，我们定义了我们对deployment的期望状态，在我们的例子中，我们想要确认，在任何时候，都有至少3个pod在运行。我们再在<code>spec.template.spec</code>里面定义我们要运行的每个pod都应该是什么状态，所以这就是为啥这里会有两个spec的原因。</p><p>一旦这个对象被创建了，kubernetes会直接给对象添加一个<code>status</code>的field，如下：</p><p><img data-src="https://static.purewhite.io/images/2017-12-22-70B197CF-63EA-401C-B029-AFC9F9271D91.png!webp_90" alt="70B197CF-63EA-401C-B029-AFC9F9271D91"></p><h1 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h1><p>Pod是kubernetes中最简单也是最小的一个对象，是kubernetes部署的一个单元，代表了应用的一个单一实例。一个Pod是一个或者多个容器的逻辑上的集合，这些容器拥有以下的特性：</p><ul><li>在同一个host上一起进行调度</li><li>共享同一个network namespace</li><li>挂载同样的external storage（volumes）</li></ul><p><img data-src="https://static.purewhite.io/images/2017-12-22-38D8B067-9AD2-4CE0-85C5-70C3D5538FB0.png!webp_90" alt="38D8B067-9AD2-4CE0-85C5-70C3D5538FB0"></p><p>Pod并非一个持久化的东西，很有可能突然挂了，并且没有能力自我修复，这就是为啥我们把它们和controller一起用，这样可以来控制pod的replica，容错，自我修复等等。比较有名的例子比如Deployments，ReplicaSets等。我们通过把Pod的定义（specification，也就是<code>spec</code>）附加到别的对象（也就是之前用的<code>template.spec</code>）来完成。</p><h1 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h1><p>Labels都是键值对，这些键值对可以被attach到kubernetes的对象上，比如Pod。Labels一般被用来组织和选择一些符合条件的对象。label不提供唯一性。</p><p><img data-src="https://static.purewhite.io/images/2017-12-22-5594660A-4922-497F-9BB6-69CDE96238B3.png!webp_90" alt="5594660A-4922-497F-9BB6-69CDE96238B3"></p><p>通过这个图片，我们可以看到我们用了两个label：<code>app</code>和<code>env</code>。基于我们的需求，我们可以给我们的pod不同的值。</p><h1 id="Label-Selectors"><a href="#Label-Selectors" class="headerlink" title="Label Selectors"></a>Label Selectors</h1><p>通过Label  Selectors，我们可以选择一系列的对象，Kubernetes支持两种Selector类型：</p><h3 id="Equality-Based-Selectors"><a href="#Equality-Based-Selectors" class="headerlink" title="Equality-Based Selectors"></a>Equality-Based Selectors</h3><p>顾名思义，这种selector通过 <code>==</code> 或者 <code>!=</code> 来进行选择，比如我们选择一个 <code>env==dev</code> 的对象，就会找出所有有env label，并且值为dev的。</p><h3 id="Set-Based-Selectors"><a href="#Set-Based-Selectors" class="headerlink" title="Set-Based Selectors"></a>Set-Based Selectors</h3><p>这种selector支持通过一系列的值来进行过滤，比如通过<code>in</code>, <code>notin</code>和<code>exist</code>。</p><p>举例：<code>env in (dev, qa)</code></p><p><img data-src="https://static.purewhite.io/images/2017-12-22-9DCAECB6-54CF-4789-94B8-4332BABE4B53.png!webp_90" alt="9DCAECB6-54CF-4789-94B8-4332BABE4B53"></p><h1 id="Replication-Controllers"><a href="#Replication-Controllers" class="headerlink" title="Replication Controllers"></a>Replication Controllers</h1><p>一个 ReplicationController（rc）是master node上Controller Manager的一部分，主要作用是保证每个pod的replica都达到了预期值。不然的话会通过杀死或者新建pod的办法来达到。不过现在已经被ReplicaSet(rs)取代了。</p><h1 id="Replica-Sets"><a href="#Replica-Sets" class="headerlink" title="Replica Sets"></a>Replica Sets</h1><p>Replica Set是下一代的Replication Controller，好处在于同时支持equality 和 set based selector（rc只支持equality-based）。目前这是唯一的区别。</p><p>Rs可以单独使用，不过一般是配合deployment一起用。Deployment会自动创建rs来管理下面的pod。</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>deployment提供了对于pod和rs的陈述性更新。DeploymentController是master node上Controller Manager的一部分，作用和Controller manager别的一样——确保当前的状态和期望的状态相同。</p><p>在下面这个例子中，我们的deployment创建了一个 rs A，然后rs A又创建了3个pod，并且在每个pod中，都有一个跑了nginx:1.7.9镜像的容器。</p><p><img data-src="https://static.purewhite.io/images/2017-12-22-1A74F83F-00D9-4954-9737-D6C1BBAE3EF3.png!webp_90" alt="1A74F83F-00D9-4954-9737-D6C1BBAE3EF3"></p><p>接下来，在下一个deployment中，我们修改了pod的template，把nginx从1.7.9升级到了1.9.1。因为我们升级了期望的状态，所以deployment会创建一个新的rs B，这个过程被称为Deployment rollout：</p><p><img data-src="https://static.purewhite.io/images/2017-12-22-D9667D97-B328-4C19-AA9F-FD9E7CDEDD65.png!webp_90" alt="D9667D97-B328-4C19-AA9F-FD9E7CDEDD65"></p><p>当rs B创建完毕的时候，deployment开始指向它：</p><p><img data-src="https://static.purewhite.io/images/2017-12-22-652F4886-8F15-4C27-9DDF-8C1DA7D1DF11.png!webp_90" alt="652F4886-8F15-4C27-9DDF-8C1DA7D1DF11"></p><p>在rs之上，deployment提供了很多特性比如recording，通过这个特性，如果说更新出错，或者更新后的应用出了bug，我们可以rollback到原先的状态。</p><h1 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h1><p>如果我们有无数个用户，我们想把这些用户组织到不同的team或者project，我们可以通过namespace把kubernetes集群分成好多个小集群。所有在namespace中创建的resources/objects都是唯一的，不会跨命名空间。</p><p>一般来说，k8s会有两个默认namespace：kube-system和default。kube-system一般会用来放一些kubernetes系统的组件，default会用来放一些属于其它namespace的对象。我们默认情况下是会连接到default命名空间。kube-public是一个特殊的namespace，可以被所有的用户读，一般用于特殊情况比如初始化一个集群。</p><p>我们可以通过使用资源配额（Resource Quotas）来限制每个命名空间的资源。</p><p>最后再插播一条广告：</p><blockquote><p><img data-src="https://static.purewhite.io/images/2017-12-22-C8E9D1AC-E8F8-4544-8DB0-F4EAA6905F56.png!webp_90" alt="C8E9D1AC-E8F8-4544-8DB0-F4EAA6905F56"></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kubernetes中有很多积木（Building Blocks），比如object model，pod，rs，deployment，namespace之类，这些都是kubernetes中很重要的东西。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes安装</title>
    <link href="https://www.purewhite.io/2017/12/22/install-kubernetes/"/>
    <id>https://www.purewhite.io/2017/12/22/install-kubernetes/</id>
    <published>2017-12-22T09:43:49.000Z</published>
    <updated>2021-12-02T12:51:07.227Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章里，会主要记录一下kubernetes安装相关的信息。</p><span id="more"></span><h1 id="Kubernetes-设置"><a href="#Kubernetes-设置" class="headerlink" title="Kubernetes 设置"></a>Kubernetes 设置</h1><p>Kubernetes可以通过不同的设置安装，比较普遍的四种安装方法如下：</p><h3 id="All-in-One-Single-Node-Installation"><a href="#All-in-One-Single-Node-Installation" class="headerlink" title="All-in-One Single-Node Installation"></a>All-in-One Single-Node Installation</h3><p>在这种模式下，所有的master和worker组件都被安装在一个node上，这对学习、开发和测试非常有用，但是不应该被用在生产环境中。minikube就是一个例子。</p><h3 id="Single-Node-etcd-Single-Master-and-Multi-Worker-Installation"><a href="#Single-Node-etcd-Single-Master-and-Multi-Worker-Installation" class="headerlink" title="Single-Node etcd, Single-Master, and Multi-Worker Installation"></a>Single-Node etcd, Single-Master, and Multi-Worker Installation</h3><p>在这种模式下，我们有一个单独的master node，在这个master node上同时也跑了一个单节点的etcd实例。多个worker node都连接到这一个master node。</p><h3 id="Single-Node-etcd-Multi-Master-and-Multi-Worker-Installation"><a href="#Single-Node-etcd-Multi-Master-and-Multi-Worker-Installation" class="headerlink" title="Single-Node etcd, Multi-Master, and Multi-Worker Installation"></a>Single-Node etcd, Multi-Master, and Multi-Worker Installation</h3><p>在这种模式下，我们有多个Master node，master node将会在HA模式下工作，但是我们只有一个单节点的etcd实例。多个的worker node都会连接到多个master node上去。</p><h3 id="Multi-Node-etcd-Multi-Master-and-Multi-Worker-Installation"><a href="#Multi-Node-etcd-Multi-Master-and-Multi-Worker-Installation" class="headerlink" title="Multi-Node etcd, Multi-Master, and Multi-Worker Installation"></a>Multi-Node etcd, Multi-Master, and Multi-Worker Installation</h3><p>在这种模式下，etcd被设置成了集群模式，并且在kubernetes集群之外。所有的Node都会连接到它上面去。所有的master node都被设置为HA模式，并且连接到所有的worker node上。Production都应该这么玩。</p><h1 id="Kubernetes需要的基础设施"><a href="#Kubernetes需要的基础设施" class="headerlink" title="Kubernetes需要的基础设施"></a>Kubernetes需要的基础设施</h1><p>当我们决定了安装的类型，我们同时需要决定一下基础架构相关的决定，比如：</p><ul><li>我们应该在裸机上安装k8s，还是在公有云，还是在私有云？</li><li>我们应该用哪种操作系统？RHEL，CoreOS，CentOS？</li><li>我们应该用哪种网络解决方案？</li><li>以及其它的。</li></ul><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><p>本地安装推荐使用 minikube。</p><h3 id="在虚拟机或者裸机上"><a href="#在虚拟机或者裸机上" class="headerlink" title="在虚拟机或者裸机上"></a>在虚拟机或者裸机上</h3><p>kubernetes都支持安装在虚拟机或者裸机上，有很多工具比如ansible和kubeadm同时支持这两种安装。</p><h3 id="安装在云上"><a href="#安装在云上" class="headerlink" title="安装在云上"></a>安装在云上</h3><p>这个就不用多说了，交保护费即可。</p><h1 id="Kubernetes安装工具"><a href="#Kubernetes安装工具" class="headerlink" title="Kubernetes安装工具"></a>Kubernetes安装工具</h1><p>目前比较有名的有三个：kubeadm, kubespray, kops。</p><p>区别在于，kubeadm支持任何环境，kubespray是基于ansible的，kops目前和aws和gce强耦合。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这篇文章里，会主要记录一下kubernetes安装相关的信息。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 架构 Overview</title>
    <link href="https://www.purewhite.io/2017/12/22/kubernetes-concepts/"/>
    <id>https://www.purewhite.io/2017/12/22/kubernetes-concepts/</id>
    <published>2017-12-22T05:51:13.000Z</published>
    <updated>2021-12-02T12:51:07.227Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在复习准备考试，于是一边复习一遍写成博客，印证自己所学。</p><span id="more"></span><h1 id="Kubernetes架构"><a href="#Kubernetes架构" class="headerlink" title="Kubernetes架构"></a>Kubernetes架构</h1><p>从高层看，kubernetes是由如下东西组成的：</p><ul><li>一个或多个master node</li><li>一个或多个worker node</li><li>一个分布式的key-value存储，比如<code>etcd</code></li></ul><p><img data-src="https://static.purewhite.io/images/2017-12-22-2FDF2789-F7EA-4EE6-8561-6FE7AD4A79D6.png!webp_90" alt="2FDF2789-F7EA-4EE6-8561-6FE7AD4A79D6"></p><h1 id="Master-Node"><a href="#Master-Node" class="headerlink" title="Master Node"></a>Master Node</h1><p>Master node 是集群管理者，我们发出的所有请求都是到master node的api server上。</p><p>一个集群可以有多个master node做HA，当有多个master node的时候，只有一个会提供服务，剩下的都是follower。</p><p>集群的状态一般存储在<code>etcd</code>里面，所有的master node都会连接到etcd。etcd是一个分布式k-v存储。etcd可以是master内部的，也可以是外部的。</p><h3 id="Master-node的组件"><a href="#Master-node的组件" class="headerlink" title="Master node的组件"></a>Master node的组件</h3><p>master node一般都有如下组件：</p><h4 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h4><p>所有的操作都是通过 API Server 去完成的。每个用户/操作者通过发送REST请求到api server，然后api server先验证然后执行这些操作。在执行完之后把集群的状态存到etcd里面。</p><h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p>顾名思义，Scheduler的作用是调度，Scheduler拥有所有worker node的资源使用情况，同时也知道用户设置的资源需求，比如说一个 <code>disk=ssd</code>的label。在调度之前，scheduler还会考虑到service requirements，data locality，affinity，anti-affinity等。scheduler负责的是service和pod的调度。</p><h4 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h4><p>简单来说，Controller Manager是负责启动和关闭pod的。Controller Manager的任务是让集群维持在期望的状态上。Controller Manager知道每个Pod的状态应该是什么样，然后会不断检测是否有不达标的pod。</p><h1 id="Worker-Node"><a href="#Worker-Node" class="headerlink" title="Worker Node"></a>Worker Node</h1><p>Worker Node就是一个被master node控制的机器，Pod一般都是调度到worker node里面的。Worker node会有一些可以运行以及连接容器的工具。Pod是kubernetes里面的调度单元，是一个或多个容器组成的通常一起调度的逻辑上的集合。</p><p><img data-src="https://static.purewhite.io/images/2017-12-22-D012D35E-5431-411E-AD4A-829A268E0875.png!webp_90" alt="D012D35E-5431-411E-AD4A-829A268E0875"></p><h3 id="Worker-Node组件"><a href="#Worker-Node组件" class="headerlink" title="Worker Node组件"></a>Worker Node组件</h3><p>一个worker node一般会有以下组件：</p><h4 id="Contrainer-Runtime"><a href="#Contrainer-Runtime" class="headerlink" title="Contrainer Runtime"></a>Contrainer Runtime</h4><p>不用多说了，运行容器必备的，默认用的是Docker</p><h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>kubelet是在每个worker node上都会运行的，用来和master node通信的。kubelet从master接收pod的定义，然后启动里面的容器，并监控容器是否一直正常运行。</p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h4><p>kube-proxy简单来说，就是对外提供代理服务的。换句话说，没有kube-proxy，我们要访问其中的application，就得直接访问到worker node上，这显然是不合理的。我们可以通过kube-proxy来做load balancer等。以前版本的Service也借助了kube-proxy。</p><h1 id="用etcd来管理状态"><a href="#用etcd来管理状态" class="headerlink" title="用etcd来管理状态"></a>用etcd来管理状态</h1><p>在kubernetes里面，都是用的etcd来管理所有的状态。除了集群的状态之外，还会用来存放一些信息，比如configmap，secret。</p><h1 id="网络需求"><a href="#网络需求" class="headerlink" title="网络需求"></a>网络需求</h1><p>为了启动一个全功能的kubernetes集群，我们需要先确认以下信息：</p><ul><li>每个Pod有唯一一个独立的IP</li><li>每个Pod里面的容器可以互相沟通</li><li>Pod之间可以互相沟通</li><li>通过设置，在Pod里面的application可以被外部访问到</li></ul><p>这些问题都是需要在部署之前被解决的。</p><p>我们一个个看：</p><h3 id="给每个Pod分配一个独立的IP"><a href="#给每个Pod分配一个独立的IP" class="headerlink" title="给每个Pod分配一个独立的IP"></a>给每个Pod分配一个独立的IP</h3><p>在kubernetes里面，每个Pod都要有一个独立的IP。一般容器网络有两种规格：</p><ul><li>Container Network Model (CNM)</li><li>Container Network Interface (CNI)</li></ul><p>Kubernetes用CNI来给Pod分配IP</p><p><img data-src="https://static.purewhite.io/images/2017-12-22-CA97E57F-D3C7-4BF0-BD0F-AB8E83838655.png!webp_90" alt="CA97E57F-D3C7-4BF0-BD0F-AB8E83838655"></p><p>简单来说，容器运行时向CNI申请IP，然后CNI通过其下面指定的plugin来获取到IP，并且返回给容器运行时。</p><h3 id="容器之间交流"><a href="#容器之间交流" class="headerlink" title="容器之间交流"></a>容器之间交流</h3><p>一般基于底层操作系统的帮助，所有的容器运行时都会给每个容器创建一个独立的隔离的网络整体。在Linux上，这个整体被称为Network Namespace，这些Network Namespace可以在容器之间共享。</p><p>在一个Pod里面，容器共享Network Namespace，所以所有在同一个Pod里面的容器可以通过localhost来互相访问。</p><h3 id="跨Node的Pod之间访问"><a href="#跨Node的Pod之间访问" class="headerlink" title="跨Node的Pod之间访问"></a>跨Node的Pod之间访问</h3><p>在一个集群的环境下，每个Pod可以被调度到任何一个Node上，我们需要让在不同机器上的Pod也可以相互通信，并且任何Node都可以访问到任何Pod。Kubernetes设定了一个条件：不能有任何的NAT转换，我们可以通过以下方式来达成：</p><ul><li>可路由（Routable）的Pod和Node，通过底层的服务，比如GCE。</li><li>通过一些软件定义的网络（Software Defined Networking），比如flannel，weave，calico等</li></ul><p>更多的信息可以看看kubernetes的官方文档。</p><h3 id="外网和集群之间的访问"><a href="#外网和集群之间的访问" class="headerlink" title="外网和集群之间的访问"></a>外网和集群之间的访问</h3><p>我们可以通过<code>kube-proxy</code>来暴露我们的service，然后就能从外面访问到我们集群里面的应用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近正在复习准备考试，于是一边复习一遍写成博客，印证自己所学。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>《Head First 设计模式》读书笔记0.5 —— 引子</title>
    <link href="https://www.purewhite.io/2017/12/21/design-pattern-opening-words/"/>
    <id>https://www.purewhite.io/2017/12/21/design-pattern-opening-words/</id>
    <published>2017-12-21T09:23:12.000Z</published>
    <updated>2021-12-02T12:51:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>为什么引子我还要写一篇文章呢？因为引子介绍了很多关于大脑认知的知识，这本书运用了其中的很多知识来写作，这也是这本书为什么如此火如此出名的原因。我认为这可能会对我工作或者学习产生帮助，所以记录下来。</p><span id="more"></span><h2 id="大脑总是渴求一些奇怪的东西"><a href="#大脑总是渴求一些奇怪的东西" class="headerlink" title="大脑总是渴求一些奇怪的东西"></a>大脑总是渴求一些<code>奇怪</code>的东西</h2><p>好吧，原文意思是，大脑总是渴求一些新奇的东西，或者不寻常的事物发生，我们的大脑不会注意一些习以为常的东西，比如我们不会注意很平常的路人，但是会注意到很多“特立独行”的人。</p><p>比如说，当你拿到一本500页的教科书，书上密密麻麻都是文字，你的大脑肯定想着“**，又是这种玩意儿，无聊……”</p><p>但是如果当你拿到一本 日本H二次元漫画，还是 时崎狂三 或者 穹妹 的这个时候你的大脑就会……</p><p>或者再举个例子，如果你就普通的在路上走，你的大脑会努力的去排除那些不重要的东西，但是如果你走着走着，突然你面前蹦出一个大老虎，你的大脑肯定一下子就情绪爆发（原文）了。</p><p>Head first系列通过一些最新的认知科学、神经生物学和教育心理学来创作，有以下一些原则：</p><ol><li>看得到。与单纯的文字相比，图片更能让人记得住，通过图片，学习效率会更高，甚至能有多达89%的提高。</li><li>采用一种针对个人式的交谈式风格。</li><li>让学习的人想得更深。</li><li>引起读者的注意，而且要让他一直保持注意。</li><li>影响读者的情绪。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么引子我还要写一篇文章呢？因为引子介绍了很多关于大脑认知的知识，这本书运用了其中的很多知识来写作，这也是这本书为什么如此火如此出名的原因。我认为这可能会对我工作或者学习产生帮助，所以记录下来。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://www.purewhite.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://www.purewhite.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用 kubeadm 创建一个 kubernetes 集群</title>
    <link href="https://www.purewhite.io/2017/12/17/use-kubeadm-setup-k8s/"/>
    <id>https://www.purewhite.io/2017/12/17/use-kubeadm-setup-k8s/</id>
    <published>2017-12-17T09:22:34.000Z</published>
    <updated>2021-12-02T12:51:07.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>kubeadm</code>是一个<code>kubernetes</code>官方提供的快速安装和初始化拥有<strong>最佳实践（best practice）</strong>的<code>kubernetes</code>集群的工具，虽然目前还处于 beta 和 alpha 状态，还不能用在生产环境，但是我们可以通过学习这种部署方法来体会一些官方推荐的kubernetes最佳实践的设计和思想。</p><span id="more"></span><p><code>kubeadm</code>的目标是提供一个最小可用的可以通过<code>Kubernetes一致性测试</code>的集群，所以并不会安装任何除此之外的非必须的addon。</p><p><code>kubeadm</code>默认情况下并不会安装一个网络解决方案，所以用<code>kubeadm</code>安装完之后 需要自己来安装一个网络的插件。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p><code>kubeadm</code>支持多种系统，这里简单介绍一下需要的系统要求：</p><ol><li>Ubuntu16.04+ / Debian 9 / CentOS 7 / RHEL 7 / Fedora 25/26(best-effort) / HypriotOS v1.0.1+ / Other</li><li>2GB或者以上的RAM（否则将没有足够空间留给app）</li><li>2核以上CPU</li><li>集群的机器之间必须能通过网络互相通信</li><li><strong><u>SWAP必须被关闭，否则<code>kubelet</code>会出错！</u></strong></li></ol><p>具体的详细信息可以在官方网站上看到。</p><p>本篇内容基于aws的ap-northeast-1的ec2，<code>CentOS 7 </code>的操作系统（ami-4dd5522b），实例类型t2.medium 2核4GB，3台机器，1 master，2 nodes，kubernetes 1.9 版本。为了方便起见，在安全组里面打开了所有的端口和IP访问。</p><p>机器配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[centos@ip-172-31-24-49 ~]$ uname -a</span><br><span class="line">Linux ip-172-31-24-49.ap-northeast-1.compute.internal 3.10.0-693.5.2.el7.x86_64 #1 SMP Fri Oct 20 20:32:50 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>首先 ，我们关闭selinux：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysconfig/selinux</span></span><br></pre></td></tr></table></figure><p><img data-src="https://static.purewhite.io/images/2017-12-17-91C23F22-58A4-4F03-842F-97018D78F9D8.png!webp_90" alt="91C23F22-58A4-4F03-842F-97018D78F9D8"></p><p>把SELINUX改成disabled，然后保存退出。</p><p>在我用的ami中，swap是默认关闭的，所以不需要我手动关闭，大家需要确认 自己的环境中swap是否有关闭掉，否则会在之后的环节中出问题。</p><p>为了方便我们安装，我们将sshd设置为keepalive：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo -i</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;ClientAliveInterval 10&quot;</span> &gt;&gt; /etc/ssh/sshd_config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;TCPKeepAlive yes&quot;</span> &gt;&gt; /etc/ssh/sshd_config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl restart sshd.service</span></span><br></pre></td></tr></table></figure><p>接下来我们重启一下机器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo reboot</span></span><br></pre></td></tr></table></figure><p>至此，准备阶段结束。</p><h2 id="安装kubeadm"><a href="#安装kubeadm" class="headerlink" title="安装kubeadm"></a>安装kubeadm</h2><p>首先，我们需要在所有机器上都安装<code>docker</code>, <code>kubeadm</code>, <code>kubelet</code>和<code>kubectl</code>。</p><p>切记：**<code>kubeadm</code>不会自动去安装和管理 <code>kubelet</code>和<code>kubectl</code>，所以需要自己去确保安装的版本和你想要安装的<code>kubernetes</code>版本相同。**</p><p>安装<code>docker</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker &amp;&amp; sudo systemctl start docker</span></span><br></pre></td></tr></table></figure><p>在RHEL/CentOS 7 系统上可能会路由失败，我们需要设置一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo -i</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;<span class="string">EOF &gt;  /etc/sysctl.d/k8s.conf</span></span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="string"> sudo sysctl --system</span></span></span><br></pre></td></tr></table></figure><p>接下来我们需要安装<code>kubeadm</code>, <code>kubelet</code>和<code>kubectl</code>了，我们需要先加一个repo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y kubelet kubeadm kubectl</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> kubelet &amp;&amp; sudo systemctl start kubelet</span></span><br></pre></td></tr></table></figure><p>至此，在所有机器上安装所需的软件已经结束。</p><h2 id="使用kubeadm初始化master"><a href="#使用kubeadm初始化master" class="headerlink" title="使用kubeadm初始化master"></a>使用kubeadm初始化master</h2><p>安装完所有的依赖之后，我们就可以用<code>kubeadm</code>初始化master了。</p><p>最简单的初始化方法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubeadm init</span></span><br></pre></td></tr></table></figure><p>除此之外，<code>kubeadm</code>还支持多种方法来配置，具体可以查看一下官方文档。</p><p>我们在初始化的时候指定一下kubernetes版本，并设置一下pod-network-cidr（后面的flannel会用到）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo -i</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubeadm init --kubernetes-version=v1.9.0 --pod-network-cidr=10.244.0.0/16</span></span><br></pre></td></tr></table></figure><p>在这个过程中<code>kubeadm</code>执行了一系列的操作，包括一些pre-check，生成ca证书，安装etcd和其它控制组件等。</p><p>界面差不多如下：</p><p><img data-src="https://static.purewhite.io/images/2017-12-17-2256534A-2144-4118-843C-7179EF34EC49.png!webp_90" alt="2256534A-2144-4118-843C-7179EF34EC49"></p><p>最下面的这行<code>kubeadm join</code>什么的，就是用来让别的node加入集群的，可以看出非常方便。我们要保存好这一行东西，这是我们之后让node加入集群的凭据，一会儿会用到。</p><p>这个时候，我们还不能通过<code>kubectl</code>来控制集群，要让<code>kubectl</code>可用，我们需要做：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对于非root用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$HOME</span>/.kube</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于root用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以直接放到~/.bash_profile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;export KUBECONFIG=/etc/kubernetes/admin.conf&quot;</span> &gt;&gt; ~/.bash_profile</span></span><br></pre></td></tr></table></figure><p>接下来要注意，我们<strong>必须</strong>自己来安装一个network  addon。</p><p><strong><u>network addon必须在任何app部署之前安装好。同样的，<code>kube-dns</code>也会在network addon安装好之后才启动。<code>kubeadm</code>只支持CNI-based networks（不支持<code>kubenet</code>）。</u></strong></p><p>比较常见的network addon有：<code>Calico</code>, <code>Canal</code>, <code>Flannel</code>, <code>Kube-router</code>, <code>Romana</code>, <code>Weave Net</code>等。这里我们使用<code>Flannel</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</span></span><br></pre></td></tr></table></figure><p>安装完network之后，你可以通过<code>kubectl get pods --all-namespaces</code>来查看<code>kube-dns</code>是否在running来判断network是否安装成功。</p><p>默认情况下，为了保证master的安全，master是不会被调度到app的。你可以取消这个限制通过输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl taint nodes --all node-role.kubernetes.io/master-</span></span><br></pre></td></tr></table></figure><h2 id="加入nodes"><a href="#加入nodes" class="headerlink" title="加入nodes"></a>加入nodes</h2><p>终于部署完了我们的master！</p><p>现在我们开始加入一些node到我们的集群里面吧！</p><p>ssh到我们的node节点上，执行刚才下面给出的那个 <code>kubeadm join</code>的命令（每个人不同）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo -i</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubeadm join --token 72a8a4.2ed9076cd668b8b7 172.31.31.60:6443 --discovery-token-ca-cert-hash sha256:f0894e55d475f882dd40d52c6d01f758017ec5729be632294049f687330f60d2</span></span><br></pre></td></tr></table></figure><p>输出差不多如下图：</p><p><img data-src="https://static.purewhite.io/images/2017-12-17-1E93FFDE-F0FE-4C7B-9207-6B8DF3EE7787.png!webp_90" alt="1E93FFDE-F0FE-4C7B-9207-6B8DF3EE7787"></p><p>这时候，我们去master上输入<code>kubectl get nodes</code>查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@i-071abd86ed304dc84 ~]# kubectl get nodes</span><br><span class="line">NAME                  STATUS    ROLES     AGE       VERSION</span><br><span class="line">i-071abd86ed304dc84   Ready     master    12m       v1.9.0</span><br><span class="line">i-0c559ad3c0b16fd36   Ready     &lt;none&gt;    1m        v1.9.0</span><br><span class="line">i-0f3f7462b0a004b5e   Ready     &lt;none&gt;    47s       v1.9.0</span><br></pre></td></tr></table></figure><p>成功！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以看到，用<code>kubeadm</code>部署可以让我们比手动部署方便得多，虽然比不上<code>kops</code>这样的一键部署生产Kubernetes集群的工具，但是<code>kubeadm</code>最初的设计也并非是傻瓜式使用。</p><p><code>kubeadm</code>给了用户很多的灵活性，让用户可以完全自定义地去配置自己的集群。</p><p>不过目前（截止博客发布为止），<code>kubeadm</code>还只是在测试，官方还不建议在生产环境中使用，不过预计会在2018年春季可以投入生产使用。</p><p>最后，我们总结一下<code>kubeadm</code>最核心的几个概念：</p><ul><li>官方认为的 最佳实践（best-practice）</li><li>合理的安全（reasonably secure）</li><li>可扩展（extensible）</li><li>最小可用（minimum viable）</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kubeadm&lt;/code&gt;是一个&lt;code&gt;kubernetes&lt;/code&gt;官方提供的快速安装和初始化拥有&lt;strong&gt;最佳实践（best practice）&lt;/strong&gt;的&lt;code&gt;kubernetes&lt;/code&gt;集群的工具，虽然目前还处于 beta 和 alpha 状态，还不能用在生产环境，但是我们可以通过学习这种部署方法来体会一些官方推荐的kubernetes最佳实践的设计和思想。&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://www.purewhite.io/categories/kubernetes/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="运维" scheme="https://www.purewhite.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="kubernetes" scheme="https://www.purewhite.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>CAS认证</title>
    <link href="https://www.purewhite.io/2017/12/14/cas-authentication/"/>
    <id>https://www.purewhite.io/2017/12/14/cas-authentication/</id>
    <published>2017-12-14T01:51:49.000Z</published>
    <updated>2021-12-02T12:51:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>工作需要学习CAS，所以边学边写博客来印证自己所学。</p><p>CAS——Central Authentication Service，集中式认证服务，顾名思义就是把一个网站群的用户认证挪到同一个地方去进行。</p><span id="more"></span><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>CAS架构如下图：</p><p><img data-src="https://static.purewhite.io/images/2017-12-14-cas_architecture.png!webp_50" alt="cas_architecture"></p><p>可以看出来，CAS主要是用在网站群里面。想想也是，如果有好多个网站都需要用户认证，不可能每个网站自己维护一套用户认证系统，不然维护和开发起来不是太麻烦了，所以需要把用户认证挪到同一个地方去集中地进行，这就是CAS的思想。</p><p>CAS服务器和App服务器通过协议进行交互，其实也就是相当于我们经常说的“解耦”，把用户认证的体系给单独剥离出来，使得用户认证体系可以在所有网站中复用。这么说来还有点微服务的意思？其实很多想法都是殊途同归的。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img data-src="https://static.purewhite.io/images/2017-12-14-cas_flow_diagram.png!webp_50" alt="cas_flow_diagram"></p><p>这是CAS主要的流程，简单来说就是在访问服务器的时候，如果发现没有session，就去CAS Server验证一下，CAS的TGT是为了不让用户重复登录的一个ticket。</p><p>CAS Server验证完了身份，就给一个ST，让用户拿给app，app用ST去CAS Server获取到用户的信息，于是创建session。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作需要学习CAS，所以边学边写博客来印证自己所学。&lt;/p&gt;
&lt;p&gt;CAS——Central Authentication Service，集中式认证服务，顾名思义就是把一个网站群的用户认证挪到同一个地方去进行。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.purewhite.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>《Head First 设计模式》读书笔记0 —— 总览</title>
    <link href="https://www.purewhite.io/2017/12/11/design-pattern-overview/"/>
    <id>https://www.purewhite.io/2017/12/11/design-pattern-overview/</id>
    <published>2017-12-11T11:56:07.000Z</published>
    <updated>2021-12-02T12:51:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>开始看《Head First 设计模式》，接下来（可能）会写一系列的博客关于设计模式，先在这里挖个坑。。。</p><span id="more"></span><h2 id="为什么要学设计模式"><a href="#为什么要学设计模式" class="headerlink" title="为什么要学设计模式"></a>为什么要学设计模式</h2><p>因为<strong>有些人已经解决你的问题了</strong>。你的问题别人已经遇到过了，也解决了，我们应该学习别人的经验并进行复用。</p><p>设计模式大都是一些良好的OO实践，其中能反映出很多OO的设计原则。</p><p>使用模式最好的方法是：“<strong>把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们</strong>。”</p><h2 id="大致有哪些设计模式"><a href="#大致有哪些设计模式" class="headerlink" title="大致有哪些设计模式"></a>大致有哪些设计模式</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="让你的对象知悉现状"><a href="#让你的对象知悉现状" class="headerlink" title="让你的对象知悉现状"></a>让你的对象知悉现状</h4><p><strong>有趣的事情发生时，可千万别错过了！</strong></p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><h4 id="装饰对象"><a href="#装饰对象" class="headerlink" title="装饰对象"></a>装饰对象</h4><p><strong>给爱用继承的人一个全新的设计眼界</strong></p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="烘烤OO的精华"><a href="#烘烤OO的精华" class="headerlink" title="烘烤OO的精华"></a>烘烤OO的精华</h4><p><strong>装备好开始烘烤某些松耦合的OO设计。</strong></p><h3 id="单实例模式"><a href="#单实例模式" class="headerlink" title="单实例模式"></a>单实例模式</h3><h4 id="独一无二的对象"><a href="#独一无二的对象" class="headerlink" title="独一无二的对象"></a>独一无二的对象</h4><p><strong>单实例模式：用来创建独一无二的，只能有一个实例的对象的入场券。</strong></p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="封装调用"><a href="#封装调用" class="headerlink" title="封装调用"></a>封装调用</h4><p><strong>把封装带到一个全新的境界：把方法调用封装起来。</strong></p><h3 id="适配器模式与外观模式"><a href="#适配器模式与外观模式" class="headerlink" title="适配器模式与外观模式"></a>适配器模式与外观模式</h3><h4 id="随遇而安"><a href="#随遇而安" class="headerlink" title="随遇而安"></a>随遇而安</h4><p><strong>把方块放进圆洞中。</strong></p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><h4 id="封装算法"><a href="#封装算法" class="headerlink" title="封装算法"></a>封装算法</h4><p><strong>封装完对象……接下来呢？</strong></p><h3 id="迭代器与组合模式"><a href="#迭代器与组合模式" class="headerlink" title="迭代器与组合模式"></a>迭代器与组合模式</h3><h4 id="管理良好的集合"><a href="#管理良好的集合" class="headerlink" title="管理良好的集合"></a>管理良好的集合</h4><p><strong>有许多种方法可以把对象堆起来成为一个集合。</strong></p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><h4 id="事物的状态"><a href="#事物的状态" class="headerlink" title="事物的状态"></a>事物的状态</h4><p><strong>基本常识：策略模式和状态模式是双胞胎，在出生时才分开。</strong></p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="控制对象访问"><a href="#控制对象访问" class="headerlink" title="控制对象访问"></a>控制对象访问</h4><p><strong>玩过扮白脸、扮黑脸的游戏吗？</strong></p><h3 id="复合模式"><a href="#复合模式" class="headerlink" title="复合模式"></a>复合模式</h3><h4 id="模式中的模式"><a href="#模式中的模式" class="headerlink" title="模式中的模式"></a>模式中的模式</h4><p><strong>谁料得到模式居然可以携手合作？</strong></p><h2 id="与设计模式相处"><a href="#与设计模式相处" class="headerlink" title="与设计模式相处"></a>与设计模式相处</h2><h3 id="真实世界中的模式"><a href="#真实世界中的模式" class="headerlink" title="真实世界中的模式"></a>真实世界中的模式</h3><p><strong>现在你已经准备好迎接一个充满设计模式的崭新世界。</strong></p><h2 id="其它设计模式"><a href="#其它设计模式" class="headerlink" title="其它设计模式"></a>其它设计模式</h2><p>略……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始看《Head First 设计模式》，接下来（可能）会写一系列的博客关于设计模式，先在这里挖个坑。。。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://www.purewhite.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://www.purewhite.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>如何在Mac上卸载Python</title>
    <link href="https://www.purewhite.io/2017/05/21/how-to-delete-python-on-mac/"/>
    <id>https://www.purewhite.io/2017/05/21/how-to-delete-python-on-mac/</id>
    <published>2017-05-21T09:47:46.000Z</published>
    <updated>2021-12-02T12:51:07.227Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Remove the Python 2.7 framework</p><p><code>sudo rm -rf /Library/Frameworks/Python.framework/Versions/2.7</code></p></li><li><p>Remove the Python 2.7 applications directory</p><p><code>sudo rm -rf &quot;/Applications/Python 2.7&quot;</code></p></li><li><p>Remove the symbolic links in <code>/usr/local/bin</code> that point to this Python version see <code>ls -l /usr/local/bin | grep &#39;../Library/Frameworks/Python.framework/Versions/2.7&#39;</code> and then run the following command to remove all the links:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">ls -l /usr/<span class="built_in">local</span>/bin | grep <span class="string">&#x27;../Library/Frameworks/Python.framework/Versions/2.7&#x27;</span> | awk <span class="string">&#x27;&#123;print $9&#125;&#x27;</span> | tr -d @ | xargs rm</span><br></pre></td></tr></table></figure></li><li><p>If necessary, edit your shell profile file(s) to remove adding <code>/Library/Frameworks/Python.framework/Versions/2.7</code> to your <code>PATH</code> environment file. Depending on which shell you use, any of the following files may have been modified: <code>~/.bash_login</code>, <code>~/.bash_profile</code>, <code>~/.cshrc</code>, <code>~/.profile</code>, <code>~/.tcshrc</code>, and/or <code>~/.zprofile</code>.</p></li></ol><span id="more"></span><p>转自：<a href="http://stackoverflow.com/questions/3819449/how-to-uninstall-python-2-7-on-a-mac-os-x-10-6-4">How to uninstall Python 2.7 on a Mac OS X 10.6.4?</a></p>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Remove the Python 2.7 framework&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo rm -rf /Library/Frameworks/Python.framework/Versions/2.7&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Remove the Python 2.7 applications directory&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo rm -rf &amp;quot;/Applications/Python 2.7&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Remove the symbolic links in &lt;code&gt;/usr/local/bin&lt;/code&gt; that point to this Python version see &lt;code&gt;ls -l /usr/local/bin | grep &amp;#39;../Library/Frameworks/Python.framework/Versions/2.7&amp;#39;&lt;/code&gt; and then run the following command to remove all the links:&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/bin/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls -l /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/bin | grep &lt;span class=&quot;string&quot;&gt;&amp;#x27;../Library/Frameworks/Python.framework/Versions/2.7&amp;#x27;&lt;/span&gt; | awk &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#123;print $9&amp;#125;&amp;#x27;&lt;/span&gt; | tr -d @ | xargs rm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If necessary, edit your shell profile file(s) to remove adding &lt;code&gt;/Library/Frameworks/Python.framework/Versions/2.7&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; environment file. Depending on which shell you use, any of the following files may have been modified: &lt;code&gt;~/.bash_login&lt;/code&gt;, &lt;code&gt;~/.bash_profile&lt;/code&gt;, &lt;code&gt;~/.cshrc&lt;/code&gt;, &lt;code&gt;~/.profile&lt;/code&gt;, &lt;code&gt;~/.tcshrc&lt;/code&gt;, and/or &lt;code&gt;~/.zprofile&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.purewhite.io/categories/python/"/>
    
    
    <category term="mac" scheme="https://www.purewhite.io/tags/mac/"/>
    
    <category term="python" scheme="https://www.purewhite.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>MySql存储引擎的比较</title>
    <link href="https://www.purewhite.io/2017/05/20/mysql-engines-compare/"/>
    <id>https://www.purewhite.io/2017/05/20/mysql-engines-compare/</id>
    <published>2017-05-19T16:44:21.000Z</published>
    <updated>2021-12-02T12:51:07.229Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，MySql提供了很多存储引擎，这里来比较一下常见引擎的优劣。</p><h2 id="查看所有存储引擎"><a href="#查看所有存储引擎" class="headerlink" title="查看所有存储引擎"></a>查看所有存储引擎</h2><p>我们可以通过<code>show engines</code>命令来看到我们的mysql server提供了哪些引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a>InnoDB 存储引擎</h2><p>InnoDB是事务性数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL5.5.5之后，InnoDB作为默认存储引擎。InnoDB主要特性有：</p><ol><li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表与其他MySQL的表的类型混合起来，甚至在同一个查询中也可以混合。</li><li>InnoDB是为处理巨大数据量所设计的性能为重的，它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。</li><li>InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎在主内存中维持了自己的缓冲池来缓存数据和索引。InnoDB将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制在2GB的操作系统上。</li><li>InnoDB支持外键完整性约束（FOREIGN KEY）。存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显式在表定义时制定主键，InnoDB会为每一行生成一个6B的ROWID，并以此作为主键。</li><li>InnoDB被用在众多需要高性能的大型数据库站点上。</li><li>InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件。</li></ol><h2 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h2><p>MyISAM是基于ISAM的存储引擎，并对其进行扩展。它是在Web、数据存储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务。在MySQL5.5.5之前的版本中，MyISAM是默认存储引擎。MyISAM主要特性有：</p><ol><li>大文件（达63位文件长度）在支持大文件的文件系统和操作系统上被支持。</li><li>当把删除、更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块来自动完成。</li><li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16个。</li><li>最大的键长度是1000B，这也可以通过编译来改变。对于键长度超过250B的情况，一个超过1024B的键将被用上。</li><li>BLOB和TEXT列可以被索引。</li><li>NULL值被允许在索引的列中。这个值占每个键的0-1个字节。</li><li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩。</li><li>每表一个AUTO_INCREMENT列的内部处理。MyISAM为INSERT和UPDATE操作自动更新这一列。这使得AUTO_INCREMENT列更快（至少10%）。在序列项的值被删除之后就不能再利用。</li><li>可以把数据文件和索引文件放在不同目录。</li><li>每个字符列可以有不同的字符集。</li><li>有VARCHAR的表可以固定或动态记录长度。</li><li>VARCHAR和CHAR列可以多达64KB。</li><li>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表的名字开始，扩展名代表了文件的类型：frm文件存储表定义，myd代表数据文件，myi代表索引文件。</li></ol><h2 id="MEMORY-存储引擎"><a href="#MEMORY-存储引擎" class="headerlink" title="MEMORY 存储引擎"></a>MEMORY 存储引擎</h2><p>MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。MEMORY主要特性有：</p><ol><li>MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500B的最大键长度。</li><li>MEMORY存储引擎执行HASH 和 BTREE索引。</li><li>可以在一个MEMORY表中有非唯一键。</li><li>MEMORY表使用一个固定的记录长度格式。</li><li>MEMORY不支持BLOG或TEXT列。</li><li>MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引。</li><li>MEMORY表在所有客户端之间共享（就像其他任何非TEMPORARY表）。</li><li>MEMORY表内容被存在内存中，内存是MEMORY表和服务器在查询处理时的空闲中创建的内部表共享的。</li><li>当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（用DROP TABLE）。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，MySql提供了很多存储引擎，这里来比较一下常见引擎的优劣。&lt;/p&gt;
&lt;h2 id=&quot;查看所有存储引擎&quot;&gt;&lt;a href=&quot;#查看所有存储引擎&quot; class=&quot;headerlink&quot; title=&quot;查看所有存储引擎&quot;&gt;&lt;/a&gt;查看所有存储引擎&lt;/h2&gt;&lt;p&gt;我们可以通过&lt;code&gt;show engines&lt;/code&gt;命令来看到我们的mysql server提供了哪些引擎：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;show engines;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9 rows in set (0.00 sec)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="mysql" scheme="https://www.purewhite.io/categories/mysql/"/>
    
    
    <category term="架构" scheme="https://www.purewhite.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="mysql" scheme="https://www.purewhite.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何选择开源协议</title>
    <link href="https://www.purewhite.io/2017/05/16/how-to-choose-free-software-licenses/"/>
    <id>https://www.purewhite.io/2017/05/16/how-to-choose-free-software-licenses/</id>
    <published>2017-05-16T04:13:31.000Z</published>
    <updated>2021-12-02T12:51:07.226Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://static.purewhite.io/images/2017-12-11-free_software_licenses.png!webp_90" alt="free_software_licenses"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://static.purewhite.io/images/2017-12-11-free_software_licenses.png!webp_90&quot; alt=&quot;free_software_licenses&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="随笔" scheme="https://www.purewhite.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.purewhite.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="开源" scheme="https://www.purewhite.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译Go程序</title>
    <link href="https://www.purewhite.io/2017/05/12/go-cross-compile/"/>
    <id>https://www.purewhite.io/2017/05/12/go-cross-compile/</id>
    <published>2017-05-12T14:08:45.000Z</published>
    <updated>2021-12-02T12:51:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>你只需设置 <strong>GOOS</strong> 和 **GOARCH **两个环境变量就能生成所需平台的Go程序。</p><p>比如使用下面的代码测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;OS: %s\nArchitecture: %s\n&quot;</span>, runtime.GOOS, runtime.GOARCH)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译它： <code>$ GOOS=darwin GOARCH=386 go build test.go</code><br>就可以生成运行在<code>OS X</code>上的程序。</p><span id="more"></span><p>可用的OS和ARCH的值如下：</p><table><thead><tr><th></th><th><code>$GOOS</code></th><th><code>$GOARCH</code></th></tr></thead><tbody><tr><td></td><td><code>darwin</code></td><td><code>386</code></td></tr><tr><td></td><td><code>darwin</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>darwin</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>darwin</code></td><td><code>arm64</code></td></tr><tr><td></td><td><code>dragonfly</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>freebsd</code></td><td><code>386</code></td></tr><tr><td></td><td><code>freebsd</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>freebsd</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>386</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>arm64</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>ppc64</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>ppc64le</code></td></tr><tr><td></td><td><code>netbsd</code></td><td><code>386</code></td></tr><tr><td></td><td><code>netbsd</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>netbsd</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>openbsd</code></td><td><code>386</code></td></tr><tr><td></td><td><code>openbsd</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>openbsd</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>plan9</code></td><td><code>386</code></td></tr><tr><td></td><td><code>plan9</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>solaris</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>windows</code></td><td><code>386</code></td></tr><tr><td></td><td><code>windows</code></td><td><code>amd64</code></td></tr></tbody></table><p>不同的操作系统下的库可能有不同的实现， 比如<a href="https://golang.org/src/syscall/">syscall</a>库。go build没有内置的<code>#define</code>或者预处理器之类的处理平台相关的代码取舍， 而是采用tag和文件后缀的方式实现。<br><strong>tag方式</strong><br>tag遵循一下规则</p><ol><li>a build tag is evaluated as the OR of space-separated options</li><li>each option evaluates as the AND of its comma-separated terms</li><li>each term is an alphanumeric word or, preceded by !, its negation</li></ol><p>在文件的头部增加tag:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> +build darwin freebsd netbsd openbsd</span><br></pre></td></tr></table></figure><p>可以有多个tag,之间是<strong>AND</strong>的关系</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> +build linux darwin</span><br><span class="line"><span class="regexp">//</span> +build <span class="number">386</span></span><br></pre></td></tr></table></figure><p>注意tag和package中间需要有空行分隔，下面的例子是不对的:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> +build !linux</span><br><span class="line">package mypkg <span class="regexp">//</span> wrong</span><br></pre></td></tr></table></figure><p><strong>文件后缀方式</strong><br>以*_$GOOS.go*为后缀的文件只在此平台上编译，其它平台上编译时就当此文件不存在。完整的后缀如：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_$GOOS_$GOARCH.go</span><br></pre></td></tr></table></figure><p>如syscall_linux_amd64.go,syscall_windows_386.go,syscall_windows.go等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你只需设置 &lt;strong&gt;GOOS&lt;/strong&gt; 和 **GOARCH **两个环境变量就能生成所需平台的Go程序。&lt;/p&gt;
&lt;p&gt;比如使用下面的代码测试：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;runtime&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&lt;span class=&quot;string&quot;&gt;&amp;quot;OS: %s\nArchitecture: %s\n&amp;quot;&lt;/span&gt;, runtime.GOOS, runtime.GOARCH)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;编译它： &lt;code&gt;$ GOOS=darwin GOARCH=386 go build test.go&lt;/code&gt;&lt;br&gt;就可以生成运行在&lt;code&gt;OS X&lt;/code&gt;上的程序。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.purewhite.io/categories/go/"/>
    
    
    <category term="go" scheme="https://www.purewhite.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>在debian8 jessie上安装openjdk-8-jre-headless 或者 oracle-java8-install</title>
    <link href="https://www.purewhite.io/2017/05/10/install-openjdk-8-jre-headless-on-debian-jessie/"/>
    <id>https://www.purewhite.io/2017/05/10/install-openjdk-8-jre-headless-on-debian-jessie/</id>
    <published>2017-05-09T18:33:43.000Z</published>
    <updated>2021-12-02T12:51:07.227Z</updated>
    
    <content type="html"><![CDATA[<p>最近在折腾docker，写Dockerfile的时候需要在jessie里面安装openjdk-8-jre，一直失败，网上搜罗了一圈，尝试了N种方法终于有一个work的，记录下来。</p><span id="more"></span><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://http.debian.net/debian jessie-backports main&quot;</span> &gt; /etc/apt/sources.list.d/jessie-backports.list</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y -t jessie-backports openjdk-8-jre-headless ca-certificates-java</span><br></pre></td></tr></table></figure><p>这样就OK啦！</p><p>如果需要装oracle java并自动选择同意的话：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> oracle-java8-installer shared/accepted-oracle-license-v1-1 select <span class="literal">true</span> | sudo /usr/bin/debconf-set-selections</span><br><span class="line">apt-get install -y oracle-java8-installer</span><br></pre></td></tr></table></figure><p>就可以了！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在折腾docker，写Dockerfile的时候需要在jessie里面安装openjdk-8-jre，一直失败，网上搜罗了一圈，尝试了N种方法终于有一个work的，记录下来。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://www.purewhite.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>将Django从1.7升级到1.8小计</title>
    <link href="https://www.purewhite.io/2017/05/08/upgrade-django-from-1-7-to-1-8/"/>
    <id>https://www.purewhite.io/2017/05/08/upgrade-django-from-1-7-to-1-8/</id>
    <published>2017-05-07T22:12:27.000Z</published>
    <updated>2021-12-02T12:51:07.230Z</updated>
    
    <content type="html"><![CDATA[<p>之前在项目中将Django从1.7升级到1.8，现在想起来记录一下相关的步骤和过程。</p><p>由于项目一开始用的是1.6，所以用<code>python manage.py startapp</code>默认没有migrations这个package，而之前又有一些model是使用syncdb的，并且之后再没修改过，所以在用1.7的时候一直都没什么问题，而且1.7会自动去侦测没有makemigrations的model并自动migrate，导致了在升级1.8的过程中出现了一些小插曲，这里来记录一下。</p><span id="more"></span><p>1.7和1.8在migrate时的顺序不同（具体可以看一下源代码），所以导致了1.7能正常migrate，但是在1.8的时候会报错ColoumDoesNotExist，解决方案是看看报错信息中到底说的是哪个表没有渲染成功。我们只要先给这个app makemigrations就可以了，如果还出错的话就追根溯源到第一个报错的表，然后按顺序一个一个去makemigrations即可。</p><p>解决了migrations的差异之后，1.7和1.8基本是完全兼容的，别的都不需要进行修改。不过升级到1.8之后就算在debug模式下<code>127.0.0.1</code>默认也不在<code>settings</code>中的<code>ALLOWED_HOSTS</code>中了，所以需要添加进去才能在本地访问。</p><p>还有就是1.8用了新的TEMPLATES的设置方法，具体的看看文档稍微修改下就好了，非常简单问题不大。</p><p>附上1.8要回退1.7的脚本（经测试有效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate auth 0001</span><br><span class="line">python manage.py migrate contenttypes 0001</span><br><span class="line">pip install django==1.7.11</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在项目中将Django从1.7升级到1.8，现在想起来记录一下相关的步骤和过程。&lt;/p&gt;
&lt;p&gt;由于项目一开始用的是1.6，所以用&lt;code&gt;python manage.py startapp&lt;/code&gt;默认没有migrations这个package，而之前又有一些model是使用syncdb的，并且之后再没修改过，所以在用1.7的时候一直都没什么问题，而且1.7会自动去侦测没有makemigrations的model并自动migrate，导致了在升级1.8的过程中出现了一些小插曲，这里来记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.purewhite.io/categories/python/"/>
    
    
    <category term="后端" scheme="https://www.purewhite.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
    <category term="python" scheme="https://www.purewhite.io/tags/python/"/>
    
    <category term="django" scheme="https://www.purewhite.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu+nginx下使用letsencrypt加密https</title>
    <link href="https://www.purewhite.io/2017/05/06/letsencrypt-ubuntu-nginx-https/"/>
    <id>https://www.purewhite.io/2017/05/06/letsencrypt-ubuntu-nginx-https/</id>
    <published>2017-05-06T12:34:47.000Z</published>
    <updated>2021-12-02T12:51:07.228Z</updated>
    
    <content type="html"><![CDATA[<p>因为服务器太乱，我清理了一下服务器并且重新使用letsencrypt加密了https，现在将我的经验分享出来。</p><p>本文基于ubuntu16.04、nginx环境</p><h2 id="第一步：安装-Certbot"><a href="#第一步：安装-Certbot" class="headerlink" title="第一步：安装 Certbot"></a>第一步：安装 Certbot</h2><p>第一步是安装<code>letsencrypt</code>提供的certbot工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:certbot/certbot</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install certbot</span><br></pre></td></tr></table></figure><h2 id="第二步：-获得SSL的证书"><a href="#第二步：-获得SSL的证书" class="headerlink" title="第二步： 获得SSL的证书"></a>第二步： 获得SSL的证书</h2><p>我们使用<code>WebRoot</code>这个插件。</p><span id="more"></span><p>这里以nginx的default的site作为示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure><p>在server的块中，加入以下内容</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">~ /.well-known</span> &#123;</span><br><span class="line">        allow all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确认root是你网站的根目录，比如默认情况下是<code>/var/www/html</code></p><p>保存退出之后，测试并重启你的nginx：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t</span><br><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>然后我们获取到相关的SSL证书：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot certonly --webroot --webroot-path=/var/www/html -d example.com -d www.example.com -d third.another.com</span><br></pre></td></tr></table></figure><p>记得把上面的<code>/var/www/html</code>改成你自己的网站根目录。如果需要同时对多个域名进行认证的话只要同时使用多个<code>-d</code>就可以了，并且这些域名并不一定都需要为<code>example.com</code>，可以为别的域名。</p><p>然后根据提示，输入对应的信息，如果完成后应该会看到类似的信息：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations<span class="comment">! Your certificate and chain have been saved at</span></span><br><span class="line"><span class="comment">   /etc/letsencrypt/live/example.com/fullchain.pem. Your cert</span></span><br><span class="line"><span class="comment">   will expire on 2017-07-26. To obtain a new or tweaked version of</span></span><br><span class="line"><span class="comment">   this certificate in the future, simply run certbot again. To</span></span><br><span class="line"><span class="comment">   non-interactively renew *all* of your certificates, run &quot;certbot</span></span><br><span class="line"><span class="comment">   renew&quot;</span></span><br><span class="line"><span class="comment"> - If you lose your account credentials, you can recover through</span></span><br><span class="line"><span class="comment">   e-mails sent to sammy@example.com.</span></span><br><span class="line"><span class="comment"> - Your account credentials have been saved in your Certbot</span></span><br><span class="line"><span class="comment">   configuration directory at /etc/letsencrypt. You should make a</span></span><br><span class="line"><span class="comment">   secure backup of this folder now. This configuration directory will</span></span><br><span class="line"><span class="comment">   also contain certificates and private keys obtained by Certbot so</span></span><br><span class="line"><span class="comment">   making regular backups of this folder is ideal.</span></span><br><span class="line"><span class="comment"> - If you like Certbot, please consider supporting our work by:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="comment">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure><p>认证成功后，我们来生成一下更强的<code>dhparam</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</span><br></pre></td></tr></table></figure><p>这一步应该会消耗一定的时间</p><h2 id="第三步：在nginx上设置TLS-SSL"><a href="#第三步：在nginx上设置TLS-SSL" class="headerlink" title="第三步：在nginx上设置TLS/SSL"></a>第三步：在nginx上设置TLS/SSL</h2><p>我们先创建一个新的脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/nginx/snippets/ssl-example.com.conf</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span><br></pre></td></tr></table></figure><p>保存退出后，再创建一个脚本用来设置ssl的参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/nginx/snippets/ssl-params.conf</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from https://cipherli.st/</span></span><br><span class="line"><span class="comment"># and https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line"><span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">ssl_ciphers</span> <span class="string">&quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;</span>;</span><br><span class="line"><span class="attribute">ssl_ecdh_curve</span> secp384r1;</span><br><span class="line"><span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line"><span class="attribute">ssl_session_tickets</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">ssl_stapling</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">ssl_stapling_verify</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">resolver</span> <span class="number">8.8.8.8</span> <span class="number">8.8.4.4</span> valid=<span class="number">300s</span>;</span><br><span class="line"><span class="attribute">resolver_timeout</span> <span class="number">5s</span>;</span><br><span class="line"><span class="comment"># disable HSTS header for now</span></span><br><span class="line"><span class="comment">#add_header Strict-Transport-Security &quot;max-age=63072000; includeSubDomains; preload&quot;;</span></span><br><span class="line"><span class="attribute">add_header</span> X-Frame-Options DENY;</span><br><span class="line"><span class="attribute">add_header</span> X-Content-Type-Options nosniff;</span><br><span class="line"></span><br><span class="line"><span class="attribute">ssl_dhparam</span> /etc/ssl/certs/dhparam.pem;</span><br></pre></td></tr></table></figure><p>保存退出。</p><p>然后修改一下site的配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure><p>改成这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">    <span class="keyword">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="keyword">listen</span> [::]:<span class="number">80</span> default_server;</span><br><span class="line">    <span class="keyword">listen</span> <span class="number">443</span> ssl http2 default_server;</span><br><span class="line">    <span class="keyword">listen</span> [::]:<span class="number">443</span> ssl http2 default_server;</span><br><span class="line"></span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    <span class="keyword">include</span> snippets/ssl-example.com.conf;</span><br><span class="line">    <span class="keyword">include</span> snippets/ssl-params.conf;</span><br><span class="line"></span><br><span class="line">    . . .</span><br></pre></td></tr></table></figure><p>保存退出。</p><h2 id="第四步：在防火墙中Allow-Nginx"><a href="#第四步：在防火墙中Allow-Nginx" class="headerlink" title="第四步：在防火墙中Allow Nginx"></a>第四步：在防火墙中Allow Nginx</h2><p>执行以下脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow <span class="string">&#x27;Nginx Full&#x27;</span></span><br><span class="line">sudo nginx -t</span><br><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="第五步：自动更新SSL证书"><a href="#第五步：自动更新SSL证书" class="headerlink" title="第五步：自动更新SSL证书"></a>第五步：自动更新SSL证书</h2><p>因为letsencrypt提供的证书是有期限的，所以我们需要设置自动更新证书。</p><p>执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -e</span><br></pre></td></tr></table></figure><p>在最后加上这么一行：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">30 </span><span class="number">0</span> * * <span class="number">1</span> /<span class="keyword">usr</span>/bin/certbot renew --quiet --renew-hook <span class="string">&quot;/bin/systemctl reload nginx&quot;</span></span><br></pre></td></tr></table></figure><p>完成！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为服务器太乱，我清理了一下服务器并且重新使用letsencrypt加密了https，现在将我的经验分享出来。&lt;/p&gt;
&lt;p&gt;本文基于ubuntu16.04、nginx环境&lt;/p&gt;
&lt;h2 id=&quot;第一步：安装-Certbot&quot;&gt;&lt;a href=&quot;#第一步：安装-Certbot&quot; class=&quot;headerlink&quot; title=&quot;第一步：安装 Certbot&quot;&gt;&lt;/a&gt;第一步：安装 Certbot&lt;/h2&gt;&lt;p&gt;第一步是安装&lt;code&gt;letsencrypt&lt;/code&gt;提供的certbot工具&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo add-apt-repository ppa:certbot/certbot&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install certbot&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;第二步：-获得SSL的证书&quot;&gt;&lt;a href=&quot;#第二步：-获得SSL的证书&quot; class=&quot;headerlink&quot; title=&quot;第二步： 获得SSL的证书&quot;&gt;&lt;/a&gt;第二步： 获得SSL的证书&lt;/h2&gt;&lt;p&gt;我们使用&lt;code&gt;WebRoot&lt;/code&gt;这个插件。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://www.purewhite.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础技术——AUFS</title>
    <link href="https://www.purewhite.io/2017/05/06/docker-aufs/"/>
    <id>https://www.purewhite.io/2017/05/06/docker-aufs/</id>
    <published>2017-05-06T08:23:43.000Z</published>
    <updated>2021-12-02T12:51:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习docker，看到了一篇比较好的文章，于是转载了过来，原文出处在最后。</p><p>AUFS是一种Union File System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。</p><span id="more"></span>![](http://coolshell.cn//wp-content/uploads/2015/08/docker-filesystems-busyboxrw.png)<p>AUFS又叫Another UnionFS，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS。是个叫Junjiro Okajima（岡島順治郎）在2006年开发的，AUFS完全重写了早期的UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS 2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。</p><p>不过，好在有很多发行版都用了AUFS，比如：Ubuntu 10.04，Debian6.0, Gentoo Live CD支持AUFS，所以，也OK了。</p><p>好了，扯完这些闲话，我们还是看一个示例吧（环境：Ubuntu 14.04）</p><p>首先，我们建上两个目录（水果和蔬菜），并在这两个目录中放上一些文件，水果中有苹果和蕃茄，蔬菜有胡萝卜和蕃茄。</p><p>然后，我们输入以下命令：</p><p>我们可以看到在./mnt目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了./mnt目录下了。</p><p>我们来修改一下其中的文件内容：</p><p>上面的示例，我们可以看到./mnt/apple的内容改了，./fruits/apple的内容也改了。</p><p>上面的示例，我们可以看到，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits/carrots的目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容。</p><p>也就是说，我们在mount aufs命令中，我们没有指它vegetables和fruits的目录权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）</p><p>所以，如果我们像下面这样指定权限来mount aufs，你就会发现有不一样的效果（记得先把上面./fruits/carrots的文件删除了）：</p><p>现在，在这情况下，如果我们要修改./mnt/tomato这个文件，那么究竟是哪个文件会被改写？</p><p>可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高。</p><p>你可以用这个例子做一些各种各样的试验，我这里主要是给大家一个感性认识，就不展开试验下去了。</p><p>那么，这种UnionFS有什么用？</p><p>历史上，有一个叫<a href="http://zh.wikipedia.org/wiki/Knoppix">Knoppix的Linux发行版</a>，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把CD/DVD上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把CD/DVD这个文件系统和USB这个可写的系统给联合mount起来，这样你对CD/DVD上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对CD/DVD上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西。</p><p>我们可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad hoc snapshot。</p><p>Docker把UnionFS的想像力发挥到了容器的镜像。你是否还记得我在<a href="http://coolshell.cn/articles/17010.html">介绍Linux Namespace上篇</a>中用mount namespace和chroot山寨了一镜像。现在当你看过了这个UnionFS的技术后，你是不是就明白了，你完全可以用UnionFS这样的技术做出分层的镜像来。</p><p>下图来自Docker的官方文档<a href="http://docs.docker.com/terms/layer/">Layer</a>，其很好的展示了Docker用UnionFS搭建的分层镜像。</p><p><img data-src="http://coolshell.cn//wp-content/uploads/2015/04/docker-filesystems-multilayer.png" alt="docker-filesystems-multilayer"></p><p>关于docker的分层镜像，除了aufs，docker还支持btrfs, devicemapper和vfs，你可以使用 -s 或 –storage-driver= 选项来指定相关的镜像存储。在Ubuntu 14.04下，docker默认Ubuntu的 aufs（在CentOS7下，用的是devicemapper，关于devicemapper，我会以以后的文章中讲解）你可以在下面的目录中查看相关的每个层的镜像：</p><p>在docker执行起来后（比如：docker run -it ubuntu /bin/bash ），你可以从/sys/fs/aufs/si_[id]目录下查看aufs的mount的情况，下面是个示例：</p><p>你会看到只有最顶上的层（branch）是rw权限，其它的都是ro+wh权限只读的。</p><p>关于docker的aufs的配置，你可以在/var/lib/docker/repositories-aufs这个文件中看到。</p><h4 id="AUFS的一些特性"><a href="#AUFS的一些特性" class="headerlink" title="AUFS的一些特性"></a>AUFS的一些特性</h4><p>AUFS有所有Union FS的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被mount好的目录。而且，他还能在多个可写的branch/dir间进行负载均衡。</p><p>上面的例子，我们已经看到AUFS的mount的示例了。下面我们来看一看被union的目录（分支）的相关权限：</p><ul><li>rw表示可写可读read-write。</li><li>ro表示read-only，如果你不指权限，那么除了第一个外ro是默认值，对于ro分支，其永远不会收到写操作，也不会收到查找whiteout的操作。</li><li>rr表示real-read-only，与read-only不同的是，rr标记的是天生就是只读的分支，这样，AUFS可以提高性能，比如不再设置inotify来检查文件变动通知。</li></ul><p>权限中，我们看到了一个术语：whiteout，下面我来解释一下这个术语。</p><p>一般来说ro的分支都会有wh的属性，比如 “[dir]=ro+wh”。所谓whiteout的意思，如果在union中删除的某个文件，实际上是位于一个readonly的分支（目录）上，那么，在mount的union这个目录中你将看不到这个文件，但是read-only这个层上我们无法做任何的修改，所以，我们就需要对这个readonly目录里的文件作whiteout。AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。</p><p>看个例子：</p><p>假设我们有三个目录和文件如下所示（test是个空目录）：</p><p>我们如下mount：</p><p>现在我们在权限为rw的test目录下建个whiteout的隐藏文件.wh.apple，你就会发现./mnt/apple这个文件就消失了:</p><p>上面这个操作和 rm ./mnt/apple是一样的。</p><h5 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h5><p><strong>Branch</strong> – 就是各个要被union起来的目录（就是我在上面使用的dirs的命令行参数）</p><ul><li>Branch根据被union的顺序形成一个stack，一般来说最上面的是可写的，下面的都是只读的。</li><li>Branch的stack可以在被mount后进行修改，比如：修改顺序，加入新的branch，或是删除其中的branch，或是直接修改branch的权限</li></ul><p><strong>Whiteout</strong> 和 <strong>Opaque</strong></p><ul><li>如果UnionFS中的某个目录被删除了，那么就应该不可见了，就算是在底层的branch中还有这个目录，那也应该不可见了。</li></ul><ul><li>Whiteout就是某个上层目录覆盖了下层的相同名字的目录。用于隐藏低层分支的文件，也用于阻止readdir进入低层分支。</li></ul><ul><li>Opaque的意思就是不允许任何下层的某个目录显示出来。</li></ul><ul><li>在隐藏低层档的情况下，whiteout的名字是’.wh.<filename>’。</li></ul><ul><li>在阻止readdir的情况下，名字是’.wh..wh..opq’或者 ’.wh.__dir_opaque’。</li></ul><h5 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h5><p>看到上面这些，你一定会有几个问题：</p><p><strong>其一、你可能会问，要有文件在原来的地方被修改了会怎么样？</strong>mount的目录会一起改变吗？答案是会的，也可以是不会的。因为你可以指定一个叫udba的参数（全称：User’s Direct Branch Access），这个参数有三个取值：</p><ul><li><strong>udba=none</strong> – 设置上这个参数后，AUFS会运转的更快，因为那些不在mount目录里发生的修改，aufs不会同步过来了，所以会有数据出错的问题。</li><li><strong>udba=reval</strong> – 设置上这个参数后，AUFS会去查文件有没有被更新，如果有的话，就会把修改拉到mount目录内。</li><li><strong>udba=notify</strong> – 这个参数会让AUFS为所有的branch注册inotify，这样可以让AUFS在更新文件修改的性能更高一些。</li></ul><p><strong>其二、如果有多个rw的branch（目录）被union起来了，那么，当我创建文件的时候，aufs会创建在哪里呢？</strong> aufs提供了一个叫create的参数可以供你来配置相当的创建策略，下面有几个例子。</p><p><strong>create=rr | round−robin</strong> 轮询。下面的示例可以看到，新创建的文件轮流写到三个目录中</p><p><strong>create=mfs[:second] | most−free−space[:second]</strong> 选一个可用空间最好的分支。可以指定一个检查可用磁盘空间的时间。</p><p><strong>create=mfsrr:low[:second]</strong> 选一个空间大于low的branch，如果空间小于low了，那么aufs会使用 round-robin 方式。</p><p>更多的关于AUFS的细节使用参数，大家可以直接在Ubuntu 14.04下通过<a href="http://aufs.sourceforge.net/aufs3/man.html"> man aufs </a>来看一下其中的各种参数和命令。</p><h4 id="AUFS的性能"><a href="#AUFS的性能" class="headerlink" title="AUFS的性能"></a>AUFS的性能</h4><p>AUFS的性能慢吗？也慢也不慢。因为AUFS会把所有的分支mount起来，所以，在查找文件上是比较慢了。因为它要遍历所有的branch。是个O(n)的算法（很明显，这个算法有很大的改进空间的）所以，branch越多，查找文件的性能也就越慢。但是，一旦AUFS找到了这个文件的inode，那后以后的读写和操作原文件基本上是一样的。</p><p>所以，如果你的程序跑在在AUFS下，open和stat操作会有明显的性能下降，branch越多，性能越差，但是在write/read操作上，性能没有什么变化。</p><p>IBM的研究中心对Docker的性能给了一份非常不错的性能报告（PDF）《<a href="http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/$File/rc25482.pdf">An Updated Performance Comparison of Virtual Machinesand Linux Containers</a>》</p><p>我截了两张图出来，第一张是顺序读写，第二张是随机读写。基本没有什么性能损失的问题。而KVM在随机读写的情况也就有点慢了（但是，如果硬盘是SSD的呢？）</p><p><img data-src="http://coolshell.cn//wp-content/uploads/2015/08/docker.seq_.jpg" alt="顺序读写"></p><p><img data-src="http://coolshell.cn//wp-content/uploads/2015/08/docker.rand_.jpg" alt="随机读写"></p><p>原文出自：<a href="http://coolshell.cn/articles/17061.html">coolshell</a></p><p><strong>（转载文章请注明作者和出处 酷 壳 – CoolShell ，请勿用于任何商业用途）</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习docker，看到了一篇比较好的文章，于是转载了过来，原文出处在最后。&lt;/p&gt;
&lt;p&gt;AUFS是一种Union File System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://www.purewhite.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://www.purewhite.io/tags/docker/"/>
    
    <category term="linux" scheme="https://www.purewhite.io/tags/linux/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css"><meta name="google-site-verification" content="Xg_Hnp9ie-Rq7-zLPdd3c9dQtR_0N845ue4QaK8jvL4"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><link rel="stylesheet" href="https://use.fontawesome.com/11d7545abd.css"><link rel="stylesheet" href="/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="https://static.purewhite.io/favicon.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="https://static.purewhite.io/favicon.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="https://static.purewhite.io/favicon.jpg?v=7.0.1"><link rel="mask-icon" href="https://static.purewhite.io/favicon.jpg?v=7.0.1" color="#222"><meta property="fb:admins" content="100008177860594"><meta property="fb:app_id" content="761738893983932"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.0.1",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"ZP9482CZD3",apiKey:"d26207a3ce8de9fe98e7af4215425c93",indexName:"Blog",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="go语言以并发作为其特性之一，并发必然会带来对于资源的竞争，这时候我们就需要使用go提供的sync.Mutex这把互斥锁来保证临界资源的访问互斥。 既然经常会用这把锁，那么了解一下其内部实现，就能了解这把锁适用什么场景，特性如何了。"><meta name="keywords" content="go,golang,源码,mutex,锁,sync"><meta property="og:type" content="article"><meta property="og:title" content="源码剖析golang中sync.Mutex"><meta property="og:url" content="https://purewhite.io/2019/03/28/golang-mutex-source/index.html"><meta property="og:site_name" content="Pure White"><meta property="og:description" content="go语言以并发作为其特性之一，并发必然会带来对于资源的竞争，这时候我们就需要使用go提供的sync.Mutex这把互斥锁来保证临界资源的访问互斥。 既然经常会用这把锁，那么了解一下其内部实现，就能了解这把锁适用什么场景，特性如何了。"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-03-29T05:26:28.513Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="源码剖析golang中sync.Mutex"><meta name="twitter:description" content="go语言以并发作为其特性之一，并发必然会带来对于资源的竞争，这时候我们就需要使用go提供的sync.Mutex这把互斥锁来保证临界资源的访问互斥。 既然经常会用这把锁，那么了解一下其内部实现，就能了解这把锁适用什么场景，特性如何了。"><link rel="alternate" href="/atom.xml" title="Pure White" type="application/atom+xml"><link rel="canonical" href="https://purewhite.io/2019/03/28/golang-mutex-source/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>源码剖析golang中sync.Mutex | Pure White</title><script>window.fbAsyncInit=function(){FB.init({appId:"761738893983932",xfbml:!0,version:"v2.10"})},function(e,n,t){var o,c=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="//connect.facebook.net/zh_Hans/sdk.js",c.parentNode.insertBefore(o,c))}(document,"script","facebook-jssdk")</script><script async src="//www.googletagmanager.com/gtag/js?id=UA-98194081-1"></script><script>var host=window.location.hostname;if("localhost"!==host){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-98194081-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a29bb47eea3aa0d952f7bd979b29fa84";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Pure White</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">主业写bug，副业debug</h1></div><div class="site-nav-toggle"> <button aria-label="Toggle navigation bar"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header> <a href="https://github.com/PureWhiteWu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#222;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://purewhite.io/2019/03/28/golang-mutex-source/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Pure White"><meta itemprop="description" content="青春不是年华，是心境；<br />青春不是桃面、丹唇、柔膝，<br />而是深沉的意志、恢弘的想象、<br />炽热的感情。"><meta itemprop="image" content="https://static.purewhite.io/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Pure White"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">源码剖析golang中sync.Mutex</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-03-28 21:01:18" itemprop="dateCreated datePublished" datetime="2019-03-28T21:01:18+08:00">2019-03-28</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-03-29 13:26:28" itemprop="dateModified" datetime="2019-03-29T13:26:28+08:00">2019-03-29</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Comments:</span><a href="/2019/03/28/golang-mutex-source/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/03/28/golang-mutex-source/" itemprop="commentCount"></span></a></span> <span id="/2019/03/28/golang-mutex-source/" class="leancloud_visitors" data-flag-title="源码剖析golang中sync.Mutex"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">Views:</span><span class="leancloud-visitors-count"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">Symbols count in article:</span> <span title="Symbols count in article">13k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">12 mins.</span></div></div></header><div class="post-body han-init-context" itemprop="articleBody"><p>go语言以并发作为其特性之一，并发必然会带来对于资源的竞争，这时候我们就需要使用go提供的<code>sync.Mutex</code>这把互斥锁来保证临界资源的访问互斥。</p><p>既然经常会用这把锁，那么了解一下其内部实现，就能了解这把锁适用什么场景，特性如何了。</p><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在我第一次看这段代码的时候，感觉真的是惊为天人，特别是整个<code>Mutex</code>只用到了两个私有字段，以及一次CAS就加锁的过程，这其中设计以及编程的理念真的让我感觉自愧不如。</p><p>在看<code>sync.Mutex</code>的代码的时候，一定要记住，同时会有多个goroutine会来要这把锁，所以锁的状态<code>state</code>是可能会一直更改的。</p><h2 id="锁的性质"><a href="#锁的性质" class="headerlink" title="锁的性质"></a>锁的性质</h2><p>先说结论：<code>sync.Mutex</code>是把公平锁。</p><p>在源代码中，有一段注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutex fairness.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Mutex can be in 2 modes of operations: normal and starvation.</span></span><br><span class="line"><span class="comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span></span><br><span class="line"><span class="comment">// does not own the mutex and competes with new arriving goroutines over</span></span><br><span class="line"><span class="comment">// the ownership. New arriving goroutines have an advantage -- they are</span></span><br><span class="line"><span class="comment">// already running on CPU and there can be lots of them, so a woken up</span></span><br><span class="line"><span class="comment">// waiter has good chances of losing. In such case it is queued at front</span></span><br><span class="line"><span class="comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span></span><br><span class="line"><span class="comment">// it switches mutex to the starvation mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In starvation mode ownership of the mutex is directly handed off from</span></span><br><span class="line"><span class="comment">// the unlocking goroutine to the waiter at the front of the queue.</span></span><br><span class="line"><span class="comment">// New arriving goroutines don't try to acquire the mutex even if it appears</span></span><br><span class="line"><span class="comment">// to be unlocked, and don't try to spin. Instead they queue themselves at</span></span><br><span class="line"><span class="comment">// the tail of the wait queue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If a waiter receives ownership of the mutex and sees that either</span></span><br><span class="line"><span class="comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span></span><br><span class="line"><span class="comment">// it switches mutex back to normal operation mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Normal mode has considerably better performance as a goroutine can acquire</span></span><br><span class="line"><span class="comment">// a mutex several times in a row even if there are blocked waiters.</span></span><br><span class="line"><span class="comment">// Starvation mode is important to prevent pathological cases of tail latency.</span></span><br></pre></td></tr></table></figure><p>看懂这段注释对于我们理解mutex这把锁有很大的帮助，这里面讲了这把锁的设计理念。大致意思如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 锁有两种模式：正常模式和饥饿模式。</span></span><br><span class="line"><span class="comment">// 在正常模式下，所有的等待锁的goroutine都会存在一个先进先出的队列中（轮流被唤醒）</span></span><br><span class="line"><span class="comment">// 但是一个被唤醒的goroutine并不是直接获得锁，而是仍然需要和那些新请求锁的（new arrivial）</span></span><br><span class="line"><span class="comment">// 的goroutine竞争，而这其实是不公平的，因为新请求锁的goroutine有一个优势——它们正在CPU上</span></span><br><span class="line"><span class="comment">// 运行，并且数量可能会很多。所以一个被唤醒的goroutine拿到锁的概率是很小的。在这种情况下，</span></span><br><span class="line"><span class="comment">// 这个被唤醒的goroutine会加入到队列的头部。如果一个等待的goroutine有超过1ms（写死在代码中）</span></span><br><span class="line"><span class="comment">// 都没获取到锁，那么就会把锁转变为饥饿模式。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在饥饿模式中，锁的所有权会直接从释放锁(unlock)的goroutine转交给队列头的goroutine，</span></span><br><span class="line"><span class="comment">// 新请求锁的goroutine就算锁是空闲状态也不会去获取锁，并且也不会尝试自旋。它们只是排到队列的尾部。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果一个goroutine获取到了锁之后，它会判断以下两种情况：</span></span><br><span class="line"><span class="comment">// 1. 它是队列中最后一个goroutine；</span></span><br><span class="line"><span class="comment">// 2. 它拿到锁所花的时间小于1ms；</span></span><br><span class="line"><span class="comment">// 以上只要有一个成立，它就会把锁转变回正常模式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常模式会有比较好的性能，因为即使有很多阻塞的等待锁的goroutine，</span></span><br><span class="line"><span class="comment">// 一个goroutine也可以尝试请求多次锁。</span></span><br><span class="line"><span class="comment">// 饥饿模式对于防止尾部延迟来说非常的重要。</span></span><br></pre></td></tr></table></figure><p>在下一步真正看源代码之前，我们必须要理解一点：当一个goroutine获取到锁的时候，有可能没有竞争者，也有可能会有很多竞争者，那么我们就需要站在不同的goroutine的角度上去考虑goroutine看到的锁的状态和实际状态、期望状态之间的转化。</p><h2 id="字段定义"><a href="#字段定义" class="headerlink" title="字段定义"></a>字段定义</h2><p><code>sync.Mutex</code>只包含两个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span></span><br><span class="line">	sema	<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">	mutexWoken</span><br><span class="line">	mutexStarving</span><br><span class="line">	mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中<code>state</code>是一个表示锁的状态的字段，这个字段会同时被多个goroutine所共用（使用atomic.CAS来保证原子性），第0个bit（1）表示锁已被获取，也就是已加锁，被某个goroutine拥有；第1个bit（2）表示有goroutine被唤醒，尝试获取锁；第2个bit（4）标记这把锁是否为饥饿状态。</p><p><code>sema</code>字段就是用来唤醒goroutine所用的信号量。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>在看代码之前，我们需要有一个概念：每个goroutine也有自己的状态，存在局部变量里面（也就是函数栈里面），goroutine有可能是新到的、被唤醒的、正常的、饥饿的。</p><h3 id="atomic-CAS"><a href="#atomic-CAS" class="headerlink" title="atomic.CAS"></a>atomic.CAS</h3><p>先瞻仰一下惊为天人的一行代码加锁的CAS操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock locks m.</span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">// blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是第一段代码，这段代码调用了<code>atomic</code>包中的<code>CompareAndSwapInt32</code>这个方法来尝试快速获取锁，这个方法的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure><p>意思是，如果addr指向的地址中存的值和old一样，那么就把addr中的值改为new并返回true；否则什么都不做，返回false。由于是<code>atomic</code>中的函数，所以是保证了原子性的。</p><p>我们来具体看看CAS的实现（<code>src/runtime/internal/atomic/asm_amd64.s</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// bool Cas(int32 *val, int32 old, int32 new)</span><br><span class="line">// Atomically:</span><br><span class="line">//	if(*val == old)&#123;</span><br><span class="line">//		*val = new;</span><br><span class="line">//		return 1;</span><br><span class="line">//	&#125; else</span><br><span class="line">//		return 0;</span><br><span class="line">// 这里参数及返回值大小加起来是17，是因为一个指针在amd64下是8字节，</span><br><span class="line">// 然后int32分别是占用4字节，最后的返回值是bool占用1字节，所以加起来是17</span><br><span class="line">TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$0-17 </span><br><span class="line">	// 为什么不把*val指针放到AX中呢？因为AX有特殊用处，</span><br><span class="line">	// 在下面的CMPXCHGL里面，会从AX中读取要比较的其中一个数</span><br><span class="line">	MOVQ	ptr+0(FP), BX</span><br><span class="line">	// 所以AX要用来存参数old</span><br><span class="line">	MOVL	old+8(FP), AX</span><br><span class="line">	// 把new中的数存到寄存器CX中</span><br><span class="line">	MOVL	new+12(FP), CX</span><br><span class="line">	// 注意这里了，这里使用了LOCK前缀，所以保证操作是原子的</span><br><span class="line">	LOCK</span><br><span class="line">	// 0(BX) 可以理解为 *val</span><br><span class="line">	// 把 AX中的数 和 第二个操作数 0(BX)——也就是BX寄存器所指向的地址中存的值 进行比较</span><br><span class="line">	// 如果相等，就把 第一个操作数 CX寄存器中存的值 赋给 第二个操作数 BX寄存器所指向的地址</span><br><span class="line">	// 并将标志寄存器ZF设为1</span><br><span class="line">	// 否则将标志寄存器ZF清零</span><br><span class="line">	CMPXCHGL	CX, 0(BX)</span><br><span class="line">	// SETE的作用是：</span><br><span class="line">	// 如果Zero Flag标志寄存器为1，那么就把操作数设为1</span><br><span class="line">	// 否则把操作数设为0</span><br><span class="line">	// 也就是说，如果上面的比较相等了，就返回true，否则为false</span><br><span class="line">	// ret+16(FP)代表了返回值的地址</span><br><span class="line">	SETEQ	ret+16(FP)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure><p>如果看不懂也没太大关系，只要知道这个函数的作用，以及这个函数是原子性的即可。</p><p>那么这段代码的意思就是：先看看这把锁是不是空闲状态，如果是的话，直接原子性地修改一下<code>state</code>为已被获取就行了。多么简洁（虽然后面的代码并不是……）！</p><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>接下来具体看主流程的代码，代码中有一些位运算看起来比较晕，我会试着用伪代码在边上注释。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock locks m.</span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">// blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用来存当前goroutine等待的时间</span></span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">	<span class="comment">// 用来存当前goroutine是否饥饿</span></span><br><span class="line">	starving := <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 用来存当前goroutine是否已唤醒</span></span><br><span class="line">	awoke := <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 用来存当前goroutine的循环次数(想一想一个goroutine如果循环了2147483648次咋办……)</span></span><br><span class="line">	iter := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 复制一下当前锁的状态</span></span><br><span class="line">	old := m.state</span><br><span class="line">	<span class="comment">// 自旋</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 如果是饥饿情况之下，就不要自旋了，因为锁会直接交给队列头部的goroutine</span></span><br><span class="line">		<span class="comment">// 如果锁是被获取状态，并且满足自旋条件（canSpin见后文分析），那么就自旋等锁</span></span><br><span class="line">		<span class="comment">// 伪代码：if isLocked() and isNotStarving() and canSpin()</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// 将自己的状态以及锁的状态设置为唤醒，这样当Unlock的时候就不会去唤醒其它被阻塞的goroutine了</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 进行自旋(分析见后文)</span></span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			iter++</span><br><span class="line">			<span class="comment">// 更新锁的状态(有可能在自旋的这段时间之内锁的状态已经被其它goroutine改变)</span></span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 当走到这一步的时候，可能会有以下的情况：</span></span><br><span class="line">		<span class="comment">// 1. 锁被获取+饥饿</span></span><br><span class="line">		<span class="comment">// 2. 锁被获取+正常</span></span><br><span class="line">		<span class="comment">// 3. 锁空闲+饥饿</span></span><br><span class="line">		<span class="comment">// 4. 锁空闲+正常</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// goroutine的状态可能是唤醒以及非唤醒</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 复制一份当前的状态，目的是根据当前状态设置出期望的状态，存在new里面，</span></span><br><span class="line">		<span class="comment">// 并且通过CAS来比较以及更新锁的状态</span></span><br><span class="line">		<span class="comment">// old用来存锁的当前状态</span></span><br><span class="line">		<span class="built_in">new</span> := old</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果说锁不是饥饿状态，就把期望状态设置为被获取(获取锁)</span></span><br><span class="line">		<span class="comment">// 也就是说，如果是饥饿状态，就不要把期望状态设置为被获取</span></span><br><span class="line">		<span class="comment">// 新到的goroutine乖乖排队去</span></span><br><span class="line">		<span class="comment">// 伪代码：if isNotStarving()</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 伪代码：newState = locked</span></span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果锁是被获取状态，或者饥饿状态</span></span><br><span class="line">		<span class="comment">// 就把期望状态中的等待队列的等待者数量+1(实际上是new + 8)</span></span><br><span class="line">		<span class="comment">// (会不会可能有三亿个goroutine等待拿锁……)</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果说当前的goroutine是饥饿状态，并且锁被其它goroutine获取</span></span><br><span class="line">		<span class="comment">// 那么将期望的锁的状态设置为饥饿状态</span></span><br><span class="line">		<span class="comment">// 如果锁是释放状态，那么就不用切换了</span></span><br><span class="line">		<span class="comment">// Unlock期望一个饥饿的锁会有一些等待拿锁的goroutine，而不只是一个</span></span><br><span class="line">		<span class="comment">// 这种情况下不会成立</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 期望状态设置为饥饿状态</span></span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果说当前goroutine是被唤醒状态，我们需要reset这个状态</span></span><br><span class="line">		<span class="comment">// 因为goroutine要么是拿到锁了，要么是进入sleep了</span></span><br><span class="line">		<span class="keyword">if</span> awoke &#123;</span><br><span class="line">			<span class="comment">// 如果说期望状态不是woken状态，那么肯定出问题了</span></span><br><span class="line">			<span class="comment">// 这里看不懂没关系，wake的逻辑在下面</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这句就是把new设置为非唤醒状态</span></span><br><span class="line">			<span class="comment">// &amp;^的意思是and not</span></span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 通过CAS来尝试设置锁的状态</span></span><br><span class="line">		<span class="comment">// 这里可能是设置锁，也有可能是只设置为饥饿状态和等待数量</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果说old状态不是饥饿状态也不是被获取状态</span></span><br><span class="line">			<span class="comment">// 那么代表当前goroutine已经通过CAS成功获取了锁</span></span><br><span class="line">			<span class="comment">// (能进入这个代码块表示状态已改变，也就是说状态是从空闲到被获取)</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果之前已经等待过了，那么就要放到队列头</span></span><br><span class="line">			queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">			<span class="comment">// 如果说之前没有等待过，就初始化设置现在的等待时间</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 既然获取锁失败了，就使用sleep原语来阻塞当前goroutine</span></span><br><span class="line">			<span class="comment">// 通过信号量来排队获取锁</span></span><br><span class="line">			<span class="comment">// 如果是新来的goroutine，就放到队列尾部</span></span><br><span class="line">			<span class="comment">// 如果是被唤醒的等待锁的goroutine，就放到队列头部</span></span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 这里sleep完了，被唤醒</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果当前goroutine已经是饥饿状态了</span></span><br><span class="line">			<span class="comment">// 或者当前goroutine已经等待了1ms（在上面定义常量）以上</span></span><br><span class="line">			<span class="comment">// 就把当前goroutine的状态设置为饥饿</span></span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			<span class="comment">// 再次获取一下锁现在的状态</span></span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="comment">// 如果说锁现在是饥饿状态，就代表现在锁是被释放的状态，当前goroutine是被信号量所唤醒的</span></span><br><span class="line">			<span class="comment">// 也就是说，锁被直接交给了当前goroutine</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 如果说当前锁的状态是被唤醒状态或者被获取状态，或者说等待的队列为空</span></span><br><span class="line">				<span class="comment">// 那么是不可能的，肯定是出问题了，因为当前状态肯定应该有等待的队列，锁也一定是被释放状态且未唤醒</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 当前的goroutine获得了锁，那么就把等待队列-1</span></span><br><span class="line">				delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">				<span class="comment">// 如果当前goroutine非饥饿状态，或者说当前goroutine是队列中最后一个goroutine</span></span><br><span class="line">				<span class="comment">// 那么就退出饥饿模式，把状态设置为正常</span></span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// Exit starvation mode.</span></span><br><span class="line">					<span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">					<span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">					<span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">					<span class="comment">// to starvation mode.</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 原子性地加上改动的状态</span></span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果锁不是饥饿模式，就把当前的goroutine设为被唤醒</span></span><br><span class="line">			<span class="comment">// 并且重置iter(重置spin)</span></span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果CAS不成功，也就是说没能成功获得锁，锁被别的goroutine获得了或者锁一直没被释放</span></span><br><span class="line">			<span class="comment">// 那么就更新状态，重新开始循环尝试拿锁</span></span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为什么CAS能拿到锁呢？因为CAS会原子性地判断<code>old state</code>和当前锁的状态是否一致；而总有一个goroutine会满足以上条件成功拿锁。</p><h3 id="canSpin"><a href="#canSpin" class="headerlink" title="canSpin"></a>canSpin</h3><p>接下来我们来看看上文提到的<code>canSpin</code>条件如何：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Active spinning for sync.Mutex.</span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_canSpin sync.runtime_canSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里的active_spin是个常量，值为4</span></span><br><span class="line">	<span class="comment">// 简单来说，sync.Mutex是有可能被多个goroutine竞争的，所以不应该大量自旋(消耗CPU)</span></span><br><span class="line">	<span class="comment">// 自旋的条件如下：</span></span><br><span class="line">	<span class="comment">// 1. 自旋次数小于active_spin(这里是4)次；</span></span><br><span class="line">	<span class="comment">// 2. 在多核机器上；</span></span><br><span class="line">	<span class="comment">// 3. GOMAXPROCS &gt; 1并且至少有一个其它的处于运行状态的P；</span></span><br><span class="line">	<span class="comment">// 4. 当前P没有其它等待运行的G；</span></span><br><span class="line">	<span class="comment">// 满足以上四个条件才可以进行自旋。</span></span><br><span class="line">	<span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="keyword">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以看出来，并不是一直无限自旋下去的，当自旋次数到达4次或者其它条件不符合的时候，就改为信号量拿锁了。</p><h3 id="doSpin"><a href="#doSpin" class="headerlink" title="doSpin"></a>doSpin</h3><p>然后我们来看看<code>doSpin</code>的实现（其实也没啥好看的）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname sync_runtime_doSpin sync.runtime_doSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">	procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个汇编实现的函数，简单看两眼amd64上的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$0-0</span><br><span class="line">	MOVL	cycles+0(FP), AX</span><br><span class="line">again:</span><br><span class="line">	PAUSE</span><br><span class="line">	SUBL	$1, AX</span><br><span class="line">	JNZ	again</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure><p>看起来没啥好看的，直接跳过吧。</p><h2 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h2><p>接下来我们来看看Unlock的实现，对于Unlock来说，有两个比较关键的特性：</p><ol><li>如果说锁不是处于locked状态，那么对锁执行Unlock会导致panic；</li><li>锁和goroutine没有对应关系，所以我们完全可以在goroutine 1中获取到锁，然后在goroutine 2中调用Unlock来释放锁（这是什么骚操作！）（虽然不推荐大家这么干……）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = m.state</span><br><span class="line">		race.Release(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">	<span class="comment">// 这里获取到锁的状态，然后将状态减去被获取的状态(也就是解锁)，称为new(期望)状态</span></span><br><span class="line">	<span class="comment">// 注意以上两个操作是原子的，所以不用担心多个goroutine并发的问题</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="comment">// 如果说，期望状态加上被获取的状态，不是被获取的话</span></span><br><span class="line">	<span class="comment">// 那么就panic</span></span><br><span class="line">	<span class="comment">// 在这里给大家提一个问题：干嘛要这么大费周章先减去再加上，直接比较一下原来锁的状态是否被获取不就完事了？</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果说new状态(也就是锁的状态)不是饥饿状态</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 复制一下原先状态</span></span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 如果说锁没有等待拿锁的goroutine</span></span><br><span class="line">			<span class="comment">// 或者锁被获取了(在循环的过程中被其它goroutine获取了)</span></span><br><span class="line">			<span class="comment">// 或者锁是被唤醒状态(表示有goroutine被唤醒，不需要再去尝试唤醒其它goroutine)</span></span><br><span class="line">			<span class="comment">// 或者锁是饥饿模式(会直接转交给队列头的goroutine)</span></span><br><span class="line">			<span class="comment">// 那么就直接返回，啥都不用做了</span></span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 走到这一步的时候，说明锁目前还是空闲状态，并且没有goroutine被唤醒且队列中有goroutine等待拿锁</span></span><br><span class="line">			<span class="comment">// 那么我们就要把锁的状态设置为被唤醒，等待队列-1</span></span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="comment">// 又是熟悉的CAS</span></span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果状态设置成功了，我们就通过信号量去唤醒goroutine</span></span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 循环结束的时候，更新一下状态，因为有可能在执行的过程中，状态被修改了(比如被Lock改为了饥饿状态)</span></span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果是饥饿状态下，那么我们就直接把锁的所有权通过信号量移交给队列头的goroutine就好了</span></span><br><span class="line">		<span class="comment">// handoff = true表示直接把锁交给队列头部的goroutine</span></span><br><span class="line">		<span class="comment">// 注意：在这个时候，锁被获取的状态没有被设置，会由被唤醒的goroutine在唤醒后设置</span></span><br><span class="line">		<span class="comment">// 但是当锁处于饥饿状态的时候，我们也认为锁是被获取的(因为我们手动指定了获取的goroutine)</span></span><br><span class="line">		<span class="comment">// 所以说新来的goroutine不会尝试去获取锁(在Lock中有体现)</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据以上代码的分析，可以看出，<code>sync.Mutex</code>这把锁在你的工作负载（所需时间）比较低，比如只是对某个关键变量赋值的时候，性能还是比较好的，但是如果说对于临界资源的操作耗时很长（特别是单个操作就大于1ms）的话，实际上性能上会有一定的问题，这也就是我们经常看到“的锁一直处于饥饿状态”的问题，对于这种情况，可能就需要另寻他法了。</p><p>好了，至此整个<code>sync.Mutex</code>的分析就此结束了，虽然只有短短200行代码（包括150行注释，实际代码估计就50行），但是其中的算法、设计的思想、编程的理念却是值得感悟，所谓大道至简、少即是多可能就是如此吧。</p></div><div><div id="reward-container"><div>请博主喝杯咖啡~</div> <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';"> Donate</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="https://static.purewhite.io/wechat_pay.jpeg" alt="Pure White WeChat Pay"><p>WeChat Pay</p></div><div style="display:inline-block"> <img src="https://static.purewhite.io/alipay.jpeg" alt="Pure White Alipay"><p>Alipay</p></div></div></div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/后端/" rel="tag"># 后端</a> <a href="/tags/go/" rel="tag"># go</a> <a href="/tags/asm/" rel="tag"># asm</a></div><div class="post-widgets"><div class="wp_rating"><div id="wpac-rating"></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/03/25/golang-escape-check/" rel="next" title="golang逃逸分析"><i class="fa fa-chevron-left"></i> golang逃逸分析</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2019/04/01/golang-gc-consider-unsafe/" rel="prev" title="golang的GC如何处理unsafe.Pointer？">golang的GC如何处理unsafe.Pointer？<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> Overview</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://static.purewhite.io/avatar.jpg" alt="Pure White"><p class="site-author-name" itemprop="name">Pure White</p><div class="site-description motion-element" itemprop="description">青春不是年华，是心境；<br>青春不是桃面、丹唇、柔膝，<br>而是深沉的意志、恢弘的想象、<br>炽热的感情。</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">48</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/PureWhiteWu" title="GitHub &rarr; https://github.com/PureWhiteWu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:daniel48@126.com" title="E-Mail &rarr; mailto:daniel48@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://twitter.com/PureWhite_Wu" title="Twitter &rarr; https://twitter.com/PureWhite_Wu" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span><span class="links-of-author-item"><a href="https://www.linkedin.com/in/%E8%BF%AA-%E5%90%B4-846051106/" title="LinkedIn &rarr; https://www.linkedin.com/in/%E8%BF%AA-%E5%90%B4-846051106/" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i> LinkedIn</a></span><span class="links-of-author-item"><a href="https://telegram.me/PureWhiteWu" title="Telegram &rarr; https://telegram.me/PureWhiteWu" rel="noopener" target="_blank"><i class="fa fa-fw fa-telegram"></i> Telegram</a></span><span class="links-of-author-item"><a href="http://weibo.com/purewhitewu" title="微博 &rarr; http://weibo.com/purewhitewu" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i> 微博</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/PureWhite_Wu" title="知乎 &rarr; https://www.zhihu.com/people/PureWhite_Wu" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://static.purewhite.io/wechat.jpeg" title="微信 &rarr; https://static.purewhite.io/wechat.jpeg" rel="noopener" target="_blank"><i class="fa fa-fw fa-weixin"></i> 微信</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://blog.didispace.com/" title="http://blog.didispace.com/" rel="noopener" target="_blank">程序猿DD</a></li><li class="links-of-blogroll-item"> <a href="http://leoif.me/" title="http://leoif.me/" rel="noopener" target="_blank">leoif</a></li><li class="links-of-blogroll-item"> <a href="http://www.v2ex.com/?r=PureWhiteWu" title="http://www.v2ex.com/?r=PureWhiteWu" rel="noopener" target="_blank">v2ex</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引子"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁的性质"><span class="nav-number">2.</span> <span class="nav-text">锁的性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字段定义"><span class="nav-number">3.</span> <span class="nav-text">字段定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock"><span class="nav-number">4.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#atomic-CAS"><span class="nav-number">4.1.</span> <span class="nav-text">atomic.CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主流程"><span class="nav-number">4.2.</span> <span class="nav-text">主流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#canSpin"><span class="nav-number">4.3.</span> <span class="nav-text">canSpin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#doSpin"><span class="nav-number">4.4.</span> <span class="nav-text">doSpin</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unlock"><span class="nav-number">5.</span> <span class="nav-text">Unlock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> <a href="http://www.miitbeian.gov.cn" rel="noopener" target="_blank">沪ICP备15051443号-3</a> &copy; 2017 – <span itemprop="copyrightYear">2019</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Pure White</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Symbols count total:</span> <span title="Symbols count total">137k</span></div><div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div> <span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.0.1</div><script>!function(){var e=document.createElement("script");e.src="//tajs.qq.com/stats?sId=61888292";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/lib/reading_progress/reading_progress.js"></script><script src="/js/src/utils.js?v=7.0.1"></script><script src="/js/src/motion.js?v=7.0.1"></script><script src="/js/src/schemes/muse.js?v=7.0.1"></script><script src="/js/src/scrollspy.js?v=7.0.1"></script><script src="/js/src/post-details.js?v=7.0.1"></script><script src="/js/src/next-boot.js?v=7.0.1"></script><script src="/js/src/js.cookie.js?v=7.0.1"></script><script src="/js/src/scroll-cookie.js?v=7.0.1"></script><script id="dsq-count-scr" src="https://blog-zr0zqnlt9p.disqus.com/count.js" async></script><script>var disqus_config=function(){this.page.url="https://purewhite.io/2019/03/28/golang-mutex-source/",this.page.identifier="2019/03/28/golang-mutex-source/",this.page.title="源码剖析golang中sync.Mutex"};function loadComments(){var t=document,o=t.createElement("script");o.src="https://blog-zr0zqnlt9p.disqus.com/embed.js",o.setAttribute("data-timestamp",""+ +new Date),(t.head||t.body).appendChild(o)}$(function(){$("#comments").offset().top-$(window).height()<=0?loadComments():$(window).on("scroll.disqus_scroll",function(){$("#comments").offset().top-$(window).height()-$(window).scrollTop()<60&&($(window).off(".disqus_scroll"),loadComments())})})</script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=7.0.1"></script><script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text(counter.time + 1);
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'Sa9GIjpR90eFliBWzUAiUp9W-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'Sa9GIjpR90eFliBWzUAiUp9W-gzGzoHsz',
                'X-LC-Key': 'rSpeP2HoYIdOYJr4p2elMvLn',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>wpac_init=window.wpac_init||[],wpac_init.push({widget:"Rating",id:8500,el:"wpac-rating",color:"fc6423"}),function(){if(!("WIDGETPACK_LOADED"in window)){WIDGETPACK_LOADED=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//embed.widgetpack.com/widget.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t.nextSibling)}}()</script><script src="/lib/pangu/dist/pangu.min.js?v=3.3"></script><script>pangu.spacingPage()</script><script src="/lib/bookmark/bookmark.min.js?v=1.0"></script><script>bookmark.scrollToMark("auto","#more")</script><script>$(".highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("Copy").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=t,document.body.appendChild(n),n.select(),n.setSelectionRange(0,t.length),n.readOnly=!1,document.execCommand("copy")?$(this).text("Copied"):$(this).text("Copy failed"),n.blur(),$(this).blur()})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("Copy")},300)}).append(t)})</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="https://static.purewhite.io/favicon.jpg"><link rel="icon" type="image/png" sizes="32x32" href="https://static.purewhite.io/favicon.jpg"><link rel="icon" type="image/png" sizes="16x16" href="https://static.purewhite.io/favicon.jpg"><link rel="mask-icon" href="https://static.purewhite.io/favicon.jpg" color="#222"><meta name="google-site-verification" content="Xg_Hnp9ie-Rq7-zLPdd3c9dQtR_0N845ue4QaK8jvL4"><meta name="baidu-site-verification" content="c3b074df19d33f893845b6d092bc9169"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.purewhite.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":true,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"ZP9482CZD3","apiKey":"d26207a3ce8de9fe98e7af4215425c93","indexName":"Blog","hits":{"per_page":10}}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/config.min.js"></script><meta name="description" content="写在前面： 最近看到了一篇讲 Rust 如何对框架进行抽象的文章，写得非常好，这两天抽空翻译了一下。 原文：https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2021-05-14-inventing-the-service-trait  正文Tower是一个模块化和可重复使用的用来构建 client 和 server 的组件库。其核心是Service特性。一个Service是一个异步函数，它接受一个请"><meta property="og:type" content="article"><meta property="og:title" content="【译】Inventing the Service trait"><meta property="og:url" content="https://www.purewhite.io/2021/05/24/inventing-the-service-trait/index.html"><meta property="og:site_name" content="Pure White"><meta property="og:description" content="写在前面： 最近看到了一篇讲 Rust 如何对框架进行抽象的文章，写得非常好，这两天抽空翻译了一下。 原文：https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2021-05-14-inventing-the-service-trait  正文Tower是一个模块化和可重复使用的用来构建 client 和 server 的组件库。其核心是Service特性。一个Service是一个异步函数，它接受一个请"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-05-24T08:21:59.000Z"><meta property="article:modified_time" content="2021-12-02T12:51:07.000Z"><meta property="article:author" content="Pure White"><meta property="article:tag" content="rust"><meta property="article:tag" content="tokio"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.purewhite.io/2021/05/24/inventing-the-service-trait/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.purewhite.io/2021/05/24/inventing-the-service-trait/","path":"2021/05/24/inventing-the-service-trait/","title":"【译】Inventing the Service trait"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>【译】Inventing the Service trait | Pure White</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98194081-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-98194081-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/analytics/google-analytics.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/analytics/baidu-analytics.min.js"></script><script async src="https://hm.baidu.com/hm.js?587d2548655f9855727225afb0e4d708"></script><script async src="//assets.growingio.com/2.1/gio.js"></script><script class="next-config" data-name="growingio_analytics" type="application/json">"8a8c3a537a0132ac"</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/analytics/growingio.min.js"></script><script type="text/javascript">!function(t,e,n,a,c,s,i){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(s=e.createElement(a)).async=1,s.src="https://www.clarity.ms/tag/8mh5xasia9",(i=e.getElementsByTagName(a)[0]).parentNode.insertBefore(s,i)}(window,document,"clarity","script")</script><script>!function(){var e=document.createElement("script");e.src="https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?c75fd468cb92e13256468f9ae3917db97049a5a91566914dbb6ab879288745b8bc434964556b7d7129e9b750ed197d397efd7b0c6c715c1701396e1af40cec962b8d7c8c6655c9b00211740aa8a98e2e",e.id="ttzz";var c=document.getElementsByTagName("script")[0];c.parentNode.insertBefore(e,c)}(window)</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Pure White" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="Pure White" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Pure White</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">主业写bug，副业debug</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%A3%E6%96%87"><span class="nav-number">1.</span> <span class="nav-text">正文</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">2.</span> <span class="nav-text">添加更多的功能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Handlertrait"><span class="nav-number">3.</span> <span class="nav-text">Handlertrait</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A9Handler%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB"><span class="nav-number">4.</span> <span class="nav-text">让Handler更加灵活</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%80%9C%E5%A6%82%E6%9E%9C%E6%88%91%E5%91%8A%E8%AF%89%E4%BD%A0%E2%80%A6%E2%80%A6%E2%80%9D"><span class="nav-number">5.</span> <span class="nav-text">“如果我告诉你……”</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Backpressure"><span class="nav-number">6.</span> <span class="nav-text">Backpressure</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%84%9A%E6%B3%A8"><span class="nav-number">7.</span> <span class="nav-text">脚注</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Pure White" src="https://static.purewhite.io/avatar.jpg!webp_90"><p class="site-author-name" itemprop="name">Pure White</p><div class="site-description" itemprop="description">青春不是年华，是心境；<br>青春不是桃面、丹唇、柔膝，<br>而是深沉的意志、恢弘的想象、<br>炽热的感情。</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">29</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/PureWhiteWu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PureWhiteWu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:me@purewhite.io" title="E-Mail → mailto:me@purewhite.io" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://twitter.com/PureWhite_Wu" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;PureWhite_Wu" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i> Twitter</a></span><span class="links-of-author-item"><a href="https://www.linkedin.com/in/%E8%BF%AA-%E5%90%B4-846051106/" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;%E8%BF%AA-%E5%90%B4-846051106&#x2F;" rel="noopener me" target="_blank"><i class="fa fa-linkedin fa-fw"></i> LinkedIn</a></span><span class="links-of-author-item"><a href="https://telegram.me/PureWhiteWu" title="Telegram → https:&#x2F;&#x2F;telegram.me&#x2F;PureWhiteWu" rel="noopener me" target="_blank"><i class="fa fa-telegram fa-fw"></i> Telegram</a></span><span class="links-of-author-item"><a href="http://weibo.com/purewhitewu" title="微博 → http:&#x2F;&#x2F;weibo.com&#x2F;purewhitewu" rel="noopener me" target="_blank"><i class="fa fa-weibo fa-fw"></i> 微博</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/PureWhite_Wu" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;PureWhite_Wu" rel="noopener me" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://static.purewhite.io/wechat_channel.jpg" title="微信 → https:&#x2F;&#x2F;static.purewhite.io&#x2F;wechat_channel.jpg" rel="noopener me" target="_blank"><i class="fa fa-weixin fa-fw"></i> 微信</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.didispace.com/" title="https:&#x2F;&#x2F;www.didispace.com&#x2F;" rel="noopener" target="_blank">程序猿DD</a></li><li class="links-of-blogroll-item"> <a href="https://www.v2ex.com/?r=PureWhiteWu" title="https:&#x2F;&#x2F;www.v2ex.com&#x2F;?r&#x3D;PureWhiteWu" rel="noopener" target="_blank">v2ex</a></li><li class="links-of-blogroll-item"> <a href="https://yuzhouwan.com/" title="https:&#x2F;&#x2F;yuzhouwan.com&#x2F;" rel="noopener" target="_blank">宇宙湾</a></li><li class="links-of-blogroll-item"> <a href="https://www.ibyte.me/" title="https:&#x2F;&#x2F;www.ibyte.me&#x2F;" rel="noopener" target="_blank">Leon Ding</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.purewhite.io/2021/05/24/inventing-the-service-trait/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://static.purewhite.io/avatar.jpg!webp_90"><meta itemprop="name" content="Pure White"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Pure White"><meta itemprop="description" content="青春不是年华，是心境；<br />青春不是桃面、丹唇、柔膝，<br />而是深沉的意志、恢弘的想象、<br />炽热的感情。"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="【译】Inventing the Service trait | Pure White"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 【译】Inventing the Service trait</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-05-24 16:21:59" itemprop="dateCreated datePublished" datetime="2021-05-24T16:21:59+08:00">2021-05-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-12-02 20:51:07" itemprop="dateModified" datetime="2021-12-02T20:51:07+08:00">2021-12-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a></span></span><span id="/2021/05/24/inventing-the-service-trait/" class="post-meta-item leancloud_visitors" data-flag-title="【译】Inventing the Service trait" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Disqus：</span><a title="disqus" href="/2021/05/24/inventing-the-service-trait/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/05/24/inventing-the-service-trait/" itemprop="commentCount"></span></a></span><span class="post-meta-break"></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>6.5k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>写在前面：</p><p>最近看到了一篇讲 Rust 如何对框架进行抽象的文章，写得非常好，这两天抽空翻译了一下。</p><p>原文：<a target="_blank" rel="noopener" href="https://tokio.rs/blog/2021-05-14-inventing-the-service-trait">https://tokio.rs/blog/2021-05-14-inventing-the-service-trait</a></p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><a target="_blank" rel="noopener" href="https://github.com/tower-rs/tower"><code>Tower</code></a>是一个模块化和可重复使用的用来构建 client 和 server 的组件库。其核心是<a target="_blank" rel="noopener" href="https://docs.rs/tower/latest/tower/trait.Service.html"><code>Service</code></a>特性。一个<code>Service</code>是一个异步函数，它接受一个请求并产生一个响应。然而，<code>Tower</code>设计的某些方面可能不是那么一目了然。</p><p>与其解释今天存在于<code>Tower</code>中的<code>Service</code>特性，不如来看看<code>Service</code>背后的设计考量。让我们试试看，如果今天重新设计实现它，我们会怎么做。</p><span id="more"></span><p>想象一下，你正在用 Rust 构建一个简单的 HTTP 框架。这个框架将允许用户提供接收请求并返回响应的处理逻辑来实现一个 HTTP 服务器。你可能会有这么一个 API：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个在 3000 端口监听的服务器</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">server</span> = Server::<span class="title function_ invoke__">new</span>(<span class="string">&quot;127.0.0.1:3000&quot;</span>).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以某种方式运行用户的应用程序</span></span><br><span class="line">server.<span class="title function_ invoke__">run</span>(the_users_application).<span class="keyword">await</span>?</span><br></pre></td></tr></table></figure><p>现在问题来了，<code>the_users_application</code>应该是什么？</p><p>最简单的一个实现，可能是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_request</span>(request: HttpRequest) <span class="punctuation">-&gt;</span> HttpResponse &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>HttpRequest</code>和<code>HttpResponse</code>是由我们的框架提供的一些结构。有了这个，我们就可以这样实现<code>Server::run</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">run</span>&lt;F&gt;(<span class="keyword">self</span>, handler: F) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">Fn</span>(HttpRequest) <span class="punctuation">-&gt;</span> HttpResponse,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="keyword">self</span>.addr).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">connection</span> = listener.<span class="title function_ invoke__">accept</span>().<span class="keyword">await</span>?</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">request</span> = <span class="title function_ invoke__">read_http_request</span>(&amp;<span class="keyword">mut</span> connection).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用由用户提供的处理程序</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">handler</span>(request);</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">write_http_response</span>(connection).<span class="keyword">await</span>?</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们有一个异步函数<code>run</code>，它接受一个闭包，这个闭包接受一个<code>HttpRequest</code>并返回<code>HttpResponse</code>。用户可以像这样使用我们的<code>server</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_request</span>(request: HttpRequest) <span class="punctuation">-&gt;</span> HttpResponse &#123;</span><br><span class="line">    <span class="keyword">if</span> request.<span class="title function_ invoke__">path</span>() == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">        HttpResponse::<span class="title function_ invoke__">ok</span>(<span class="string">&quot;Hello, World!&quot;</span> )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HttpResponse::<span class="title function_ invoke__">not_found</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行服务器并使用我们的 handle_request 函数处理请求</span></span><br><span class="line">server.<span class="title function_ invoke__">run</span>(handle_request).<span class="keyword">await</span>?</span><br></pre></td></tr></table></figure><p>感觉还行，它让用户可以很容易地运行 HTTP 服务器而不必担心任何低层次的细节。</p><p>然而，我们目前的设计有一个问题：我们无法处理异步地处理请求。想象一下，我们的用户需要查询一个数据库，或者在处理请求的同时发送一个请求给其他服务器。目前，这样会导致我们需要同步等待 handler 的返回结果，从而导致了<a target="_blank" rel="noopener" href="https://ryhl.io/blog/async-what-is-blocking/">阻塞</a>。</p><p>如果我们希望我们的服务器能够处理大量的并发连接，我们需要在等待该请求异步完成的同时为其他请求提供服务。我们可以通过让 handler 返回一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/future/trait.Future.html"><code>future</code></a>来解决这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">run</span>&lt;F, Fut&gt;(<span class="keyword">self</span>, handler: F) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="comment">// handler 现在返回一个通用类型的 Fut</span></span><br><span class="line">        F: <span class="title function_ invoke__">Fn</span>(HttpRequest) <span class="punctuation">-&gt;</span> Fut,</span><br><span class="line">        <span class="comment">// FUT 是一个 Future，其输出是一个 HttpResponse</span></span><br><span class="line">        Fut: Future&lt;Output = HttpResponse&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="keyword">self</span>.addr).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">connection</span> = listener.<span class="title function_ invoke__">accept</span>().<span class="keyword">await</span>?</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">request</span> = <span class="title function_ invoke__">read_http_request</span>(&amp;<span class="keyword">mut</span> connection).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待由 handler 返回的 Future</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">handler</span>(request).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">write_http_response</span>(connection).<span class="keyword">await</span>?</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API 的用法和之前差不多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在是一个异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">handle_request</span>(request: HttpRequest) <span class="punctuation">-&gt;</span> HttpResponse &#123;</span><br><span class="line">    <span class="keyword">if</span> request.<span class="title function_ invoke__">path</span>() == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">        HttpResponse::<span class="title function_ invoke__">ok</span>(<span class="string">&quot;Hello, World!&quot;</span> )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> request.<span class="title function_ invoke__">path</span>() == <span class="string">&quot;/important-data&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 我们现在可以在这里做异步的事情了</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">some_data</span> = <span class="title function_ invoke__">fetch_data_from_database</span>().<span class="keyword">await</span>;</span><br><span class="line">        <span class="title function_ invoke__">make_response</span>(some_data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HttpResponse::<span class="title function_ invoke__">not_found</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行 server 也是一样的</span></span><br><span class="line">server.<span class="title function_ invoke__">run</span>(handle_request).<span class="keyword">await</span>?</span><br></pre></td></tr></table></figure><p>这就比之前要好很多了，因为我们的 handler 现在可以调用其他异步函数啦。然而，我们仍然缺了点啥——如果我们的处理程序出错了怎么办？我们可以让 Handler 返回一个<code>Result</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">run</span>&lt;F, Fut&gt;(<span class="keyword">self</span>, handler: F) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">Fn</span>(HttpRequest) <span class="punctuation">-&gt;</span> Fut,</span><br><span class="line">        <span class="comment">// 响应的 Future 允许返回 Error</span></span><br><span class="line">        Fut: Future&lt;Output = <span class="type">Result</span>&lt;HttpResponse, Error&gt;&gt;。</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="keyword">self</span>.addr).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">connection</span> = listener.<span class="title function_ invoke__">accept</span>().<span class="keyword">await</span>?</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">request</span> = <span class="title function_ invoke__">read_http_request</span>(&amp;<span class="keyword">mut</span> connection).<span class="keyword">await</span>?</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对响应的 Future 进行模式匹配</span></span><br><span class="line">            <span class="keyword">match</span> <span class="title function_ invoke__">handler</span>(request).<span class="keyword">await</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(response) =&gt; <span class="title function_ invoke__">write_http_response</span>(connection).<span class="keyword">await</span>?</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="title function_ invoke__">handle_error_somehow</span>(error, connection)。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加更多的功能"><a href="#添加更多的功能" class="headerlink" title="添加更多的功能"></a>添加更多的功能</h1><p>现在，假设我们想确保所有的请求都能及时完成或失败，而不是让客户端无限期地等待一个可能永远不会有的响应。</p><p>我们可以通过给每个请求添加一个超时来做到这一点。一个超时设置了<code>handler</code>允许持续的最大时间的限制。如果它在这个时间内没有产生响应，就会返回一个错误。这使得客户端可以重试该请求或向用户报告错误，而不是永远等待。</p><p>最简单的方法可能是去修改<code>Server</code>，使其可以配置一个超时，然后在每次调用<code>handler</code>时应用该超时。然而，其实你也可以在不修改<code>Server</code>的情况下添加一个超时。使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/latest/tokio/time/fn.timeout.html"><code>tokio::time::timeout</code></a>，我们可以写一个新的处理函数，让它调用我们之前的<code>handle_request</code>，并且设置超时时间为 30 秒：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">handler_with_timeout</span>(request: HttpRequest) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;HttpResponse, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = tokio::time::<span class="title function_ invoke__">timeout</span>(</span><br><span class="line">        Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">30</span>),</span><br><span class="line">        <span class="title function_ invoke__">handle_request</span>(request)</span><br><span class="line">    ).<span class="keyword">await</span>。</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Ok</span>(response)) =&gt; <span class="title function_ invoke__">Ok</span>(response)。</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Err</span>(error)) =&gt; <span class="title function_ invoke__">Err</span>(error),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_timeout_elapsed) =&gt; <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">timeout</span>() )。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这提供了一个相当好的抽象，我们能够添加一个超时器而不改变任何现有的代码。</p><p>让我们用这种方式再增加一个功能。想象一下，我们正在写一个 JSON API，并且希望在所有的响应上有一个<code>Content-Type: application/json</code>的头。我们可以用类似的方式包装<code>handler_with_timeout</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">handler_with_timeout_and_content_type</span>(</span><br><span class="line">    request: HttpRequest,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;HttpResponse, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response</span> = <span class="title function_ invoke__">handler_with_timeout</span>(request).<span class="keyword">await</span>?</span><br><span class="line">    response.<span class="title function_ invoke__">set_header</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)。</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在有了一个处理程序，它将处理一个 HTTP 请求，超时为 30 秒，并且会设置好正确的<code>Content-Type</code>头，所有这些都不需要修改我们原来的<code>handle_request</code>函数或<code>Server</code>结构。</p><p>设计可以以这种方式扩展的库是非常强大的，因为它允许用户通过增加一层新行为来扩展库的功能，而不需要等待库的维护者为其添加支持。</p><p>它也使测试变得更容易，因为你可以把你的代码分解成小的隔离的孤立的单元，并为它们编写细粒度的测试，而不必担心其他的部分。</p><p>然而，又有了一个问题：我们目前的设计是套娃，也就是实现一个处理函数来实现功能，并在其内部调用其他处理函数。这能 work，但如果我们想增加更多的额外功能，它并不能很好地扩展。</p><p>想象一下，我们有许多<code>handle_with_*</code>函数，每一个都增加了一点儿新的行为。要硬编码谁调用谁的这个调用链将成为一种挑战。我们目前的调用链是：</p><ol><li><code>handler_with_timeout_and_content_type</code>，调用</li><li><code>handler_with_timeout</code>，调用</li><li><code>handle_request</code>，实际处理请求。</li></ol><p>如果我们能以某种方式<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Function_composition">组合</a>这三个函数而不需要硬编码确切的顺序，那就更好了，就像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">final_handler</span> = <span class="title function_ invoke__">with_content_type</span>(<span class="title function_ invoke__">with_timeout</span>(handle_request));</span><br></pre></td></tr></table></figure><p>同时仍然能够像以前一样运行我们的处理程序。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_ invoke__">run</span>(final_handler).<span class="keyword">await</span>?</span><br></pre></td></tr></table></figure><p>你可以把<code>with_content_type</code>和<code>with_timeout</code>作为函数来实现，该函数接受一个<code>F: Fn(HttpRequest) -&gt; Future&lt;Output = Result&lt;HttpResponse, Error&gt;</code>的参数并返回一个<code>impl Fn(HttpRequest) -&gt; Future&lt;Output = Result&lt;HttpResponse, Error&gt;&gt;</code>的闭包。这也不是不行，但所有这些闭包类型会很快变得难以处理。</p><h1 id="Handlertrait"><a href="#Handlertrait" class="headerlink" title="Handlertrait"></a><code>Handler</code>trait</h1><p>让我们来尝试另一种方法。与其让<code>Server::run</code>接受了一个闭包(<code>Fn(HttpRequest) -&gt; …</code>)，不如让我们定义一个新的 trait 来封装<code>async fn(HttpRequest) -&gt; Result&lt;HttpResponse, Error&gt;</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;HttpResponse, Error&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这样一个 trait，我们就可以编写实现它的具体类型，这样我们就不必到处用<code>Fn</code>了。</p><p>然而，Rust 目前不支持 async trait 方法，所以我们有两个选择：</p><ol><li>让<code>call</code>返回一个 Boxed Future，如<code>Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;HttpResponse, Error&gt;&gt;</code>。这也就是<a target="_blank" rel="noopener" href="https://crates.io/crates/async-trait"><code>async-trait</code></a>干的事。</li><li>在<code>Handler</code>中添加一个关联的<code>type Future</code>，这样用户就可以指定自己的类型。</li></ol><p>我们采用方案二，因为它是最灵活的。有一个具体的 Future 类型的用户可以避免<code>Box</code>的开销，而不在乎的用户也可以使用<code>Pin&lt;Box&lt;...&gt;&gt;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">handler</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span>: Future&lt;Output = <span class="type">Result</span>&lt;HttpResponse, Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仍然要求<code>Handler::Future</code>实现输出为<code>Result&lt;HttpResponse, Error&gt;</code>的<code>Future</code>，因为那是<code>Server::run</code>的要求。</p><p>让<code>call</code>接受<code>&amp;mut self</code>是有用的，因为它允许处理程序在必要时更新他们的内部状态<sup><a href="#pin">1</a></sup>。</p><p>让我们把原来的<code>handle_request</code>函数转换为使用这个特性的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RequestHandler</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Handler</span> <span class="keyword">for</span> <span class="title class_">RequestHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 为了简单起见，我们在这里使用 Pin&lt;Box&lt;...&gt;&gt;，但也可以定义我们的</span></span><br><span class="line">    <span class="comment">// 自己的 Future 类型，以避免开销。</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span> = Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="type">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="comment">// 与我们之前的实现相同</span></span><br><span class="line">            <span class="keyword">if</span> request.<span class="title function_ invoke__">path</span>() == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(HttpResponse::<span class="title function_ invoke__">ok</span>(<span class="string">&quot;Hello, World!&quot;</span>))</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> request.<span class="title function_ invoke__">path</span>() == <span class="string">&quot;/important-data&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">some_data</span> = <span class="title function_ invoke__">fetch_data_from_database</span>().<span class="keyword">await</span>?;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">make_response</span>(some_data))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(HttpResponse::<span class="title function_ invoke__">not_found</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们如何基于这个实现超时呢？请记住，我们的目标是允许我们在不修改每个单独部分的情况下，将不同的功能组合在一起。</p><p>我们可以定义一个通用的<code>Timeout</code>结构，就像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Timeout</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// T 实现了`Handler&#x27;的类型</span></span><br><span class="line">    inner_handler: T,</span><br><span class="line">    duration: Duration,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以为<code>Timeout&lt;T&gt;</code>实现<code>Handler</code>并委托给<code>T</code>的<code>Handler</code>实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> <span class="title class_">Timeout</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Handler,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span> = Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="type">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">result</span> = tokio::time::<span class="title function_ invoke__">timeout</span>(</span><br><span class="line">                <span class="keyword">self</span>.duration,</span><br><span class="line">                <span class="keyword">self</span>.inner_handler.<span class="title function_ invoke__">call</span>(request),</span><br><span class="line">            ).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> result &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Ok</span>(response)) =&gt; <span class="title function_ invoke__">Ok</span>(response),</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Err</span>(error)) =&gt; <span class="title function_ invoke__">Err</span>(error),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_timeout) =&gt; <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">timeout</span>()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重要的一行是<code>self.inner_handler.call(request)</code>，在这我们继续调用内部处理程序，让它做自己的事情而不管关它是什么。我们只需要知道它完成后会返回一个<code>Result&lt;HttpResponse, Error&gt;</code>。</p><p>但是，这段代码编译不过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0759]: `<span class="keyword">self</span>` has an anonymous lifetime `<span class="symbol">&#x27;_</span>` but it needs to satisfy a `<span class="symbol">&#x27;static</span>` lifetime requirement</span><br><span class="line">   -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">145</span>:<span class="number">29</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">144</span> |       <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">    |               --------- this data with an anonymous lifetime `<span class="symbol">&#x27;_</span>`...</span><br><span class="line"><span class="number">145</span> |           <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    |  _____________________________^</span><br><span class="line"><span class="number">146</span> | |             <span class="keyword">let</span> <span class="variable">result</span> = tokio::time::<span class="title function_ invoke__">timeout</span>(</span><br><span class="line"><span class="number">147</span> | |                 <span class="keyword">self</span>.duration,</span><br><span class="line"><span class="number">148</span> | |                 <span class="keyword">self</span>.inner_handler.<span class="title function_ invoke__">call</span>(request),</span><br><span class="line">...   |</span><br><span class="line"><span class="number">155</span> | |             &#125;</span><br><span class="line"><span class="number">156</span> | |         &#125;)</span><br><span class="line">    | |_________^ ...is captured here, requiring it to live <span class="keyword">as</span> long <span class="keyword">as</span> `<span class="symbol">&#x27;static</span>`</span><br></pre></td></tr></table></figure><p>编译出错的原因是，我们正在捕获一个<code>&amp;mut self</code>并将其移到一个异步的代码块中。这意味着我们的 Future 和<code>&amp;mut self</code>的生命周期是相同的。但是这并不符合我们的预期，因为我们可能想在多个线程上运行我们的 Future 以获得更好的性能，或者产生多个 Future 并将它们全部并行运行。如果对 handler 的引用存在于 Future<sup><a href="#gats">2</a></sup> 中，这就不可能了。</p><p>因此，我们需要将<code>&amp;mut self</code>转换为一个有所有权的<code>self</code>。这正是<code>Clone</code>所做的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这必须是 Clone，才能使 Timeout&lt;T&gt; 成为 Clone</span></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RequestHandler</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Handler</span> <span class="keyword">for</span> <span class="title class_">RequestHandler</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timeout</span>&lt;T&gt; &#123;</span><br><span class="line">    inner_handler: T,</span><br><span class="line">    duration: Duration,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> <span class="title class_">Timeout</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Handler + <span class="built_in">Clone</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span> = Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="type">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">        <span class="comment">// 获得`&amp;mut self`的所有权</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">this</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">result</span> = tokio::time::<span class="title function_ invoke__">timeout</span>(</span><br><span class="line">                this.duration,</span><br><span class="line">                this.inner_handler.<span class="title function_ invoke__">call</span>(request),</span><br><span class="line">            ).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> result &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Ok</span>(response)) =&gt; <span class="title function_ invoke__">Ok</span>(response),</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Err</span>(error)) =&gt; <span class="title function_ invoke__">Err</span>(error),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_timeout) =&gt; <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">timeout</span>()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在这种情况下，clone 是非常便宜的，因为<code>RequestHandler</code>没有任何数据，<code>Timeout&lt;T&gt;</code>只增加了一个<code>Duration</code>（也就是实际上是<code>Copy</code>）。</p><p>好，我们现在更进一步了，现在我们得到了另一个错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0310]: the parameter <span class="keyword">type</span> `T` may not live long enough</span><br><span class="line">   -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">149</span>:<span class="number">9</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">140</span> |   <span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> <span class="title class_">Timeout</span>&lt;T&gt;</span><br><span class="line">    |        - help: consider adding an explicit lifetime bound...: `T: <span class="symbol">&#x27;static</span>`</span><br><span class="line">...</span><br><span class="line"><span class="number">149</span> | /         <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line"><span class="number">150</span> | |             <span class="keyword">let</span> <span class="variable">result</span> = tokio::time::<span class="title function_ invoke__">timeout</span>(</span><br><span class="line"><span class="number">151</span> | |                 this.duration,</span><br><span class="line"><span class="number">152</span> | |                 this.inner_handler.<span class="title function_ invoke__">call</span>(request),</span><br><span class="line">...   |</span><br><span class="line"><span class="number">159</span> | |             &#125;</span><br><span class="line"><span class="number">160</span> | |         &#125;)</span><br><span class="line">    | |__________^ ...so that the <span class="keyword">type</span> `<span class="keyword">impl</span> <span class="title class_">Future</span>` will meet its required lifetime bounds</span><br></pre></td></tr></table></figure><p>现在的问题是，因为<code>T</code>可以是任何类型。它甚至可以是一个包含引用的类型，比如<code>Vec&lt;&amp;&#39;a str&gt;</code>。然而这就拉胯了，原因和之前一样。我们需要返回的 Future 有一个<code>&#39;static</code>的生命周期，这样我们可以更容易地传递它。</p><p>编译器实际上已经告诉了我们该如何解决——加个<code>T: &#39;static&#39;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> <span class="title class_">Timeout</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Handler + <span class="built_in">Clone</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 Future 现在满足了<code>&#39;static&#39;</code>寿命的要求，因为它不包含引用（并且任何<code>T</code>包含的引用都是<code>&#39;static&#39;</code>的）。现在，我们的代码可以编译了！</p><p>让我们创建一个类似的 handler 在响应中添加<code>Content-Type</code>头：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">JsonContentType</span>&lt;T&gt; &#123;</span><br><span class="line">    inner_handler: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Handler <span class="keyword">for</span> <span class="title class_">JsonContentType</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Handler + <span class="built_in">Clone</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span> = Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="type">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: HttpRequest) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">this</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response</span> = this.inner_handler.<span class="title function_ invoke__">call</span>(request).<span class="keyword">await</span>?;</span><br><span class="line">            response.<span class="title function_ invoke__">set_header</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(response)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与<code>Timeout</code>的模式非常相似。</p><p>接下来我们修改<code>Server::run</code>以接受我们新的<code>Handler Trait</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">run</span>&lt;T&gt;(<span class="keyword">self</span>, <span class="keyword">mut</span> handler: T) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: Handler,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="keyword">self</span>.addr).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">connection</span> = listener.<span class="title function_ invoke__">accept</span>().<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">request</span> = <span class="title function_ invoke__">read_http_request</span>(&amp;<span class="keyword">mut</span> connection).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// have to call `Handler::call` here</span></span><br><span class="line">            <span class="keyword">match</span> handler.<span class="title function_ invoke__">call</span>(request).<span class="keyword">await</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(response) =&gt; <span class="title function_ invoke__">write_http_response</span>(connection, response).<span class="keyword">await</span>?,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="title function_ invoke__">handle_error_somehow</span>(error, connection),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在可以将我们的三个 handler 组合在一起：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JsonContentType &#123;</span><br><span class="line">    inner_handler: Timeout &#123;</span><br><span class="line">        inner_handler: RequestHandler,</span><br><span class="line">        duration: Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">30</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们给我们的类型添加一些<code>new</code>方法，那就更容易构建啦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handler</span> = RequestHandler;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handler</span> = Timeout::<span class="title function_ invoke__">new</span>(handler, Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handler</span> = JsonContentType::<span class="title function_ invoke__">new</span>(handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `handler` has type `JsonContentType&lt;Timeout&lt;RequestHandler&gt;&gt;`</span></span><br><span class="line"></span><br><span class="line">server.<span class="title function_ invoke__">run</span>(handler).<span class="keyword">await</span></span><br></pre></td></tr></table></figure><p>搞定！我们现在可以为<code>RequestHandler</code>增加额外的功能而不必修改它的实现。理论上，我们可以把我们的<code>JsonContentType</code>和<code>Timeout</code> handler 放到一个<code>crate</code>中，然后在<code>crates.io</code>上把它作为一个库发布供其他用户使用！</p><h1 id="让Handler更加灵活"><a href="#让Handler更加灵活" class="headerlink" title="让Handler更加灵活"></a>让<code>Handler</code>更加灵活</h1><p>我们的<code>Handler trait</code>看着还不错，但目前它只支持我们的<code>HttpRequest</code>和<code>HttpResponse</code>类型。如果这些变成了泛型，用户就可以使用他们想要的任何类型。</p><p>我们将 Request 作为 Trait 的泛型参数，这样服务就可以接受许多不同类型的请求。这样，我们的 handler 就可以用于不同的协议，而不仅仅是 HTTP 了。我们定义 Response 为一个关联类型，因为对于任意给定的请求类型，只能有且只有一种（相关的）响应类型：对应的调用返回的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Handler</span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Response</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误也应该是一个关联类型。没有理由让它成为一个</span></span><br><span class="line">    <span class="comment">// 硬编码的类型</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前的 Future 类型，但现在它的输出必须使用</span></span><br><span class="line">    <span class="comment">// 相关的 Response 和 Error 类型。</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span>: Future&lt;Output = <span class="type">Result</span>&lt;<span class="keyword">Self</span>::Response, <span class="keyword">Self</span>::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  call 没有变化，但注意这里的 Request 是个泛型，</span></span><br><span class="line">    <span class="comment">//  而不是我们之前所使用的 HttpRequest 类型。</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: Request) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对<code>RequestHandler</code>的实现现在变成了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Handler</span>&lt;HttpRequest&gt; <span class="keyword">for</span> <span class="title class_">RequestHandler</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Response</span> = HttpResponse;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = Error;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span> = Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="type">Result</span>&lt;HttpResponse, Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: Request) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">        <span class="comment">// 和之前一样</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Timeout&lt;T&gt;</code>则有点不同，因为它包装了一些其他的<code>Handler</code>，并添加了一个异步超时，它实际上并不关心请求或响应类型是什么，只要它所包装的<code>Handler</code>使用相同的类型。</p><p>而<code>Error</code>类型则有点不同。因为<code>tokio::time::timeout</code>会返回<code>Result&lt;T, tokio::time::error::Elapsed&gt;</code>，我们必须能够把<code>tokio::time::error::Elapsed</code>转换成内部<code>Handler</code>的错误类型。</p><p>如果我们把所有这些东西组合在一起，我们就能获得：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Timeout`接受任何类型的`R`的请求，只要和`T`接受相同类型的请求</span></span><br><span class="line"><span class="keyword">impl</span>&lt;R, T&gt; Handler&lt;R&gt; <span class="keyword">for</span> <span class="title class_">Timeout</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="comment">// 实际的请求类型必须不包含</span></span><br><span class="line">    <span class="comment">// 引用。编译器会告诉我们要添加</span></span><br><span class="line">    <span class="comment">// 这个，如果我们不这样做的话</span></span><br><span class="line">    R: <span class="symbol">&#x27;static</span>,</span><br><span class="line">    <span class="comment">// `T`必须接受`R`类型的请求</span></span><br><span class="line">    T: Handler&lt;R&gt; + <span class="built_in">Clone</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    <span class="comment">// 我们必须能够将一个超时的请求转换为</span></span><br><span class="line">    <span class="comment">// `T`的错误类型</span></span><br><span class="line">    T::Error: <span class="built_in">From</span>&lt;tokio::time::error::Elapsed&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 我们的响应类型与`T`相同，因此我们</span></span><br><span class="line">    <span class="comment">// 不需要修改它</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Response</span> = T::Response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误类型也是一样的</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = T::Error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Future 必须输出一个具有正确类型的`Result`。</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span> = Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="type">Result</span>&lt;T::Response, T::Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: R) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">this</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">result</span> = tokio::time::<span class="title function_ invoke__">timeout</span>(</span><br><span class="line">                this.duration,</span><br><span class="line">                this.inner_handler.<span class="title function_ invoke__">call</span>(request),</span><br><span class="line">            ).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> result &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Ok</span>(response)) =&gt; <span class="title function_ invoke__">Ok</span>(response),</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Err</span>(error)) =&gt; <span class="title function_ invoke__">Err</span>(error),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(elapsed) =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 转换错误类型</span></span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(T::Error::<span class="title function_ invoke__">from</span>(elapsed))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JsonContentType</code>也有点不同。它不关心请求或错误类型，但它关心响应类型。它必须是<code>Response</code>，这样我们才能调用<code>set_header</code>。</p><p>因此，实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还是一个通用的请求类型</span></span><br><span class="line"><span class="keyword">impl</span>&lt;R, T&gt; Handler&lt;R&gt; <span class="keyword">for</span> <span class="title class_">JsonContentType</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    R: <span class="symbol">&#x27;static</span>,</span><br><span class="line">    <span class="comment">// `T`必须接受任何类型的`R`的请求，并返回`HttpResponse`类型的响应。</span></span><br><span class="line">    T: Handler&lt;R, Response = HttpResponse&gt; + <span class="built_in">Clone</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Response</span> = HttpResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的错误类型和`T`一致</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = T::Error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span> = Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="type">Result</span>&lt;Response, T::Error&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: R) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">this</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response</span> = this.inner_handler.<span class="title function_ invoke__">call</span>(request).<span class="keyword">await</span>?;</span><br><span class="line">            response.<span class="title function_ invoke__">set_header</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(response)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，传递给<code>Server::run</code>的<code>Handler</code>必须使用<code>HttpRequest</code>和<code>HttpResponse</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">run</span>&lt;T&gt;(<span class="keyword">self</span>, <span class="keyword">mut</span> handler: T) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: Handler&lt;HttpRequest, Response = HttpResponse&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 server 的代码不需要变：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handler</span> = RequestHandler;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handler</span> = Timeout::<span class="title function_ invoke__">new</span>(handler, Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handler</span> = JsonContentType::<span class="title function_ invoke__">new</span>(handler);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_ invoke__">run</span>(handler).<span class="keyword">await</span></span><br></pre></td></tr></table></figure><p>到目前为止，我们有了一个<code>Handler trait</code>，这可以将我们的应用程序分解成独立的小部分，并可以复用。看着不错！</p><h1 id="“如果我告诉你……”"><a href="#“如果我告诉你……”" class="headerlink" title="“如果我告诉你……”"></a>“如果我告诉你……”</h1><p>到目前为止，我们只讨论了 server 方面的事情。但是实际上，我们的<code>Handler trait</code>也适用于 HTTP 客户端。比如，我们可以想象有个客户端的<code>Handler</code>接受一些请求并异步地将其发送给互联网上的某 server，我们的<code>Timeout</code>包装器在这里也很有用。<code>JsonContentType</code>可能没啥用，因为设置响应头不是客户端的工作。</p><p>由于我们的<code>Handler trait</code>对于定义服务器和客户端都很有用，<code>Handler</code>可能不是一个合适的名字，毕竟客户端并不处理一个请求，它将请求发送给服务器，然后由服务器来处理它。让我们改称我们的 trait 为<code>Service</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Service</span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Response</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span>: Future&lt;Output = <span class="type">Result</span>&lt;<span class="keyword">Self</span>::Response, <span class="keyword">Self</span>::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: Request) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上<em>几乎</em>就是<code>Tower</code>中定义的<code>Service trait</code>了。如果你已经跟着看到了这里，你现在已经了解了<code>Tower</code>的大部分内容了。除了<code>Service trait</code>，<code>Tower</code>还提供了一些实用工具，通过包装其它的<code>Service</code>并实现一个<code>Service</code>，就像我们对<code>Timeout</code>和<code>JsonContentType</code>所做的那样。这些<code>Service</code>的组成方式与我们到目前为止所做的类似。</p><p>以下是一些由<code>Tower</code>提供的<code>Service</code>示例：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.rs/tower/latest/tower/timeout/index.html"><code>Timeout</code></a>——这与我们之前实现的超时基本相同。</li><li><a target="_blank" rel="noopener" href="https://docs.rs/tower/latest/tower/retry/index.html"><code>Retry</code></a>——自动重试失败的请求。</li><li><a target="_blank" rel="noopener" href="https://docs.rs/tower/latest/tower/limit/rate/index.html"><code>RateLimit</code></a>——限制一个服务在一段时间内收到的请求数量。</li></ul><p>像<code>Timeout</code>和<code>JsonContentType</code>这样的类型通常被称为<em>中间件</em>，因为它们包裹着另一个<code>Service</code>并以某种方式对请求或响应进行处理。像<code>RequestHandler</code>这样的类型通常被称为<code>叶子服务</code>，因为它们位于嵌套服务树的叶子上。实际的响应通常是在叶子服务中产生，并由中间件修改。</p><p>好了，到这里唯一（唯二？）我们剩下还没聊的是<em>backpressure</em>和<a target="_blank" rel="noopener" href="https://docs.rs/tower/0.4.7/tower/trait.Service.html#tymethod.poll_ready"><code>poll_ready</code></a>。</p><h1 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h1><p>想象一下，现在你想写一个限制请求速率的中间件，来包装一个<code>Service</code>，以对底层服务的最大并发请求数进行限制。如果你的服务对它的负载量有一个硬性的上限，这将是非常有用的。</p><p>在我们目前的<code>Service trait</code>中，我们并没有一个好的方法来实现这样的东西，我们可以尝试这样做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;R, T&gt; Service&lt;R&gt; <span class="keyword">for</span> <span class="title class_">ConcurrencyLimit</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, request: R) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">        <span class="comment">// 1. 检查当前正在处理的请求数的计数器。</span></span><br><span class="line">        <span class="comment">// 2. 如果有剩余的容量，将请求发送到`T`，并增加计数器。</span></span><br><span class="line">        <span class="comment">// 3. 如果没有，则等到有能力时再进行处理。</span></span><br><span class="line">        <span class="comment">// 4. 当返回响应后，减去计数器。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有剩余的容量，我们必须等待，并在容量可用时以某种方式得到通知。此外，我们必须在等待时将请求保留在内存中（也称为<em>缓冲</em>）。这意味着，等待的请求越多，我们的程序就会使用更多的内存——如果产生的请求超过我们的服务所能处理的数量，我们可能会耗尽内存。<br>只有当我们确定服务有能力处理请求时，才为请求分配空间，这将是更稳健的做法。否则，在我们等待我们的服务准备好时，我们有可能使用大量的内存来缓冲请求。</p><p>如果说<code>Service</code>有这样一个方法，那就完美了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Service</span>&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">ready</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ready</code>将是一个异步函数，当服务有足够的容量来接收一个新的请求时，它就会完成并返回。我们将要求用户首先调用<code>service.ready().await</code>，然后再进行<code>service.call(require).await</code>。</p><p>将“调用服务”与“预留容量”分开，还可以有新的用法：比如我们可以维护一组“准备好的服务”，并在后台保持更新。这样，当一个请求到来时，我们已经有了一个可以使用的服务，而不需要首先等待它准备好。</p><p>通过这种设计，<code>ConcurrencyLimit</code>可以在<code>ready</code>内部计算容量，而不允许用户调用<code>call</code>，直到有足够的容量。</p><p>不关心容量的服务可以从<code>ready</code>中立即返回，或者如果它们包含了一些内部的<code>Service</code>，它们可以委托给它内部的<code>ready</code>方法。</p><p>然而，现在我们仍然不能在 trait 中定义异步函数。因此，我们可以给<code>Service</code>定义另一个关联类型，叫做<code>ReadyFuture</code>，但是必须返回一个<code>Future</code>会给我们带来我们之前遇到的同样的生命周期问题。如果有一些方法可以解决这个问题就好了。</p><p>作为替代，我们可以从<code>Future</code>特性中获得一些灵感，定义一个方法叫做<code>poll_ready</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Service</span>&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll_ready</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;()&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果服务没有容量，<code>poll_ready</code>将返回<code>Poll::Pending</code>；当容量变得可用时，使用<code>Context</code>中的<code>waker</code>通知调用者。这时，可以再次调用<code>poll_ready</code>，如果它返回<code>Poll::Ready(())</code>，那么容量就被保留了，就可以调用<code>call</code>了。</p><p>请注意，从技术上来说，没有任何东西可以阻止用户在没有确定服务准备好的情况下调用<code>call</code>，然而，这样做被认为是违反了<code>Service</code>的 API 调用约定。这时候<code>call</code>可以<code>panic</code>如果服务没有准备好。</p><p><code>poll_ready</code>不返回<code>Future</code>也意味着我们能够快速检查一个服务是否准备好了，而不需要被迫等待它准备好。如果我们<br>调用<code>poll_ready</code>并返回<code>Poll::Pending</code>，我们可以决定去做其他事情而不是等待。举个例子，这允许你写个负载均衡器，通过服务返回<code>Poll::Pending</code>的频率来估计服务的负载，并将请求发送到负载最小的服务。</p><p>使用类似于<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.14/futures/future/fn.poll_fn.html"><code>futures::future::poll_fn</code></a>或者<a target="_blank" rel="noopener" href="https://docs.rs/tower/0.4.7/tower/trait.ServiceExt.html#method.ready"><code>tower::ServiceExt::ready</code></a>的东西，仍然可以获得一个等待服务容量可用的 Future。</p><p>这种服务与它们的调用者沟通其容量的概念被称为“反压传播”。你可以把它看作是服务向后反推他们的调用者，并且如果他们产生的请求太快了时，告诉他们需要放慢速度。其基本思想是，你不应该向一个没有能力处理的服务发送请求。相反，你应该等待（缓冲），放弃请求（减负），或以其他方式处理能力不足的问题。你可以在<a target="_blank" rel="noopener" href="https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7">这里</a>和<a target="_blank" rel="noopener" href="https://aws.amazon.com/builders-library/using-load-shedding-to-avoid-overload/">这里</a>了解更多关于背压的一般概念。</p><p>最后，在预留容量时也可能发生一些错误，所以<code>poll_ready</code>也许应该返回<code>Poll&lt;Result&lt;(), Self::Error&gt;</code>。</p><p>有了这一改变，我们现在已经有了完整的<code>tower::Service</code>特性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Service</span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Response</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span>: Future&lt;Output = <span class="type">Result</span>&lt;<span class="keyword">Self</span>::Response, <span class="keyword">Self</span>::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll_ready</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> Poll&lt;<span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, req: Request) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>许多中间件不添加自己的背压，而只是委托给被封装的服务的<code>poll_ready</code>实现。然而，中间件的背压确实可以实现一些有趣的用例，例如各种速率限制、负载均衡和自动扩容。</p><p>由于你永远不知道一个<code>Service</code>可能由哪些中间件组成，所以重要的是不要忘记调用<code>poll_ready</code>。</p><p>有了这一切，调用服务的最常用方法是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tower::&#123;</span><br><span class="line">    Service,</span><br><span class="line">    <span class="comment">// for the `ready` method</span></span><br><span class="line">    ServiceExt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">response</span> = service</span><br><span class="line">    <span class="comment">// wait for the service to have capacity</span></span><br><span class="line">    .<span class="title function_ invoke__">ready</span>().<span class="keyword">await</span>?</span><br><span class="line">    <span class="comment">// send the request</span></span><br><span class="line">    .<span class="title function_ invoke__">call</span>(request).<span class="keyword">await</span>?;</span><br></pre></td></tr></table></figure><div style="text-align:right">&mdash; David Pedersen (<a target="_blank" rel="noopener" href="https://github.com/davidpdrsn">@davidpdrsn</a>)</div><hr><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p><a name="pin">1</a>: 关于<code>call</code>是否应该使用<code>Pin&lt;&amp;mut Self&gt;</code> ，已经有了一些讨论。但是到目前为止，我们决定采用一个普通的 <code>&amp;mut self</code>，这意味着 handler（咳，<em>Services</em>）必须是<code>Unpin</code>。在实践中，这很少出现问题。更多细节可以看<a target="_blank" rel="noopener" href="https://github.com/tower-rs/tower/issues/319">这里</a>。</p><p><a name="gats">2</a>: 说得更准确一点，这要求响应返回的 Future 必须是<code>&#39;static&#39;</code>的，因为写<code>Box&lt;dyn Future&gt;</code>实际上会被 desugar 成<code>Box&lt;dyn Future + &#39;static&gt;</code>，因此在<code>fn call(&amp;&#39;_ mut self, ...)</code> 中的匿名<code>lifetime</code>并不满足这个要求。在未来，Rust编译器团队计划增加一个名为<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/44265">泛型关联类型（GAT）</a>的功能，这将解决这个问题。泛型关联类型允许我们将响应的 future 定义为<code>type Future&lt;&#39;a&gt;</code>，<code>call</code>定义为<code>fn call&lt;&#39;a&gt;(&amp;&#39;a mut self, ...) -&gt; Self::Future&lt;&#39;a&gt;</code>，但现在响应返回的 Future 必须是<code>&#39;static</code>的。</p></div><footer class="post-footer"><div class="reward-container"><div>请博主喝杯咖啡~</div> <button> 赞赏</button><div class="post-reward"><div> <img src="https://static.purewhite.io/wechat_pay.jpeg" alt="Pure White 微信"> <span>微信</span></div><div> <img src="https://static.purewhite.io/alipay.jpeg" alt="Pure White 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Pure White</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.purewhite.io/2021/05/24/inventing-the-service-trait/" title="【译】Inventing the Service trait">https://www.purewhite.io/2021/05/24/inventing-the-service-trait/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"> <span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://static.purewhite.io/wechat_channel.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-tags"> <a href="/tags/rust/" rel="tag"># rust</a> <a href="/tags/tokio/" rel="tag"># tokio</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/04/29/golang-time-now-optimize/" rel="prev" title="一次 Golang 的 time.Now 优化之旅"><i class="fa fa-angle-left"></i> 一次 Golang 的 time.Now 优化之旅</a></div><div class="post-nav-item"> <a href="/2021/08/11/rust-considered-unsafe-undefined/" rel="next" title="Rust 认为什么是“未定义”以及什么不是“不安全”？">Rust 认为什么是“未定义”以及什么不是“不安全”？<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">沪ICP备15051443号-3</a> <img src="https://static.purewhite.io/images/2019-10-30-%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=31010602004105" rel="noopener" target="_blank">沪公网安备 31010602004105号</a></div><div class="copyright"> &copy; 2017 – <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Pure White</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span title="站点总字数">92k</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">5:34</span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/PureWhiteWu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/comments.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/motion.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/schemes/muse.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/next-boot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/bookmark.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js" integrity="sha256-DABVk+hYj0mdUzo+7ViJC6cwLahQIejFvC+my2M/wfM=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.60.0/dist/instantsearch.production.min.js" integrity="sha256-9242vN47QUX50UG5Gf5XDO1YREWCEJRyXHofh5fsl24=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/search/algolia-search.min.js"></script><script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdn.jsdelivr.net/npm/wavedrom@3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script><script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdn.jsdelivr.net/npm/wavedrom@3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/tags/wavedrom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/pace.min.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"DyCyUXRHZzXfXMk2Y2ysMPgL-gzGzoHsz","app_key":"7ULdnCBPkXxF6ArPc8VxaXy4","server_url":"https://leancloud.purewhite.io","security":true}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/statistics/lean-analytics.min.js"></script><script src="https://cdn.jsdelivr.net/npm/quicklink@2.3.0/dist/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"ignores":null,"url":"https://www.purewhite.io/2021/05/24/inventing-the-service-trait/"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/quicklink.min.js"></script><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"blog-zr0zqnlt9p","count":true,"i18n":{"disqus":"disqus"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.19.1/source/js/third-party/comments/disqus.min.js"></script></body></html>
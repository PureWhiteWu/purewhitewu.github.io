<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0"><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="https://static.purewhite.io/favicon.jpg"><link rel="icon" type="image/png" sizes="32x32" href="https://static.purewhite.io/favicon.jpg"><link rel="icon" type="image/png" sizes="16x16" href="https://static.purewhite.io/favicon.jpg"><link rel="mask-icon" href="https://static.purewhite.io/favicon.jpg" color="#222"><meta name="google-site-verification" content="Xg_Hnp9ie-Rq7-zLPdd3c9dQtR_0N845ue4QaK8jvL4"><meta name="baidu-site-verification" content="c3b074df19d33f893845b6d092bc9169"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.purewhite.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":true,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"ZP9482CZD3","apiKey":"d26207a3ce8de9fe98e7af4215425c93","indexName":"Blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="原文：https:&#x2F;&#x2F;github.com&#x2F;dtolnay&#x2F;rust-faq 本文档的存在是为了回答有关 Rust 编程语言的常见问题。它不是一个完整的语言指南，也不是一个教授该语言的工具。它只是一个参考，用来回答 Rust 社区中人们经常遇到的问题，并澄清 Rust 的一些设计决定背后的原因。"><meta property="og:type" content="article"><meta property="og:title" content="【译】Rust 常见的问题"><meta property="og:url" content="https://www.purewhite.io/2021/09/01/rust-faq/index.html"><meta property="og:site_name" content="Pure White"><meta property="og:description" content="原文：https:&#x2F;&#x2F;github.com&#x2F;dtolnay&#x2F;rust-faq 本文档的存在是为了回答有关 Rust 编程语言的常见问题。它不是一个完整的语言指南，也不是一个教授该语言的工具。它只是一个参考，用来回答 Rust 社区中人们经常遇到的问题，并澄清 Rust 的一些设计决定背后的原因。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-09-01T08:24:08.000Z"><meta property="article:modified_time" content="2021-12-02T12:51:07.229Z"><meta property="article:author" content="Pure White"><meta property="article:tag" content="rust"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.purewhite.io/2021/09/01/rust-faq/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.purewhite.io/2021/09/01/rust-faq/","path":"2021/09/01/rust-faq/","title":"【译】Rust 常见的问题"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>【译】Rust 常见的问题 | Pure White</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98194081-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-98194081-1","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?587d2548655f9855727225afb0e4d708"></script><script async src="//assets.growingio.com/2.1/gio.js"></script><script class="next-config" data-name="growingio_analytics" type="application/json">"8a8c3a537a0132ac"</script><script src="/js/third-party/analytics/growingio.js"></script><script type="text/javascript">!function(t,e,n,a,c,s,i){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(s=e.createElement(a)).async=1,s.src="https://www.clarity.ms/tag/8mh5xasia9",(i=e.getElementsByTagName(a)[0]).parentNode.insertBefore(s,i)}(window,document,"clarity","script")</script><script>!function(){var e=document.createElement("script");e.src="https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?c75fd468cb92e13256468f9ae3917db97049a5a91566914dbb6ab879288745b8bc434964556b7d7129e9b750ed197d397efd7b0c6c715c1701396e1af40cec962b8d7c8c6655c9b00211740aa8a98e2e",e.id="ttzz";var c=document.getElementsByTagName("script")[0];c.parentNode.insertBefore(e,c)}(window)</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Pure White" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="Pure White" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Pure White</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">主业写bug，副业debug</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Rust-Project"><span class="nav-number">2.</span> <span class="nav-text">The Rust Project</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">这个项目的目标是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%98%AF%E7%94%B1-Mozilla-%E6%8E%A7%E5%88%B6%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">这个项目是由 Mozilla 控制的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%9E%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">Rust的一些非目标是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mozilla-%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Rust%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">Mozilla 在哪些项目中使用 Rust？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%A7%E5%9E%8B-Rust-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">有哪些大型 Rust 项目的例子？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%98%E6%9C%89%E8%B0%81%E5%9C%A8%E4%BD%BF%E7%94%A8-Rust%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">还有谁在使用 Rust？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E8%BD%BB%E6%9D%BE%E5%9C%B0%E5%B0%9D%E8%AF%95-Rust%EF%BC%9F"><span class="nav-number">2.7.</span> <span class="nav-text">我怎样才能轻松地尝试 Rust？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%BE%97%E5%88%B0-Rust-%E9%97%AE%E9%A2%98%E7%9A%84%E5%B8%AE%E5%8A%A9%EF%BC%9F"><span class="nav-number">2.8.</span> <span class="nav-text">我怎样才能得到 Rust 问题的帮助？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Rust-%E9%9A%8F%E7%9D%80%E6%97%B6%E9%97%B4%E7%9A%84%E6%8E%A8%E7%A7%BB%E5%8F%91%E7%94%9F%E4%BA%86%E5%A6%82%E6%AD%A4%E5%A4%A7%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="nav-number">2.9.</span> <span class="nav-text">为什么 Rust 随着时间的推移发生了如此大的变化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="nav-number">2.10.</span> <span class="nav-text">Rust语言的版本管理是如何进行的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8B%E8%AF%95%E7%89%88%E6%88%96%E7%A8%B3%E5%AE%9A%E7%89%88%E9%A2%91%E9%81%93%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%B8%8D%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%8A%9F%E8%83%BD%E5%90%97%EF%BC%9F"><span class="nav-number">2.11.</span> <span class="nav-text">我可以在测试版或稳定版频道上使用不稳定的功能吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E7%89%B9%E6%80%A7%E5%BC%80%E5%85%B3%E2%80%9D"><span class="nav-number">2.12.</span> <span class="nav-text">什么是“特性开关”?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%87%E7%94%A8-MIT-x2F-ASL2-%E5%8F%8C%E8%AE%B8%E5%8F%AF%E8%AF%81%EF%BC%9F"><span class="nav-number">2.13.</span> <span class="nav-text">为什么要采用 MIT&#x2F;ASL2 双许可证？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-BSD-%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%AE%B8%E5%8F%AF%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF-MPL-%E6%88%96%E4%B8%89%E5%90%88%E4%B8%80%E8%AE%B8%E5%8F%AF%EF%BC%9F"><span class="nav-number">2.14.</span> <span class="nav-text">为什么是 BSD 风格的许可，而不是 MPL 或三合一许可？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">3.</span> <span class="nav-text">性能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust%E6%9C%89%E5%A4%9A%E5%BF%AB%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">Rust有多快？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E6%9C%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%90%97%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">Rust 有垃圾收集吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%BE%88%E6%85%A2%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">为什么我的程序很慢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%BC%E4%B9%8E%E5%BE%88%E6%85%A2%E3%80%82%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">Rust的编译似乎很慢。这是为什么呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Rust-%E7%9A%84HashMap%E5%BE%88%E6%85%A2%EF%BC%9F"><span class="nav-number">3.5.</span> <span class="nav-text">为什么 Rust 的HashMap很慢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E9%9B%86%E6%88%90%E7%9A%84%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD"><span class="nav-number">3.6.</span> <span class="nav-text">为什么没有集成的基准测试基础设施?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E6%98%AF%E5%90%A6%E5%81%9A%E4%BA%86%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">3.7.</span> <span class="nav-text">Rust 是否做了尾调用优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E6%9C%89-runtime-%E5%90%97%EF%BC%9F"><span class="nav-number">3.8.</span> <span class="nav-text">Rust 有 runtime 吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%A4%A7%E6%8B%AC%E5%8F%B7-%E4%B8%BA%E4%BB%80%E4%B9%88-Rust-%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8D%E8%83%BD%E5%83%8F-Haskell-%E6%88%96-Python-%E9%82%A3%E6%A0%B7%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">为什么要用大括号? 为什么 Rust 的语法不能像 Haskell 或 Python 那样？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E5%9C%A8if%E6%9D%A1%E4%BB%B6%E4%B8%8A%E4%B8%8D%E5%8A%A0%E5%B0%8F%E6%8B%AC%E5%8F%B7%EF%BC%8C%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%8D%95%E8%A1%8C%E5%9D%97%E5%91%A8%E5%9B%B4%E5%8A%A0%E4%B8%8A%E5%A4%A7%E6%8B%AC%E5%8F%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%A3%8E%E6%A0%BC"><span class="nav-number">4.2.</span> <span class="nav-text">我可以在if条件上不加小括号，那么为什么我必须在单行块周围加上大括号？为什么不允许使用 C 语言的风格?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E5%AD%97%E5%85%B8%E7%9A%84%E5%AD%97%E9%9D%A2%E8%AF%AD%E6%B3%95%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">为什么没有字典的字面语法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%BA%94%E8%AF%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E8%BF%94%E5%9B%9E%EF%BC%9F"><span class="nav-number">4.4.</span> <span class="nav-text">我应该在什么时候使用隐式返回？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E6%96%AD%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%BE%E5%90%8D%EF%BC%9F"><span class="nav-number">4.5.</span> <span class="nav-text">为什么不推断出函数的签名？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88match%E5%BF%85%E9%A1%BB%E6%98%AF%E8%AF%A6%E5%B0%BD%E7%9A%84"><span class="nav-number">4.6.</span> <span class="nav-text">为什么match必须是详尽的?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Numerics"><span class="nav-number">5.</span> <span class="nav-text">Numerics</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%EF%BC%8C%E6%88%91%E5%BA%94%E8%AF%A5%E9%80%89%E6%8B%A9f32%E5%92%8Cf64%E4%B8%AD%E7%9A%84%E5%93%AA%E4%B8%80%E4%B8%AA"><span class="nav-number">5.1.</span> <span class="nav-text">对于浮点运算，我应该选择f32和f64中的哪一个?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E8%83%BD%E6%AF%94%E8%BE%83%E6%B5%AE%E7%82%B9%E6%95%B0%E6%88%96%E7%94%A8%E5%AE%83%E4%BB%AC%E4%BD%9C%E4%B8%BAHashMap%E6%88%96BTreeMap%E7%9A%84%E9%94%AE"><span class="nav-number">5.2.</span> <span class="nav-text">为什么我不能比较浮点数或用它们作为HashMap或BTreeMap的键?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%9C%A8%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.3.</span> <span class="nav-text">我如何在数字类型之间进行转换?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Rust%E6%B2%A1%E6%9C%89%E5%A2%9E%E9%87%8F%E5%92%8C%E5%87%8F%E9%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.4.</span> <span class="nav-text">为什么Rust没有增量和减量运算符?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AAString%E6%88%96Vec-lt-T-gt-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%89%87%E6%96%AD-amp-str%E5%92%8C-amp-T"><span class="nav-number">6.1.</span> <span class="nav-text">如何将一个String或Vec&lt;T&gt;转换为一个片断(&amp;str和&amp;[T])?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E4%BB%8E-amp-str%E8%BD%AC%E6%8D%A2%E5%88%B0String%E6%88%96%E5%8F%8D%E8%BF%87%E6%9D%A5%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">我如何从&amp;str转换到String或反过来？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.3.</span> <span class="nav-text">两种不同的字符串类型之间有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E4%B8%AAString%E4%B8%AD%E8%BF%9B%E8%A1%8C-O-1-%E7%9A%84%E5%AD%97%E7%AC%A6%E8%AE%BF%E9%97%AE"><span class="nav-number">6.4.</span> <span class="nav-text">我如何在一个String中进行 O(1) 的字符访问?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%BB%98%E8%AE%A4%E4%B8%BA-UTF-8%EF%BC%9F"><span class="nav-number">6.5.</span> <span class="nav-text">为什么字符串默认为 UTF-8？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">6.6.</span> <span class="nav-text">我应该使用什么字符串类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%86%99%E4%B8%80%E4%B8%AA%E6%97%A2%E6%8E%A5%E5%8F%97-amp-str%E5%8F%88%E6%8E%A5%E5%8F%97String%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.7.</span> <span class="nav-text">我怎样才能写一个既接受&amp;str又接受String的函数?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Into-lt-String-gt"><span class="nav-number">6.7.1.</span> <span class="nav-text">使用Into&lt;String&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AsRef-lt-str-gt"><span class="nav-number">6.7.2.</span> <span class="nav-text">使用AsRef&lt;str&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Cow-lt-str-gt"><span class="nav-number">6.7.3.</span> <span class="nav-text">使用Cow&lt;str&gt;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">7.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E5%9C%A8-Rust-%E4%B8%AD%E6%9C%89%E6%95%88%E5%9C%B0%E5%AE%9E%E7%8E%B0%E5%90%91%E9%87%8F%E5%92%8C%E9%93%BE%E8%A1%A8%E7%AD%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%97"><span class="nav-number">7.1.</span> <span class="nav-text">我可以在 Rust 中有效地实现向量和链表等数据结构吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%9C%A8%E4%B8%8D%E7%A7%BB%E5%8A%A8-x2F-%E6%B6%88%E8%80%97%E9%9B%86%E5%90%88%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">我怎样才能在不移动&#x2F;消耗集合的情况下对其进行迭代？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E9%9C%80%E8%A6%81%E5%9C%A8%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E4%B8%AD%E8%BE%93%E5%85%A5%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">7.3.</span> <span class="nav-text">为什么我需要在数组声明中输入数组大小?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">8.</span> <span class="nav-text">所有权</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E7%8E%AF%E7%9A%84%E5%9B%BE%E6%88%96%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.1.</span> <span class="nav-text">我怎样才能实现一个包含环的图或其他数据结构?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E5%AF%B9%E5%85%B6%E8%87%AA%E8%BA%AB%E5%AD%97%E6%AE%B5%E4%B9%8B%E4%B8%80%E7%9A%84%E5%BC%95%E7%94%A8%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">我怎样才能定义一个包含对其自身字段之一的引用的结构？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E6%B6%88%E8%80%97%E3%80%81%E7%A7%BB%E5%8A%A8%E5%92%8C%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">8.3.</span> <span class="nav-text">按值传递、消耗、移动和转移所有权之间有什么区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%90%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9C%A8%E4%BC%A0%E9%80%92%E7%BB%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%90%8E%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%80%8C%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="nav-number">8.4.</span> <span class="nav-text">为什么某些类型的值在传递给一个函数后可以使用，而重复使用其他类型的值会导致错误？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E2%80%9Cuse-of-moved-value%E2%80%9D%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="nav-number">8.5.</span> <span class="nav-text">如何处理“use of moved value”的错误？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E%E4%B8%AD%E4%BD%BF%E7%94%A8self%E3%80%81-amp-self%E6%88%96-amp-mut-self%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">8.6.</span> <span class="nav-text">在方法声明中使用self、&amp;self或&amp;mut self的规则是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E7%90%86%E8%A7%A3%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%E5%99%A8%EF%BC%9F"><span class="nav-number">8.7.</span> <span class="nav-text">我怎样才能理解借用检查器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99Rc%E6%9C%89%E7%94%A8%EF%BC%9F"><span class="nav-number">8.8.</span> <span class="nav-text">什么时候Rc有用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="nav-number">8.9.</span> <span class="nav-text">我如何从一个函数中返回一个闭包？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-deref-coercion%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">8.10.</span> <span class="nav-text">什么是 deref coercion，它是如何工作的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">9.</span> <span class="nav-text">生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">9.1.</span> <span class="nav-text">为什么是生命周期?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E8%AF%AD%E6%B3%95%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">9.2.</span> <span class="nav-text">为什么生命周期的语法是这样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E5%80%9F%E6%9D%A5%E7%9A%84%E4%B8%9C%E8%A5%BF%E8%BF%94%E5%9B%9E%E5%88%B0%E6%88%91%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="nav-number">9.3.</span> <span class="nav-text">我如何将一个借来的东西返回到我从函数中创建的东西？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E5%BC%95%E7%94%A8%E6%9C%89%E5%AF%BF%E5%91%BD%EF%BC%8C%E5%A6%82-amp-39-a-T%EF%BC%8C%E8%80%8C%E6%9C%89%E4%BA%9B%E5%88%99%E6%B2%A1%E6%9C%89%EF%BC%8C%E5%A6%82-amp-T%EF%BC%9F"><span class="nav-number">9.4.</span> <span class="nav-text">为什么有些引用有寿命，如&amp;&#39;a T，而有些则没有，如&amp;T？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E2%80%9C%E6%B2%A1%E6%9C%89%E7%A9%BA%E6%8C%87%E9%92%88%E2%80%9D%E5%92%8C%E2%80%9C%E6%B2%A1%E6%9C%89%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%E2%80%9D"><span class="nav-number">9.5.</span> <span class="nav-text">Rust如何保证“没有空指针”和“没有悬空指针”?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E7%94%A8%E2%80%9Cnull%E2%80%9D%E6%9D%A5%E8%A1%A8%E8%BE%BE%E4%B8%80%E4%B8%AA%E5%80%BC%E7%9A%84%E7%BC%BA%E5%A4%B1"><span class="nav-number">9.6.</span> <span class="nav-text">我如何用“null”来表达一个值的缺失?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%8D%95%E6%80%81%E5%8C%96%E2%80%9D"><span class="nav-number">10.1.</span> <span class="nav-text">什么是“单态化”?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%92%8C%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E6%8D%95%E8%8E%B7%E4%BB%BB%E4%BD%95%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AD%E5%8C%85%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">10.2.</span> <span class="nav-text">一个函数和一个没有捕获任何变量的闭包之间有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E9%9C%80%E8%A6%81%E5%AE%83%E4%BB%AC%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88-Rust-%E6%B2%A1%E6%9C%89%E5%AE%83%E4%BB%AC%EF%BC%9F"><span class="nav-number">10.3.</span> <span class="nav-text">什么是高阶类型，为什么我需要它们，以及为什么 Rust 没有它们？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%AD%E5%83%8F-lt-T-Foo-gt-%E8%BF%99%E6%A0%B7%E7%9A%84%E5%91%BD%E5%90%8D%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">10.4.</span> <span class="nav-text">通用类型中像&lt;T&#x3D;Foo&gt;这样的命名类型参数是什么意思?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%90%97-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">10.5.</span> <span class="nav-text">我可以重载运算符吗? 哪些操作符，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8Eq-x2F-PartialEq%E5%92%8COrd-x2F-PartialOrd%E4%B9%8B%E9%97%B4%E5%88%92%E5%88%86%EF%BC%9F"><span class="nav-number">10.6.</span> <span class="nav-text">为什么要在Eq&#x2F;PartialEq和Ord&#x2F;PartialOrd之间划分？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA"><span class="nav-number">11.</span> <span class="nav-text">输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E8%AF%BB%E6%88%90%E4%B8%80%E4%B8%AA%E2%80%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9D"><span class="nav-number">11.1.</span> <span class="nav-text">如何将一个文件读成一个“字符串”?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E5%9C%B0%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5"><span class="nav-number">11.2.</span> <span class="nav-text">如何有效地读取文件输入?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%9C%A8-Rust-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%EF%BC%9F"><span class="nav-number">11.3.</span> <span class="nav-text">我如何在 Rust 中进行异步输入&#x2F;输出？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%9C%A8-Rust-%E4%B8%AD%E8%8E%B7%E5%BE%97%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">11.4.</span> <span class="nav-text">我如何在 Rust 中获得命令行参数?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">12.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Rust-%E6%B2%A1%E6%9C%89%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="nav-number">12.1.</span> <span class="nav-text">为什么 Rust 没有异常？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%B0%E5%A4%84%E9%83%BD%E6%9C%89-96-unwrap-%E2%80%99%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B"><span class="nav-number">12.2.</span> <span class="nav-text">到处都有&#96;unwrap()’是怎么回事?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E6%88%91%E8%AF%95%E5%9B%BE%E8%BF%90%E8%A1%8C%E4%BD%BF%E7%94%A8try-%E5%AE%8F%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF"><span class="nav-number">12.3.</span> <span class="nav-text">当我试图运行使用try!宏的示例代码时，为什么我得到一个错误?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E6%B2%A1%E6%9C%89%E6%AF%94%E5%88%B0%E5%A4%84%E9%83%BD%E6%98%AF%E2%80%9CResult%E2%80%9D%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E6%9D%A5%E5%81%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">12.4.</span> <span class="nav-text">有没有比到处都是“Result”更简单的方法来做错误处理？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">13.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B2%A1%E6%9C%89%E2%80%9C%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%9D%E5%9D%97%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%B7%A8%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%80%BC%E5%90%97%EF%BC%9F"><span class="nav-number">13.1.</span> <span class="nav-text">我可以在没有“不安全”块的情况下跨线程使用静态值吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">14.</span> <span class="nav-text">宏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8F%E6%9D%A5%E7%94%9F%E6%88%90%E6%A0%87%E8%AF%86%E7%AC%A6%E5%90%97"><span class="nav-number">14.1.</span> <span class="nav-text">我可以写一个宏来生成标识符吗?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Debugging-and-Tooling"><span class="nav-number">15.</span> <span class="nav-text">Debugging and Tooling</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-Rust-%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="nav-number">15.1.</span> <span class="nav-text">我如何调试 Rust 程序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rustc%E8%AF%B4%E6%A0%87%E5%87%86%E5%BA%93%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86-panic%E3%80%82%E6%88%91%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="nav-number">15.2.</span> <span class="nav-text">rustc说标准库代码中发生了 panic。我如何定位我的代码中的错误？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88-IDE%EF%BC%9F"><span class="nav-number">15.3.</span> <span class="nav-text">我应该使用什么 IDE？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Low-Level"><span class="nav-number">16.</span> <span class="nav-text">Low-Level</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BDmemcpy%E5%AD%97%E8%8A%82"><span class="nav-number">16.1.</span> <span class="nav-text">我怎样才能memcpy字节?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%8CRust-%E8%83%BD%E5%90%88%E7%90%86%E5%9C%B0%E8%BF%90%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="nav-number">16.2.</span> <span class="nav-text">没有标准库，Rust 能合理地运行吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E7%94%A8-Rust-%E5%86%99%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F"><span class="nav-number">16.3.</span> <span class="nav-text">我可以用 Rust 写一个操作系统吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%9C%A8%E6%96%87%E4%BB%B6%E6%88%96%E5%85%B6%E4%BB%96%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%AD%E4%BB%A5%E5%A4%A7%E6%95%B0%E6%88%96%E5%B0%8F%E6%95%B0%E6%A0%BC%E5%BC%8F%E8%AF%BB%E5%86%99%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E5%A6%82i32%E6%88%96f64"><span class="nav-number">16.4.</span> <span class="nav-text">我如何在文件或其他字节流中以大数或小数格式读写数字类型如i32或f64?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E6%98%AF%E5%90%A6%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B8%83%E5%B1%80%EF%BC%9F"><span class="nav-number">16.5.</span> <span class="nav-text">Rust 是否保证一个特定的数据布局？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="nav-number">17.</span> <span class="nav-text">跨平台</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-Rust-%E4%B8%AD%E8%A1%A8%E8%BE%BE%E7%89%B9%E5%AE%9A%E5%B9%B3%E5%8F%B0%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%B9%A0%E6%83%AF%E6%80%A7%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">17.1.</span> <span class="nav-text">在 Rust 中表达特定平台行为的习惯性方法是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E-Android-x2F-iOS-%E7%BC%96%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="nav-number">17.2.</span> <span class="nav-text">Rust 可以用于 Android&#x2F;iOS 编程吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BD%91%E7%BB%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%88%91%E7%9A%84-Rust-%E7%A8%8B%E5%BA%8F%E5%90%97%EF%BC%9F"><span class="nav-number">17.3.</span> <span class="nav-text">我可以在网络浏览器中运行我的 Rust 程序吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%9C%A8-Rust-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%EF%BC%9F"><span class="nav-number">17.4.</span> <span class="nav-text">我如何在 Rust 中进行交叉编译？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mod-%E5%92%8C-crate"><span class="nav-number">18.</span> <span class="nav-text">mod 和 crate</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mod-%E5%92%8C-crate-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">18.1.</span> <span class="nav-text">mod 和 crate 之间的关系是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Rust-%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%91%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%99%E4%B8%AA%E5%BA%93"><span class="nav-number">18.2.</span> <span class="nav-text">为什么 Rust 编译器找不到我正在使用的这个库?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BF%85%E9%A1%BB%E5%9C%A8-crate-%E7%9A%84%E9%A1%B6%E5%B1%82%E7%94%A8mod%E5%A3%B0%E6%98%8E-mod-%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5use%E5%AE%83%E4%BB%AC%EF%BC%9F"><span class="nav-number">18.3.</span> <span class="nav-text">为什么我必须在 crate 的顶层用mod声明 mod 文件，而不是直接use它们？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Cargo-%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="nav-number">18.4.</span> <span class="nav-text">我如何配置 Cargo 使用代理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%B7%B2%E7%BB%8F%E2%80%9Cuse%E2%80%9D%E4%BA%86-crate%EF%BC%8C%E4%BD%86%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%98%E6%98%AF%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">18.5.</span> <span class="nav-text">为什么我已经“use”了 crate，但编译器还是找不到方法的实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E8%83%BD%E4%B8%BA%E6%88%91%E6%8E%A8%E6%96%AD%E5%87%BAuse%E5%A3%B0%E6%98%8E%EF%BC%9F"><span class="nav-number">18.6.</span> <span class="nav-text">为什么编译器不能为我推断出use声明？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81-Rust-%E5%BA%93%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="nav-number">18.7.</span> <span class="nav-text">我如何进行动态 Rust 库加载？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-crates-io-%E6%B2%A1%E6%9C%89%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="nav-number">18.8.</span> <span class="nav-text">为什么 crates.io 没有命名空间？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%93"><span class="nav-number">19.</span> <span class="nav-text">库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%8F%91%E5%87%BA-HTTP-%E8%AF%B7%E6%B1%82"><span class="nav-number">19.1.</span> <span class="nav-text">我怎样才能发出 HTTP 请求?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E7%94%A8-Rust-%E7%BC%96%E5%86%99-GUI-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="nav-number">19.2.</span> <span class="nav-text">我如何用 Rust 编写 GUI 应用程序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E8%A7%A3%E6%9E%90-JSON-x2F-XML"><span class="nav-number">19.3.</span> <span class="nav-text">我怎样才能解析 JSON&#x2F;XML?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84-2D-%E7%9F%A2%E9%87%8F%E5%92%8C%E5%BD%A2%E7%8A%B6-crate"><span class="nav-number">19.4.</span> <span class="nav-text">是否有一个标准的 2D+ 矢量和形状 crate?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%9C%A8-Rust-%E4%B8%AD%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-OpenGL-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">19.5.</span> <span class="nav-text">我如何在 Rust 中编写一个 OpenGL 应用程序?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E7%94%A8-Rust-%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%86%E9%A2%91%E6%B8%B8%E6%88%8F%E5%90%97%EF%BC%9F"><span class="nav-number">19.6.</span> <span class="nav-text">我可以用 Rust 写一个视频游戏吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">20.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">20.1.</span> <span class="nav-text">Rust是面向对象的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%B0%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E6%98%A0%E5%B0%84%E5%88%B0-Rust-%E4%B8%AD%EF%BC%9F"><span class="nav-number">20.2.</span> <span class="nav-text">我如何将面向对象的概念映射到 Rust 中？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B8%A6%E6%9C%89%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%93%E6%9E%84%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="nav-number">20.3.</span> <span class="nav-text">我如何处理带有可选参数的结构的配置？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%9C%A8-Rust-%E4%B8%AD%E5%81%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">20.4.</span> <span class="nav-text">我如何在 Rust 中做全局变量?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E5%B8%B8%E9%87%8F%EF%BC%9F"><span class="nav-number">20.5.</span> <span class="nav-text">我如何设置程序化定义的编译时常量？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%8F%AF%E4%BB%A5%E8%BF%90%E8%A1%8C%E5%8F%91%E7%94%9F%E5%9C%A8-main-%E4%B9%8B%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81%E5%90%97%EF%BC%9F"><span class="nav-number">20.6.</span> <span class="nav-text">我可以运行发生在 main 之前的初始化代码吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E5%85%81%E8%AE%B8-globals-%E4%BD%BF%E7%94%A8%E9%9D%9E%E7%BB%93%E6%9E%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%E5%90%97%EF%BC%9F"><span class="nav-number">20.7.</span> <span class="nav-text">Rust 允许 globals 使用非结构表达式的值吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80"><span class="nav-number">21.</span> <span class="nav-text">其他语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%9C%A8-Rust-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC-C-%E8%AF%AD%E8%A8%80%E7%9A%84struct-X-static-int-X-%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%91%A2%EF%BC%9F"><span class="nav-number">21.1.</span> <span class="nav-text">我怎样才能在 Rust 中实现类似 C 语言的struct X { static int X; };的东西呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%B0%86-C-%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0%EF%BC%8C%E5%8F%8D%E4%B9%8B%E4%BA%A6%E7%84%B6%EF%BC%9F"><span class="nav-number">21.2.</span> <span class="nav-text">我如何将 C 风格的枚举转换为整数，反之亦然？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Rust-%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%A7%E5%B0%8F%E6%AF%94-C-%E7%A8%8B%E5%BA%8F%E5%A4%A7"><span class="nav-number">21.3.</span> <span class="nav-text">为什么 Rust 程序的二进制大小比 C 程序大?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%80%81%E5%8C%96"><span class="nav-number">21.3.1.</span> <span class="nav-text">单态化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E7%AC%A6%E5%8F%B7"><span class="nav-number">21.3.2.</span> <span class="nav-text">调试符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%97%B6%E4%BC%98%E5%8C%96"><span class="nav-number">21.3.3.</span> <span class="nav-text">链接时优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">21.3.4.</span> <span class="nav-text">标准库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Rust-%E4%B8%8D%E5%83%8F-C-%E9%82%A3%E6%A0%B7%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A8%B3%E5%AE%9A%E7%9A%84-ABI%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BF%85%E9%A1%BB%E7%94%A8-extern-%E6%9D%A5%E6%B3%A8%E8%A7%A3%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="nav-number">21.4.</span> <span class="nav-text">为什么 Rust 不像 C 那样有一个稳定的 ABI，为什么我必须用 extern 来注解东西？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8-C-%E4%BB%A3%E7%A0%81%E5%90%97%EF%BC%9F"><span class="nav-number">21.5.</span> <span class="nav-text">Rust 代码可以调用 C 代码吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8-Rust-%E4%BB%A3%E7%A0%81%E5%90%97"><span class="nav-number">21.6.</span> <span class="nav-text">C 代码可以调用 Rust 代码吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%B7%B2%E7%BB%8F%E5%86%99%E4%BA%86%E5%AE%8C%E7%BE%8E%E7%9A%84-C-%E4%BB%A3%E7%A0%81%E3%80%82Rust-%E8%83%BD%E7%BB%99%E6%88%91%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">21.7.</span> <span class="nav-text">我已经写了完美的 C++ 代码。Rust 能给我什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E5%9C%A8-Rust-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%BD%93%E4%BA%8E-C-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%B8%93%E4%B8%9A%E5%8C%96%EF%BC%9F"><span class="nav-number">21.8.</span> <span class="nav-text">我如何在 Rust 中实现相当于 C++ 模板的专业化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E7%B3%BB%E7%BB%9F%E4%B8%8E-C-%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">21.9.</span> <span class="nav-text">Rust 的所有权系统与 C++ 的移动语义有什么关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E4%BB%8E-Rust-%E4%B8%8E-C-%E4%BA%92%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%88%96%E8%80%85%E4%BB%8E-C-%E4%B8%8E-Rust-%E4%BA%92%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">21.10.</span> <span class="nav-text">我怎样才能从 Rust 与 C++ 互操作，或者从 C++ 与 Rust 互操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E6%9C%89-C-%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">21.11.</span> <span class="nav-text">Rust 有 C++ 风格的构造函数吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E6%9C%89%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">21.12.</span> <span class="nav-text">Rust 有复制构造函数吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E6%9C%89%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">21.13.</span> <span class="nav-text">Rust 有移动构造函数吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E5%92%8C-Rust-%E6%9C%89%E4%BB%80%E4%B9%88%E7%9B%B8%E4%BC%BC%E4%B9%8B%E5%A4%84%EF%BC%8C%E5%8F%88%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">21.14.</span> <span class="nav-text">Go 和 Rust 有什么相似之处，又有什么不同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-traits-%E4%B8%8E-Haskell-typeclasses-%E7%9B%B8%E6%AF%94%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="nav-number">21.15.</span> <span class="nav-text">Rust traits 与 Haskell typeclasses 相比如何？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Documentation"><span class="nav-number">22.</span> <span class="nav-text">Documentation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Stack-Overflow-%E4%B8%8A%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A-Rust-%E7%9A%84%E7%AD%94%E6%A1%88%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F"><span class="nav-number">22.1.</span> <span class="nav-text">为什么 Stack Overflow 上有这么多 Rust 的答案是错误的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%9C%A8%E5%93%AA%E9%87%8C%E6%8A%A5%E5%91%8A-Rust-%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">22.2.</span> <span class="nav-text">我在哪里报告 Rust 文档中的问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%89%80%E4%BE%9D%E8%B5%96%E7%9A%84%E5%BA%93%E7%9A%84-Rustdoc-%E6%96%87%E6%A1%A3%EF%BC%9F"><span class="nav-number">22.3.</span> <span class="nav-text">我如何查看我的项目所依赖的库的 Rustdoc 文档？</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Pure White" src="https://static.purewhite.io/avatar.jpg!webp_90"><p class="site-author-name" itemprop="name">Pure White</p><div class="site-description" itemprop="description">青春不是年华，是心境；<br>青春不是桃面、丹唇、柔膝，<br>而是深沉的意志、恢弘的想象、<br>炽热的感情。</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">29</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/PureWhiteWu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PureWhiteWu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:me@purewhite.io" title="E-Mail → mailto:me@purewhite.io" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://twitter.com/PureWhite_Wu" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;PureWhite_Wu" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i> Twitter</a></span><span class="links-of-author-item"><a href="https://www.linkedin.com/in/%E8%BF%AA-%E5%90%B4-846051106/" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;%E8%BF%AA-%E5%90%B4-846051106&#x2F;" rel="noopener me" target="_blank"><i class="fa fa-linkedin fa-fw"></i> LinkedIn</a></span><span class="links-of-author-item"><a href="https://telegram.me/PureWhiteWu" title="Telegram → https:&#x2F;&#x2F;telegram.me&#x2F;PureWhiteWu" rel="noopener me" target="_blank"><i class="fa fa-telegram fa-fw"></i> Telegram</a></span><span class="links-of-author-item"><a href="http://weibo.com/purewhitewu" title="微博 → http:&#x2F;&#x2F;weibo.com&#x2F;purewhitewu" rel="noopener me" target="_blank"><i class="fa fa-weibo fa-fw"></i> 微博</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/PureWhite_Wu" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;PureWhite_Wu" rel="noopener me" target="_blank"><i class="fa fa-book fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://static.purewhite.io/wechat_channel.jpg" title="微信 → https:&#x2F;&#x2F;static.purewhite.io&#x2F;wechat_channel.jpg" rel="noopener me" target="_blank"><i class="fa fa-weixin fa-fw"></i> 微信</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://blog.didispace.com/" title="http:&#x2F;&#x2F;blog.didispace.com&#x2F;" rel="noopener" target="_blank">程序猿DD</a></li><li class="links-of-blogroll-item"> <a href="http://www.v2ex.com/?r=PureWhiteWu" title="http:&#x2F;&#x2F;www.v2ex.com&#x2F;?r&#x3D;PureWhiteWu" rel="noopener" target="_blank">v2ex</a></li><li class="links-of-blogroll-item"> <a href="https://yuzhouwan.com/" title="https:&#x2F;&#x2F;yuzhouwan.com&#x2F;" rel="noopener" target="_blank">宇宙湾</a></li><li class="links-of-blogroll-item"> <a href="https://pengrl.com/" title="https:&#x2F;&#x2F;pengrl.com&#x2F;" rel="noopener" target="_blank">yoko blog</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.purewhite.io/2021/09/01/rust-faq/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://static.purewhite.io/avatar.jpg!webp_90"><meta itemprop="name" content="Pure White"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Pure White"><meta itemprop="description" content="青春不是年华，是心境；<br />青春不是桃面、丹唇、柔膝，<br />而是深沉的意志、恢弘的想象、<br />炽热的感情。"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="【译】Rust 常见的问题 | Pure White"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 【译】Rust 常见的问题</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-09-01 16:24:08" itemprop="dateCreated datePublished" datetime="2021-09-01T16:24:08+08:00">2021-09-01</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-12-02 20:51:07" itemprop="dateModified" datetime="2021-12-02T20:51:07+08:00">2021-12-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a></span></span><span id="/2021/09/01/rust-faq/" class="post-meta-item leancloud_visitors" data-flag-title="【译】Rust 常见的问题" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Disqus：</span><a title="disqus" href="/2021/09/01/rust-faq/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/09/01/rust-faq/" itemprop="commentCount"></span></a></span><span class="post-meta-break"></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>21k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1:16</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>原文：<a target="_blank" rel="noopener" href="https://github.com/dtolnay/rust-faq">https://github.com/dtolnay/rust-faq</a></p><p>本文档的存在是为了回答有关 Rust 编程语言的常见问题。它不是一个完整的语言指南，也不是一个教授该语言的工具。它只是一个参考，用来回答 Rust 社区中人们经常遇到的问题，并澄清 Rust 的一些设计决定背后的原因。</p><span id="more"></span><p>如果你觉得有一些常见的或重要的问题在这里没有得到解答，请在 GitHub 上针对<a target="_blank" rel="noopener" href="https://github.com/dtolnay/rust-faq">这个 repo</a>提一个 issue!</p><p><em>这些内容大部分以前都在 rust-lang&#x2F;rust 库中，并且在网站上有一个专门的 FAQ 页面。但是在 2018 年的网站重新设计中，它被删除了。我在这里把它恢复了，因为这些问题中的许多问题仍然被频繁询问。</em></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#The-Rust-Project">The Rust Project</a></li><li><a href="#%E6%80%A7%E8%83%BD">性能</a></li><li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li><li><a href="#%E6%95%B0%E5%AD%97">数字</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li><li><a href="#%E9%9B%86%E5%90%88">集合</a></li><li><a href="#%E6%80%9D%E6%99%AE%E8%84%BE%E6%B0%94am">所有权</a></li><li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a></li><li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></li><li><a href="#%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA">输入&#x2F;输出</a></li><li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></li><li><a href="#%E5%B9%B6%E5%8F%91">并发</a></li><li><a href="#%E5%AE%8F">宏</a></li><li><a href="#Debugging-and-Tooling">Debugging and Tooling</a></li><li><a href="#Low-Level">Low-Level</a></li><li><a href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台</a></li><li><a href="#mod-%E5%92%8C-crate">mod 和 crate</a></li><li><a href="#%E5%BA%93">库</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80">其他语言</a></li><li><a href="#Documentation">Documentation</a></li></ul><h1 id="The-Rust-Project"><a href="#The-Rust-Project" class="headerlink" title="The Rust Project"></a>The Rust Project</h1><h2 id="这个项目的目标是什么？"><a href="#这个项目的目标是什么？" class="headerlink" title="这个项目的目标是什么？"></a>这个项目的目标是什么？</h2><p>设计并实现一种安全的、并发的、实用的系统级语言。</p><p>Rust 之所以存在，是因为在这个抽象和效率水平上的其他语言并不令人满意。特别是：</p><ol><li>对安全性的关注太少。</li><li>他们对并发性的支持很差。</li><li>缺乏实际的承受力。</li><li>它们对资源的控制有限。</li></ol><p>Rust 作为一种替代方案存在，它既能提供高效的代码，又能提供舒适的抽象水平，同时在上述四点上都有改进。</p><h2 id="这个项目是由-Mozilla-控制的吗？"><a href="#这个项目是由-Mozilla-控制的吗？" class="headerlink" title="这个项目是由 Mozilla 控制的吗？"></a>这个项目是由 Mozilla 控制的吗？</h2><p>Rust 在 2006 年作为 Graydon Hoare 的兼职项目开始，并保持了 3 年多。2009 年，当该语言成熟到可以运行基本测试并展示其核心概念时，Mozilla 参与其中。虽然它仍然由 Mozilla 赞助，但 Rust 是由来自世界各地不同地方的爱好者组成的一个多样化社区开发的。<a target="_blank" rel="noopener" href="https://www.rust-lang.org/governance">Rust 团队</a>由 Mozilla 和非 Mozilla 成员组成，GitHub 上的<code>rust</code>到目前为止已经有超过<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/">2300 个独特的贡献者</a>。</p><p>就<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/blob/master/text/1068-rust-governance.md">项目管理</a>而言，Rust 由一个核心团队管理，为项目设定愿景和优先级。从全球角度来指导它。还有一些子团队来指导和促进特定兴趣领域的发展，包括核心语言、编译器、Rust 库、Rust 工具和 Rust 官方社区的管理。这些领域的设计都是通过[RFC]（<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs%EF%BC%89%E6%9D%A5%E6%8E%A8%E8%BF%9B%E7%9A%84%E3%80%82%E5%AF%B9%E4%BA%8E%E4%B8%8D%E9%9C%80%E8%A6%81">https://github.com/rust-lang/rfcs）来推进的。对于不需要</a> RFC 的变化，通过<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust"><code>rustc</code>仓库</a>的 PR 来决定。</p><h2 id="Rust的一些非目标是什么？"><a href="#Rust的一些非目标是什么？" class="headerlink" title="Rust的一些非目标是什么？"></a>Rust的一些非目标是什么？</h2><ol><li>我们不采用任何特别前沿的技术。旧的、成熟的技术会更好。</li><li>我们并不把表现力、极简主义或优雅性置于其他目标之上。这些都是可取的，但是从属的目标。</li><li>我们不打算涵盖 C++ 或任何其他语言的完整功能集。Rust 应该提供大多数情况下的功能。</li><li>我们不打算做到 100% 的静态，100% 的安全，100% 的反射，或在任何其他意义上过于教条化。存在权衡。</li><li>我们不要求 Rust 在“所有可能的平台”上运行。它最终必须在广泛使用的硬件和软件平台上没有不必要的妥协地运行。</li></ol><h2 id="Mozilla-在哪些项目中使用-Rust？"><a href="#Mozilla-在哪些项目中使用-Rust？" class="headerlink" title="Mozilla 在哪些项目中使用 Rust？"></a>Mozilla 在哪些项目中使用 Rust？</h2><p>主要的项目是<a target="_blank" rel="noopener" href="https://github.com/servo/servo">Servo</a>，这是 Mozilla 正在进行的实验性浏览器引擎。他们也在努力将<a target="_blank" rel="noopener" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1135640">Rust 组件</a>整合到 Firefox 中。</p><h2 id="有哪些大型-Rust-项目的例子？"><a href="#有哪些大型-Rust-项目的例子？" class="headerlink" title="有哪些大型 Rust 项目的例子？"></a>有哪些大型 Rust 项目的例子？</h2><p>现在最大的两个 Rust 开源项目是<a target="_blank" rel="noopener" href="https://github.com/servo/servo">Servo</a>和<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust">Rust 编译器</a>本身。</p><h2 id="还有谁在使用-Rust？"><a href="#还有谁在使用-Rust？" class="headerlink" title="还有谁在使用 Rust？"></a>还有谁在使用 Rust？</h2><p><a target="_blank" rel="noopener" href="https://www.rust-lang.org/production/users">越来越多的组织！</a></p><h2 id="我怎样才能轻松地尝试-Rust？"><a href="#我怎样才能轻松地尝试-Rust？" class="headerlink" title="我怎样才能轻松地尝试 Rust？"></a>我怎样才能轻松地尝试 Rust？</h2><p>尝试Rust的最简单方法是通过<a target="_blank" rel="noopener" href="https://play.rust-lang.org/">playpen</a>，这是一个用于编写和运行 Rust 代码的在线应用程序。如果你想在你的系统上尝试 Rust，<a target="_blank" rel="noopener" href="https://www.rust-lang.org/tools/install">安装它</a>并通过书中的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">猜谜游戏</a>教程。</p><h2 id="我怎样才能得到-Rust-问题的帮助？"><a href="#我怎样才能得到-Rust-问题的帮助？" class="headerlink" title="我怎样才能得到 Rust 问题的帮助？"></a>我怎样才能得到 Rust 问题的帮助？</h2><p>有几种方法。你可以。</p><ul><li>在<a target="_blank" rel="noopener" href="https://users.rust-lang.org/">users.rust-lang.org</a>，即 Rust 官方用户论坛上发帖</li><li>在官方的<a target="_blank" rel="noopener" href="https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust">Rust IRC channel</a> (#rust on irc.mozilla.org)中提问。</li><li>在<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>上用“rust”标签提问。</li><li>在<a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust">&#x2F;r&#x2F;rust</a>，非官方的 Rust 子论坛上发帖</li></ul><h2 id="为什么-Rust-随着时间的推移发生了如此大的变化？"><a href="#为什么-Rust-随着时间的推移发生了如此大的变化？" class="headerlink" title="为什么 Rust 随着时间的推移发生了如此大的变化？"></a>为什么 Rust 随着时间的推移发生了如此大的变化？</h2><p>Rust 最初的目标是创造一种安全但可用的系统编程语言。在追求这一目标的过程中，它探索了很多想法，其中一些被保留了下来（生命周期，Trait），而另一些则被抛弃了（类型状态系统，绿色线程）。另外，在 1.0 之前，很多标准库都被重写了，因为早期的设计被更新以最好地使用 Rust 的特性，并提供高质量的、一致的跨平台 API。现在 Rust 已经达到了 1.0，该语言被保证是“稳定的”；虽然它可能继续发展，但在当前 Rust 上运行的代码应该继续在未来的版本上运行。</p><h2 id="Rust语言的版本管理是如何进行的？"><a href="#Rust语言的版本管理是如何进行的？" class="headerlink" title="Rust语言的版本管理是如何进行的？"></a>Rust语言的版本管理是如何进行的？</h2><p>Rust 的语言版本管理遵循<a target="_blank" rel="noopener" href="http://semver.org/">SemVer</a>，只有当需要进行编译器错误的修复、安全漏洞的修补或者需要更多注释以改变类型推断和分发的时候，才允许在小版本中对稳定的 API 进行向后不兼容的修改。更详细的小版本修改指南可参考<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md">语言</a>和<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md">标准库</a>的 RFC。</p><p>Rust 有三个“发布 channel”：稳定版、测试版和 nightly 版。稳定版和测试版每六周更新一次，当前的 nightly 版成为新的测试版，而当前的 nightly 版成为新的稳定版。标记为不稳定的语言和标准库功能或隐藏在特性开关后面的功能只能在 nightly 中使用。新功能以不稳定的形式出现，一旦被核心团队和相关的子团队批准，就会被“解禁”。这种方法允许实验，同时为稳定频道提供强大的向后兼容性保证。</p><p>更多的细节，请阅读 Rust 的博文<a target="_blank" rel="noopener" href="http://blog.rust-lang.org/2014/10/30/Stability.html">“Stability as a Deliverable”</a>。</p><h2 id="我可以在测试版或稳定版频道上使用不稳定的功能吗？"><a href="#我可以在测试版或稳定版频道上使用不稳定的功能吗？" class="headerlink" title="我可以在测试版或稳定版频道上使用不稳定的功能吗？"></a>我可以在测试版或稳定版频道上使用不稳定的功能吗？</h2><p>不，你不能。Rust 努力为测试版和稳定版频道上提供的功能的稳定性提供强有力的保证。当某项功能不稳定时，这意味着我们还不能为它提供这些保证，并且不希望人们依赖它保持不变。这使我们有机会在 nightly 上尝试改变，同时仍然为寻求稳定的人保持强有力的保证。</p><p>事情一直在变稳定，测试版和稳定版频道每六周更新一次，其他时候偶尔也会接受测试版的修复。如果你在等待一个功能，而不使用 nightly，你可以通过检查问题追踪器上的<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues?q=is:issue+is:open+tracking+label:B-unstable"><code>B-unstable</code></a>标签来定位其追踪问题。</p><h2 id="什么是“特性开关”"><a href="#什么是“特性开关”" class="headerlink" title="什么是“特性开关”?"></a>什么是“特性开关”?</h2><p>“特性开关”是 Rust 用来稳定编译器、语言和标准库的特性的机制。一个被“开关控制”的特性只有在 nightly 上才能访问，而且只有在通过<code>#[feature]</code>属性或<code>-Z unstable-options</code>命令行参数明确启用后才能访问。当一个特性被稳定化后，它就可以在稳定发布通道上使用，并且不需要明确启用，这时候这个特性就被认为是稳定的。特性开关允许开发者在开发中的实验性功能在它们在稳定语言中可用之前进行测试。</p><h2 id="为什么要采用-MIT-x2F-ASL2-双许可证？"><a href="#为什么要采用-MIT-x2F-ASL2-双许可证？" class="headerlink" title="为什么要采用 MIT&#x2F;ASL2 双许可证？"></a>为什么要采用 MIT&#x2F;ASL2 双许可证？</h2><p>Apache 许可证包括对专利侵犯的重要保护，但它与 GPL 第 2 版不兼容。为了避免 Rust 与 GPL2 的使用出现问题，Rust 采用了 MIT 许可。</p><h2 id="为什么是-BSD-风格的许可，而不是-MPL-或三合一许可？"><a href="#为什么是-BSD-风格的许可，而不是-MPL-或三合一许可？" class="headerlink" title="为什么是 BSD 风格的许可，而不是 MPL 或三合一许可？"></a>为什么是 BSD 风格的许可，而不是 MPL 或三合一许可？</h2><p>这一方面是由于原始开发者（Graydon）的偏好，另一方面是由于语言往往比网络浏览器等产品有更广泛的受众和更多样化的可能嵌入和最终用途。我们希望尽可能多地吸引这些潜在的贡献者。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><h2 id="Rust有多快？"><a href="#Rust有多快？" class="headerlink" title="Rust有多快？"></a>Rust有多快？</h2><p>非常快! 在许多基准测试中，Rust 已经可以与 C 和 C++ 竞争（比如<a target="_blank" rel="noopener" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html">基准游戏</a>和<a target="_blank" rel="noopener" href="https://github.com/kostya/benchmarks">其他</a>）。</p><p>像 C++ 一样，Rust 把<a target="_blank" rel="noopener" href="http://blog.rust-lang.org/2015/05/11/traits.html">零成本抽象</a>作为它的核心原则之一：Rust 的抽象没有一个施加全局性能惩罚，也没有传统意义上的任何运行时系统的开销。</p><p>鉴于 Rust 是建立在 LLVM 之上的，并努力从 LLVM 的角度类似于 Clang，任何 LLVM 的性能改进也有助于 Rust。从长远来看，Rust 的类型系统中更丰富的信息也应该能够实现 C&#x2F;C++ 代码难以实现或无法实现的优化。</p><h2 id="Rust-有垃圾收集吗？"><a href="#Rust-有垃圾收集吗？" class="headerlink" title="Rust 有垃圾收集吗？"></a>Rust 有垃圾收集吗？</h2><p>不，Rust 的关键创新之一是在<em>不需要</em>垃圾收集的同时保证内存安全（无 segfault）。</p><p>通过避免 GC，Rust 可以提供许多好处：可预测的资源清理，较低的内存管理开销，以及基本上没有运行时系统。所有这些特征都使 Rust 变得精干，并且容易嵌入到任意的上下文中，并使其更容易<a target="_blank" rel="noopener" href="http://calculist.org/blog/2015/12/23/neon-node-rust/">将 Rust 代码与有 GC 的语言集成</a>。</p><p>Rust 通过其所有权和借用系统避免了对 GC 的需求，但同样的系统也有助于解决一系列其他问题，包括<br><a target="_blank" rel="noopener" href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">一般的资源管理</a>和<a target="_blank" rel="noopener" href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">并发性</a>。</p><p>当单一所有权不够用时，Rust 程序依靠标准的引用计数智能指针类型<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>，以及它的线程安全对应类型<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>，而不是 GC。</p><p>然而，我们正在研究<em>可选的</em>垃圾收集作为未来的扩展。我们的目标是使其能够顺利地与垃圾收集的运行时，例如那些由<a target="_blank" rel="noopener" href="https://spidermonkey.dev/">Spidermonkey</a>和<a target="_blank" rel="noopener" href="https://developers.google.com/v8/?hl=en">V8</a>的 JavaScript 引擎提供的。最后，一些人已经在没有编译器的支持情况下研究了实现<a target="_blank" rel="noopener" href="https://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/">纯 Rust 垃圾收集器</a>。</p><h2 id="为什么我的程序很慢？"><a href="#为什么我的程序很慢？" class="headerlink" title="为什么我的程序很慢？"></a>为什么我的程序很慢？</h2><p>Rust 编译器不会用优化来编译，除非被要求这样做，<a target="_blank" rel="noopener" href="https://users.rust-lang.org/t/why-does-cargo-build-not-optimise-by-default/4150/3">因为优化会降低编译速度，而且在开发过程中通常是不可取的</a>。</p><p>如果你用<code>cargo</code>编译，请使用<code>--release</code>标志。如果你直接用<code>rustc</code>编译，使用<code>-O</code>标志。这两个标志中的任何一个都会打开优化功能。</p><h2 id="Rust的编译似乎很慢。这是为什么呢？"><a href="#Rust的编译似乎很慢。这是为什么呢？" class="headerlink" title="Rust的编译似乎很慢。这是为什么呢？"></a>Rust的编译似乎很慢。这是为什么呢？</h2><p>代码翻译和优化。Rust 提供了高水平的抽象，可以编译成高效的机器代码，这些翻译需要时间来运行，特别是在优化时。</p><p>但是 Rust 的编译时间并不像看起来那么糟糕，而且有理由相信它会有所改善。当比较 C++ 和 Rust 之间类似规模的项目时，一般认为整个项目的编译时间是相当的。人们普遍认为 Rust 的编译速度很慢，这在很大程度上是由于 C++ 和 Rust 的<em>编译模型</em>的不同。C++ 的编译单元是文件，而 Rust 的编译单元是由许多文件组成的 crate。因此，在开发过程中，修改一个 C++ 文件可能会导致比 Rust 少得多的重新编译。目前正在努力重构编译器以引入<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/blob/master/text/1298-incremental-compilation.md">增量编译</a>，这将为 Rust 提供 C++ 模型的编译时间优势。</p><p>除了编译模型之外，Rust 的语言设计和编译器实现还有其他几个方面会影响编译时的性能。</p><p>首先，Rust 有一个适度复杂的类型系统，必须花费不可忽视的编译时间来执行约束，使 Rust 在运行时安全。</p><p>其次，Rust 编译器有长期的技术债务，特别是产生了质量很差的 LLVM IR，LLVM 必须花时间“修复”。在 Rust 编译器中加入一个新的内部表示法，称为<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md">MIR</a>，有可能进行更多的优化，提高生成的 LLVM IR 的质量，但这项工作还没有发生过。</p><p>第三，Rust 使用 LLVM 来生成代码是一把双刃剑：虽然它使 Rust 拥有世界一流的运行时性能，但 LLVM 是一个大型框架，不注重编译时的性能，特别是在处理质量差的输入时。</p><p>最后，虽然 Rust 的首选策略是单态泛型（类似于 C++），但它要求生成的代码比其他翻译策略多得多。Rust 的程序员可以使用特征对象，通过使用动态调度来换取这种代码的膨胀。</p><h2 id="为什么-Rust-的HashMap很慢？"><a href="#为什么-Rust-的HashMap很慢？" class="headerlink" title="为什么 Rust 的HashMap很慢？"></a>为什么 Rust 的<code>HashMap</code>很慢？</h2><p>默认情况下，Rust 的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SipHash">SipHash</a> 散列算法，该算法旨在防止<a target="_blank" rel="noopener" href="http://programmingisterrible.com/post/40620375793/hash-table-denial-of-service-attacks-revisited">散列表碰撞攻击</a>，同时提供<a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust/comments/3hw9zf/rust_hasher_comparisons/cub4oh6">各种工作负载下的合理性能</a>。</p><p>虽然 SipHash <a target="_blank" rel="noopener" href="http://cglab.ca/%7Eabeinges/blah/hash-rs/">在许多情况下表现出有竞争力的性能</a>，但它比其他散列算法明显慢的一种情况是在短键，如整数。这就是为什么 Rust 程序员经常观察到<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>的性能缓慢。在这种情况下，经常推荐使用 <a target="_blank" rel="noopener" href="https://crates.io/crates/fnv">FNV hasher</a>，但要注意它不具备与 SipHash 一样的抗碰撞特性。</p><h2 id="为什么没有集成的基准测试基础设施"><a href="#为什么没有集成的基准测试基础设施" class="headerlink" title="为什么没有集成的基准测试基础设施?"></a>为什么没有集成的基准测试基础设施?</h2><p>有，但它只在 nightly 上可用。我们最终计划建立一个可插拔的系统来进行综合基准测试，但与此同时，目前的系统<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/29553">被认为是不稳定的</a>。</p><h2 id="Rust-是否做了尾调用优化？"><a href="#Rust-是否做了尾调用优化？" class="headerlink" title="Rust 是否做了尾调用优化？"></a>Rust 是否做了尾调用优化？</h2><p>一般来说，不会。在<a target="_blank" rel="noopener" href="http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization">有限的情况下</a>可能会进行尾部调用优化，但<a target="_blank" rel="noopener" href="https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html">不保证</a>。由于这个功能一直是人们所希望的，Rust 保留了一个关键字（<code>become</code>），尽管目前还不清楚它在技术上是否可行，也不清楚它是否会被实现。曾经有一个<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/pull/81">拟议的扩展</a>，允许在某些情况下消除尾随调用，但目前被推迟了。</p><h2 id="Rust-有-runtime-吗？"><a href="#Rust-有-runtime-吗？" class="headerlink" title="Rust 有 runtime 吗？"></a>Rust 有 runtime 吗？</h2><p>不是 Java 等语言所使用的典型意义上的运行时，但是 Rust 标准库的一部分可以被认为是“运行时”，它提供了一个堆、回溯、解开和堆栈守护。有一个<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/master/library/std/src/rt.rs">少量的初始化代码</a>，在用户的<code>main</code>函数之前运行。Rust 标准库还链接了 C 标准库，它也做了类似的<a target="_blank" rel="noopener" href="http://www.embecosm.com/appnotes/ean9/html/ch05s02.html">运行时初始化</a>。Rust 代码可以在没有标准库的情况下进行编译，在这种情况下，运行时与 C 语言大致相当。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="为什么要用大括号-为什么-Rust-的语法不能像-Haskell-或-Python-那样？"><a href="#为什么要用大括号-为什么-Rust-的语法不能像-Haskell-或-Python-那样？" class="headerlink" title="为什么要用大括号? 为什么 Rust 的语法不能像 Haskell 或 Python 那样？"></a>为什么要用大括号? 为什么 Rust 的语法不能像 Haskell 或 Python 那样？</h2><p>使用大括号来表示块是各种编程语言中常见的设计选择，而 Rust 的一致性对于已经熟悉这种风格的人来说是很有用的。</p><p>大括号还可以为程序员提供更灵活的语法，并在编译器中提供更简单的解析器。</p><h2 id="我可以在if条件上不加小括号，那么为什么我必须在单行块周围加上大括号？为什么不允许使用-C-语言的风格"><a href="#我可以在if条件上不加小括号，那么为什么我必须在单行块周围加上大括号？为什么不允许使用-C-语言的风格" class="headerlink" title="我可以在if条件上不加小括号，那么为什么我必须在单行块周围加上大括号？为什么不允许使用 C 语言的风格?"></a>我可以在<code>if</code>条件上不加小括号，那么为什么我必须在单行块周围加上大括号？为什么不允许使用 C 语言的风格?</h2><p>C 语言要求“if”语句的条件必须有小括号，但大括号是可选的，而 Rust 对其“if”表达式做出了相反的选择。这使得条件语句与语句主体明确分开，并避免了可选大括号的危害，这可能导致在重构过程中出现容易被忽略的错误，比如苹果的 <a target="_blank" rel="noopener" href="https://gotofail.com/">goto fail</a> 错误。</p><h2 id="为什么没有字典的字面语法？"><a href="#为什么没有字典的字面语法？" class="headerlink" title="为什么没有字典的字面语法？"></a>为什么没有字典的字面语法？</h2><p>Rust 的整体设计倾向于限制<em>语言</em>的大小，同时启用强大的<em>库</em>。虽然 Rust 确实为数组和字符串字面提供了初始化语法，但这是语言中唯一的集合类型。其他库定义的类型，包括无处不在的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>集合类型，都使用宏进行初始化，如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.vec!.html"><code>vec!</code></a>宏。</p><p>这种使用 Rust 的宏设施来初始化集合的设计选择在未来可能会被通用地扩展到其他集合，不仅可以简单地初始化<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>，还可以初始化其他集合类型，如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a>。同时, 如果你想要一个更方便的初始化集合的语法, 你可以<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/27582739/how-do-i-create-a-hashmap-literal">创建你自己的宏</a>来提供它.</p><h2 id="我应该在什么时候使用隐式返回？"><a href="#我应该在什么时候使用隐式返回？" class="headerlink" title="我应该在什么时候使用隐式返回？"></a>我应该在什么时候使用隐式返回？</h2><p>Rust 是一种非常面向表达式的语言，而“隐式返回”是这种设计的一部分。像<code>if</code>s, <code>match</code>es, 和普通块这样的结构在 Rust 中都是表达式。例如，下面的代码检查一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.i64.html"><code>i64</code></a>是否为奇数，通过简单地将其作为一个值来返回结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">is_odd</span>(x: <span class="type">i64</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> &#123; <span class="literal">true</span> &#125; <span class="keyword">else</span> &#123; <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然它可以进一步简化，比如说。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">is_odd</span>(x: <span class="type">i64</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    x % <span class="number">2</span> != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个例子中，函数的最后一行是该函数的返回值。需要注意的是，如果一个函数以分号结束，其返回类型将是<code>()</code>，表示没有返回值。隐式返回必须省略分号，才能发挥作用。</p><p>显式返回只有在隐式返回不可能时才会使用，因为你要在函数主体结束前返回。虽然上面的每个函数都可以用<code>return</code>关键字和分号来写，但这样做是不必要的冗长，而且与 Rust 代码的惯例不一致。</p><h2 id="为什么不推断出函数的签名？"><a href="#为什么不推断出函数的签名？" class="headerlink" title="为什么不推断出函数的签名？"></a>为什么不推断出函数的签名？</h2><p>在 Rust 中，声明往往带有明确的类型，而实际代码的类型是推断出来的。这种设计有几个原因：</p><ul><li>强制性的声明签名有助于在模块和板块层面上执行接口的稳定性。</li><li>签名提高了程序员对代码的理解，消除了 IDE 在整个板块中运行推理算法来猜测一个函数的参数类型的需要；它总是显式的，就在附近。</li><li>在机制上，它简化了推理算法，因为推理只需要一次看一个函数。</li></ul><h2 id="为什么match必须是详尽的"><a href="#为什么match必须是详尽的" class="headerlink" title="为什么match必须是详尽的?"></a>为什么<code>match</code>必须是详尽的?</h2><p>为了帮助重构和清晰化。</p><p>首先，如果每一种可能性都被<code>match</code>所覆盖，那么将来在<code>enum</code>中增加变体将导致编译失败，而不是在运行时出错。这种类型的编译器帮助使得 Rust 中的无畏重构成为可能。</p><p>其次，穷举式检查使默认情况的语义变得明确：一般来说，非穷举式<code>match</code>的唯一安全方式是在没有匹配到任何东西时让线程恐慌。Rust 的早期版本并不要求<code>match</code>情况是详尽的，而且发现它是一个很大的 bug 来源。</p><p>通过使用<code>_</code>通配符，可以很容易地忽略所有未指定的情况。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> val.<span class="title function_ invoke__">do_something</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cat</span>(a) =&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    _ =&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Numerics"><a href="#Numerics" class="headerlink" title="Numerics"></a>Numerics</h1><h2 id="对于浮点运算，我应该选择f32和f64中的哪一个"><a href="#对于浮点运算，我应该选择f32和f64中的哪一个" class="headerlink" title="对于浮点运算，我应该选择f32和f64中的哪一个?"></a>对于浮点运算，我应该选择<code>f32</code>和<code>f64</code>中的哪一个?</h2><p>选择哪种方式取决于程序的目的。</p><p>如果你对浮点数的最大精度感兴趣, 那么就选择<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>. 如果你对保持数值的大小或最大的效率更感兴趣，并且不关心每个数值的位数较少所带来的误差，那么<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>更好。对<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>的操作通常更快，即使是在 64 位硬件上。作为一个常见的例子，图形编程通常使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>，因为它需要高性能，而 32 位浮点数足以代表屏幕上的像素。</p><p>如果有疑问，可以选择<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>以获得更大的精度。</p><h2 id="为什么我不能比较浮点数或用它们作为HashMap或BTreeMap的键"><a href="#为什么我不能比较浮点数或用它们作为HashMap或BTreeMap的键" class="headerlink" title="为什么我不能比较浮点数或用它们作为HashMap或BTreeMap的键?"></a>为什么我不能比较浮点数或用它们作为<code>HashMap</code>或<code>BTreeMap</code>的键?</h2><p>浮点数可以用<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, 和<code>&gt;=</code>运算符，以及<code>partial_cmp()</code>函数进行比较。<code>==</code>和<code>！=</code>是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>特性的一部分，而<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>和<code>partial_cmp()</code>是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> 特性的一部分。</p><p>浮点数不能用<code>cmp()</code>函数进行比较，它是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>特性的一部分，因为浮点数没有总排序。此外，浮点数没有全等关系，所以它们也没有实现<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>特性。</p><p>由于浮点数<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NaN"><code>NaN</code></a>不小于、大于或等于任何其他浮点数或其本身，所以浮点数没有总排序或平等关系。</p><p>因为浮点数没有实现<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>或<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>，所以它们不能被用于特质边界需要这些特质的类型，例如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a>或[<code>HashMap</code>]。这一点很重要，因为这些类型<em>假设</em>它们的键提供了一个总排序或总等价关系，否则会出现故障。</p><p>有一个<a target="_blank" rel="noopener" href="https://crates.io/crates/ordered-float">crate</a>包装了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>以提供<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>的实现，这在某些情况下可能很有用。</p><h2 id="我如何在数字类型之间进行转换"><a href="#我如何在数字类型之间进行转换" class="headerlink" title="我如何在数字类型之间进行转换?"></a>我如何在数字类型之间进行转换?</h2><p>有两种方法：<code>as</code>关键字，它为原始类型做简单的转换，以及<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>特性，它们是为一些类型转换而实现的（你也可以为你自己的类型实现）。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>特性只在转换无损的情况下实现，所以例如，<code>f64::from(0f32)</code>会被编译，而<code>f32::from(0f64)</code>不会。另一方面，<code>as</code>将在任何两个原始类型之间进行转换，必要时截断数值。</p><h2 id="为什么Rust没有增量和减量运算符"><a href="#为什么Rust没有增量和减量运算符" class="headerlink" title="为什么Rust没有增量和减量运算符?"></a>为什么Rust没有增量和减量运算符?</h2><p>Preincrement 和 Postincrement（以及与之对应的 Decrement）虽然方便，但也相当复杂。它们需要对计算顺序的了解，并经常导致 C 和 C++ 中的微妙错误和未定义行为。和<code>x = x + 1</code>相比<code>x += 1</code>只是稍微长一点，但不明确。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="如何将一个String或Vec-lt-T-gt-转换为一个片断-amp-str和-amp-T"><a href="#如何将一个String或Vec-lt-T-gt-转换为一个片断-amp-str和-amp-T" class="headerlink" title="如何将一个String或Vec&lt;T&gt;转换为一个片断(&amp;str和&amp;[T])?"></a>如何将一个<code>String</code>或<code>Vec&lt;T&gt;</code>转换为一个片断(<code>&amp;str</code>和<code>&amp;[T]</code>)?</h2><p>通常情况下，你可以在期望有片断的地方传递一个对<code>String</code>或<code>Vec&lt;T&gt;</code>的引用。使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-02-deref.html">Deref coercions</a>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code>s</a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code>s</a>在用<code>&amp;</code>或<code>&amp;mut</code>传递引用时，将自动联合到各自的片上。</p><p>在<code>&amp;str</code>和<code>&amp;[T]</code>上实现的方法可以直接访问<code>String</code>和<code>Vec&lt;T&gt;</code>。例如，<code>some_string.trim()</code>可以工作，尽管<code>trim</code>是<code>&amp;str</code>上的方法，而<code>some_string</code>是一个<code>String</code>。</p><p>在某些情况下，例如通用代码，有必要进行手动转换。手动转换可以使用切片操作符来实现，像这样。<code>&amp;my_vec[...]</code>。</p><h2 id="我如何从-amp-str转换到String或反过来？"><a href="#我如何从-amp-str转换到String或反过来？" class="headerlink" title="我如何从&amp;str转换到String或反过来？"></a>我如何从<code>&amp;str</code>转换到<code>String</code>或反过来？</h2><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string"><code>to_string()</code></a>方法可以将<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a>转换为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>，当你借用一个引用时，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>自动转换为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a>。这两种情况在下面的例子中都有演示。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Jane Doe&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span> (<span class="string">&quot;Hello &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种不同的字符串类型之间有什么区别？"><a href="#两种不同的字符串类型之间有什么区别？" class="headerlink" title="两种不同的字符串类型之间有什么区别？"></a>两种不同的字符串类型之间有什么区别？</h2><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>是一个在堆上分配的 UTF-8 字节的自有缓冲区。可变的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>可以被修改，根据需要增加其容量。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a>是在其他地方分配的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>的一个固定容量的“视图”，如果是从<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>中引用的片断，通常在堆上，如果是字符串字面，在静态内存中。</p><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a>是由 Rust 语言实现的原始类型，而<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>是由标准库实现的。</p><h2 id="我如何在一个String中进行-O-1-的字符访问"><a href="#我如何在一个String中进行-O-1-的字符访问" class="headerlink" title="我如何在一个String中进行 O(1) 的字符访问?"></a>我如何在一个<code>String</code>中进行 O(1) 的字符访问?</h2><p>你不能。至少在你不清楚“字符”是什么意思的情况下，以及在对字符串进行预处理以找到所需字符的索引的情况下是不行的。</p><p>Rust 字符串是 UTF-8 编码的。UTF-8 中的单个视觉字符不一定是一个字节，因为它在 ASCII 编码的字符串中是一个字节。每个字节被称为“代码单元”（在 UTF-16 中，代码单元是 2 个字节；在 UTF-32 中是4个字节）。“代码点”由一个或多个代码单元组成，并组合成最接近于字符的“字素群”。</p><p>因此，即使你可以对 UTF-8 字符串中的字节进行索引，你也无法在恒定时间内访问第 i 个码位或字母群。然而，如果你知道所需的码位或字形群从哪个字节开始，那么你就可以在恒定时间内访问它。包括<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html#method.find">str::find()</a>和 regex 匹配在内的函数都会返回字节索引，以方便这种访问。</p><h2 id="为什么字符串默认为-UTF-8？"><a href="#为什么字符串默认为-UTF-8？" class="headerlink" title="为什么字符串默认为 UTF-8？"></a>为什么字符串默认为 UTF-8？</h2><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a>类型是 UTF-8，因为我们在野外观察到更多的文本是用这种编码的–特别是在网络传输中，它是 endian-agnostic 的–而且我们认为最好不要让 I&#x2F;O 的默认处理涉及到在每个方向重新编码代码点。</p><p>这确实意味着在一个字符串中定位一个特定的 Unicode 编码点是一个 O(n) 操作，尽管如果开始的字节索引已经知道，那么它们可以在 O(1) 中被访问。一方面，这显然是不可取的；另一方面，这个问题充满了权衡，我们想指出几个重要的限定条件。</p><p>扫描一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a>的 ASCII 范围的代码点仍然可以安全地逐个字节地进行。如果你使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>.as_bytes()</code></a>，取出一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.u8.html"><code>u8</code></a>只需花费<code>O(1)</code>，并产生一个可以被转换并与 ASCII 范围的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>比较的值。因此，如果你（比如）在<code>\n</code>上断行，基于字节的处理方法仍然有效。UTF-8 就是这样被精心设计的。</p><p>大多数“面向字符”的文本操作只有在非常有限的语言假设下才能工作，如“仅 ASCII 范围的代码点”。在 ASCII 范围之外，你往往不得不使用复杂的（非恒定时间）算法来确定语言单位（字形、单词、段落）的边界。我们建议使用一种“诚实的”具有语言意识的、经 Unicode 批准的算法。</p><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>类型是 UTF-32。如果你确定你需要做一个代码点的算法，写一个<code>type wstr = [char]</code>，并将一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a>一次性解压到其中，然后用<code>wstr</code>工作，这是非常容易的。换句话说：如果你需要使用这种编码，语言没有<code>默认解码为 UTF32</code>的事实不应该阻止你解码（或以任何其他方式重新编码）。</p><p>关于为什么 UTF-8 通常比 UTF-16 或 UTF-32 更受欢迎，请阅读 <a target="_blank" rel="noopener" href="http://utf8everywhere.org/">UTF-8 Everywhere 宣言</a>。</p><h2 id="我应该使用什么字符串类型？"><a href="#我应该使用什么字符串类型？" class="headerlink" title="我应该使用什么字符串类型？"></a>我应该使用什么字符串类型？</h2><p>Rust 有四对字符串类型，每一对都有不同的用途。在每一对中，都有一个“自有”的字符串类型，和一个“分片”的字符串类型。这个组织看起来像这样。</p><table><thead><tr><th align="left"></th><th align="left">“Slice” type</th><th align="left">“Owned” type</th></tr></thead><tbody><tr><td align="left">UTF-8</td><td align="left"><code>str</code></td><td align="left"><code>String</code></td></tr><tr><td align="left">OS-compatible</td><td align="left"><code>OsStr</code></td><td align="left"><code>OsString</code></td></tr><tr><td align="left">C-compatible</td><td align="left"><code>CStr</code></td><td align="left"><code>CString</code></td></tr><tr><td align="left">System path</td><td align="left"><code>Path</code></td><td align="left"><code>PathBuf</code></td></tr></tbody></table><p>Rust 的不同字符串类型有不同的用途。<code>String</code>和<code>str</code>是 UTF-8 编码的通用字符串。<code>OsString</code>和<code>OsStr</code>是根据当前平台编码的，在与操作系统交互时使用。<code>CString</code>和<code>CStr</code>相当于C 语言中的字符串，在 FFI 代码中使用。<code>PathBuf</code>和<code>Path</code>是对<code>OsString</code>和<code>OsStr</code>的方便包装，提供特定于路径操作的方法。</p><h2 id="我怎样才能写一个既接受-amp-str又接受String的函数"><a href="#我怎样才能写一个既接受-amp-str又接受String的函数" class="headerlink" title="我怎样才能写一个既接受&amp;str又接受String的函数?"></a>我怎样才能写一个既接受<code>&amp;str</code>又接受<code>String</code>的函数?</h2><p>有几种选择，取决于函数的需要。</p><ul><li>如果函数需要一个自有的字符串，但又想接受任何类型的字符串，可以使用一个<code>Into&lt;String&gt;</code>绑定。</li><li>如果函数需要一个字符串分片，但希望接受任何类型的字符串，使用<code>AsRef&lt;str&gt;</code>绑定。</li><li>如果函数不关心字符串的类型，而想统一处理这两种可能性，使用<code>Cow&lt;str&gt;</code>作为输入类型。</li></ul><h3 id="使用Into-lt-String-gt"><a href="#使用Into-lt-String-gt" class="headerlink" title="使用Into&lt;String&gt;"></a>使用<code>Into&lt;String&gt;</code></h3><p>在这个例子中，该函数将同时接受自有字符串和字符串片，要么不做任何事情，要么在函数主体内将输入的字符串转换为自有字符串。注意，转换需要明确进行，否则不会发生。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">accepts_both</span>&lt;S: <span class="built_in">Into</span>&lt;<span class="type">String</span>&gt;&gt;(s: S) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = s.<span class="title function_ invoke__">into</span>(); <span class="comment">// 这将把 s 转换成一个`String`。</span></span><br><span class="line">    <span class="comment">// ... 其余的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用AsRef-lt-str-gt"><a href="#使用AsRef-lt-str-gt" class="headerlink" title="使用AsRef&lt;str&gt;"></a>使用<code>AsRef&lt;str&gt;</code></h3><p>在这个例子中，该函数将接受拥有的字符串和字符串片断，要么不做任何事情，要么将输入的字符串片断转换为字符串。这可以通过引用输入来自动完成，像这样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">accepts_both</span>&lt;S: <span class="built_in">AsRef</span>&lt;<span class="type">str</span>&gt;&gt;(s: &amp;S) &#123;</span><br><span class="line">    <span class="comment">// ... 该函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Cow-lt-str-gt"><a href="#使用Cow-lt-str-gt" class="headerlink" title="使用Cow&lt;str&gt;"></a>使用<code>Cow&lt;str&gt;</code></h3><p>在这个例子中，函数接收了一个<code>Cow&lt;str&gt;</code>，它不是一个通用类型，而是一个容器，根据需要包含一个自有的字符串或字符串片断。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">accepts_cow</span>(s: Cow&lt;<span class="type">str</span>&gt;) &#123;</span><br><span class="line">    <span class="comment">// ... 该函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="我可以在-Rust-中有效地实现向量和链表等数据结构吗"><a href="#我可以在-Rust-中有效地实现向量和链表等数据结构吗" class="headerlink" title="我可以在 Rust 中有效地实现向量和链表等数据结构吗?"></a>我可以在 Rust 中有效地实现向量和链表等数据结构吗?</h2><p>如果你实现这些数据结构的原因是为了在其他程序中使用它们，那就没有必要了，因为这些数据结构的有效实现已经由标准库提供了。</p><p>然而，如果<a href="book-to-many-lists">你的理由只是为了学习</a>，那么你很可能需要涉足不安全代码。虽然这些数据结构可以完全用安全的 Rust 来实现，但其性能可能会比使用不安全的代码要差。原因很简单，向量和链接列表等数据结构依赖于指针和内存操作，而这些操作在安全 Rust 中是不允许的。</p><p>例如，一个双链接列表需要对每个节点有两个可变引用，但这违反了 Rust 的可变引用别名规则。你可以用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a>来解决这个问题，但是性能会比你想要的差。使用不安全的代码，你可以绕过可变引用别名规则的限制，但必须手动验证你的代码是否引入了内存安全违规。</p><h2 id="我怎样才能在不移动-x2F-消耗集合的情况下对其进行迭代？"><a href="#我怎样才能在不移动-x2F-消耗集合的情况下对其进行迭代？" class="headerlink" title="我怎样才能在不移动&#x2F;消耗集合的情况下对其进行迭代？"></a>我怎样才能在不移动&#x2F;消耗集合的情况下对其进行迭代？</h2><p>最简单的方法是通过使用集合的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>实现。下面是一个关于<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>&amp;Vec</code></a>的例子。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">print!</span> (<span class="string">&quot;&#123;&#125; &quot;</span>, item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span> (<span class="string">&quot;\nLength: &#123;&#125;&quot;</span>, v.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure><p>Rust 的<code>for</code>循环对它们要迭代的东西调用<code>into_iter()</code>（定义在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>trait 上）。任何实现了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>trait 的东西都可以用<code>for</code>循环进行循环。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>是为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>&amp;Vec</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>&amp;mut Vec</code></a>实现的，导致来自<code>into_iter()</code>的迭代器借用集合的内容，而不是移动&#x2F;消费它们。这对其他标准集合也是如此。</p><p>如果需要一个移动&#x2F;消耗的迭代器，编写<code>for</code>循环时不要在迭代中使用<code>&amp;</code>或<code>&amp;mut</code>。</p><p>如果你需要直接访问一个借用的迭代器，你通常可以通过调用<code>iter()</code>方法得到它。</p><h2 id="为什么我需要在数组声明中输入数组大小"><a href="#为什么我需要在数组声明中输入数组大小" class="headerlink" title="为什么我需要在数组声明中输入数组大小?"></a>为什么我需要在数组声明中输入数组大小?</h2><p>你不一定要这样做。如果你直接声明一个数组，大小是根据元素的数量推断出来的。但是如果你声明的是一个接收固定大小的数组的函数，编译器就必须知道这个数组有多大。</p><p>有一点需要注意的是，目前 Rust 并没有对不同大小的数组提供泛型。如果你想接受一个连续的可变数量的值的容器，使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>或 slice（取决于你是否需要所有权）。</p><h1 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h1><h2 id="我怎样才能实现一个包含环的图或其他数据结构"><a href="#我怎样才能实现一个包含环的图或其他数据结构" class="headerlink" title="我怎样才能实现一个包含环的图或其他数据结构?"></a>我怎样才能实现一个包含环的图或其他数据结构?</h2><p>至少有四种选择（在<a target="_blank" rel="noopener" href="https://rust-unofficial.github.io/too-many-lists/">Too Many Linked Lists</a>中详细讨论过）。</p><ul><li>你可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak</code></a>实现它，以允许节点的共享所有权。尽管这种方法需要付出内存管理的代价。</li><li>你可以使用“不安全”的代码实现它，使用原始指针。这将更加高效，但却绕过了 Rust 的安全保证。</li><li>使用向量和这些向量的索引。有<a target="_blank" rel="noopener" href="http://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">几个</a><a target="_blank" rel="noopener" href="https://featherweightmusings.blogspot.com/2015/04/graphs-in-rust.html">可用</a>这种方法的例子和解释。</li><li>用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>使用借用的引用。对于这种方法有<a target="_blank" rel="noopener" href="https://github.com/nrc/r4cppp/blob/master/graphs/README.md#node-and-unsafecell">解释和代码</a>。</li></ul><h2 id="我怎样才能定义一个包含对其自身字段之一的引用的结构？"><a href="#我怎样才能定义一个包含对其自身字段之一的引用的结构？" class="headerlink" title="我怎样才能定义一个包含对其自身字段之一的引用的结构？"></a>我怎样才能定义一个包含对其自身字段之一的引用的结构？</h2><p>这是有可能的，但是这样做没有用。该结构会被自己永久借用，因此不能被移动。下面是一些说明这个问题的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unmovable</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    x: <span class="type">u32</span>,</span><br><span class="line">    y: Cell&lt;<span class="type">Option</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">u32</span>&gt;&gt;。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">test</span> = Unmovable &#123; x: <span class="number">42</span>, y: Cell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>) &#125;。</span><br><span class="line">    test.y.<span class="title function_ invoke__">set</span>(<span class="title function_ invoke__">Some</span>(&amp;test.x))。</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span> (<span class="string">&quot;&#123;:?&#125;&quot;</span>, test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按值传递、消耗、移动和转移所有权之间有什么区别"><a href="#按值传递、消耗、移动和转移所有权之间有什么区别" class="headerlink" title="按值传递、消耗、移动和转移所有权之间有什么区别?"></a>按值传递、消耗、移动和转移所有权之间有什么区别?</h2><p>这些是同一事物的不同术语。在所有的情况下，这意味着值已经被转移到另一个所有者那里，并且脱离了原所有者的占有，原所有者不能再使用它。如果一个类型实现了<code>Copy</code>特性，那么原所有者的值就不会被废止，仍然可以使用。</p><h2 id="为什么某些类型的值在传递给一个函数后可以使用，而重复使用其他类型的值会导致错误？"><a href="#为什么某些类型的值在传递给一个函数后可以使用，而重复使用其他类型的值会导致错误？" class="headerlink" title="为什么某些类型的值在传递给一个函数后可以使用，而重复使用其他类型的值会导致错误？"></a>为什么某些类型的值在传递给一个函数后可以使用，而重复使用其他类型的值会导致错误？</h2><p>如果一个类型实现了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>特性，那么它在传递给函数时就会被复制。Rust 中的所有数字类型都实现了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>，但结构类型默认不实现<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>，所以它们被移动。这意味着该结构不能再被用于其他地方，除非通过返回将其移回函数之外。</p><h2 id="如何处理“use-of-moved-value”的错误？"><a href="#如何处理“use-of-moved-value”的错误？" class="headerlink" title="如何处理“use of moved value”的错误？"></a>如何处理“use of moved value”的错误？</h2><p>这个错误意味着你要使用的值已经被转移到一个新的所有者那里。首先要检查的是有关的移动是否是必要的：如果它移动到一个函数中，也许可以重写该函数以使用一个引用，而不是移动。否则，如果被移动的类型实现了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>，那么在移动前对其调用<code>clone()</code>将移动它的一个副本，留下原始的仍然可以继续使用。但是请注意，克隆一个值通常应该是最后的手段，因为克隆可能很昂贵，会导致进一步的分配。</p><p>如果移动的值是你自己的自定义类型，考虑实现<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>（用于隐式复制，而不是移动）或<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>（显式复制）。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>最常用的实现方式是<code>#[derive(Copy, Clone)]</code>（<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>需要<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>），而<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>则是&#96;#[derive(Clone)]。</p><p>如果这些都不可能，你可能想修改获得所有权的函数，以便在函数退出时返回数值的所有权。</p><h2 id="在方法声明中使用self、-amp-self或-amp-mut-self的规则是什么"><a href="#在方法声明中使用self、-amp-self或-amp-mut-self的规则是什么" class="headerlink" title="在方法声明中使用self、&amp;self或&amp;mut self的规则是什么?"></a>在方法声明中使用<code>self</code>、<code>&amp;self</code>或<code>&amp;mut self</code>的规则是什么?</h2><ul><li>当一个函数需要消耗值的时候，使用<code>self</code>。</li><li>当一个函数只需要一个对值的只读引用时，使用<code>&amp;self</code>。</li><li>当一个函数需要在不消耗该值的情况下改变该值时，使用<code>&amp;mut self</code>。</li></ul><h2 id="我怎样才能理解借用检查器？"><a href="#我怎样才能理解借用检查器？" class="headerlink" title="我怎样才能理解借用检查器？"></a>我怎样才能理解借用检查器？</h2><p>借用检查器在评估 Rust 代码时只应用一些规则，这些规则可以在 Rust 书的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-02-deref.html">借用部分</a>中找到。这些规则是：</p><blockquote><p>首先，任何借用必须持续的范围不大于所有者的范围。第二，你可以有这两种借用中的一种或另一种，但不能同时存在：</p><ul><li>对一个资源的一个或多个引用（&amp;T）。</li><li>一个可变的引用（&amp;mut T）。</li></ul></blockquote><p>虽然这些规则本身很简单，但持续地遵守这些规则并不容易，特别是对于那些不习惯推理寿命和所有权的人来说。</p><p>了解借用检查器的第一步是阅读它产生的错误。为了确保借用检查器在解决它所发现的问题方面提供高质量的帮助，我们做了大量的工作。当你遇到借用检查器的问题时，第一步是慢慢地、仔细地阅读所报告的错误，只有在理解了所描述的错误之后，才能接近代码。</p><p>第二步是熟悉 Rust 标准库提供的所有权和可变性相关的容器类型，包括<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a>。这些都是表达某些所有权和可变性情况的有用和必要的工具，并且被写成性能代价最小。</p><p>理解借用检查器最重要的一个部分是实践。Rust 的强静态分析保证是严格的，与许多程序员之前的工作有很大不同。需要一些时间才能完全适应一切。</p><p>如果你发现自己在借用检查器上挣扎，或者没有耐心了，请随时联系 <a target="_blank" rel="noopener" href="https://www.rust-lang.org/community">Rust 社区</a>寻求帮助。</p><h2 id="什么时候Rc有用？"><a href="#什么时候Rc有用？" class="headerlink" title="什么时候Rc有用？"></a>什么时候<code>Rc</code>有用？</h2><p>这在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>的官方文档中有所涉及，Rust 的非原子引用计算的指针类型。简而言之，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>和它的线程安全表亲<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>对于表达共享所有权是很有用的，当没有人访问相关内存时，系统会自动将其取消。</p><h2 id="我如何从一个函数中返回一个闭包？"><a href="#我如何从一个函数中返回一个闭包？" class="headerlink" title="我如何从一个函数中返回一个闭包？"></a>我如何从一个函数中返回一个闭包？</h2><p>要从一个函数中返回一个闭包，它必须是一个“移动闭包”，也就是说，闭包是用<code>move</code>关键字声明的。正如 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch13-01-closures.html">Rust 书中所解释的</a>，这使得闭包拥有自己的捕获变量的副本，独立于其父级堆栈框架。否则，返回一个闭包将是不安全的，因为它将允许访问不再有效的变量；换句话说：它将允许读取可能无效的内存。闭包还必须被包裹在一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>中，这样它就被分配在堆上。阅读更多关于这个的内容<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch13-01-closures.html">在书中</a>。</p><h2 id="什么是-deref-coercion，它是如何工作的？"><a href="#什么是-deref-coercion，它是如何工作的？" class="headerlink" title="什么是 deref coercion，它是如何工作的？"></a>什么是 deref coercion，它是如何工作的？</h2><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-02-deref.html">deref coercion</a> 是一个很方便的 coercion。自动将对指针的引用(例如, <code>&amp;Rc&lt;T&gt;</code> 或 <code>&amp;Box&lt;T&gt;</code>)转换为对其内容的引用（例如，<code>&amp;T</code>）。Deref coercion 的存在是为了使 Rust 的使用更符合人体工程学，并通过<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>特性实现。</p><p>Deref 的实现表明实现类型可以通过调用<code>deref</code>方法转换为目标类型，该方法接收对调用类型的不可变的引用，并返回对目标类型的引用（具有相同的生命周期）。<code>*</code>前缀操作符是<code>deref</code>方法的简写。</p><p>它们被称“coercions”，因为下面的规则，这里引用了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-02-deref.html">Rust 书</a>。</p><blockquote><p>如果你有一个类型<code>U</code>，并且它实现了<code>Deref&lt;Target=T&gt;</code>，那么<code>&amp;U</code>的值将自动被强制为<code>T</code>。</p></blockquote><p>例如，如果你有一个<code>&amp;Rc&lt;String&gt;</code>，它将通过这个规则联合成一个<code>&amp;String</code>，然后以同样的方式联合成一个<code>&amp;str</code>。因此，如果一个函数需要一个<code>&amp;str</code>参数，你可以直接传入一个<code>&amp;Rc&lt;String&gt;</code>，所有的强制都通过<code>Deref</code>特性自动处理。</p><p>最常见的 Derefcoercions 种类是：</p><ul><li><code>&amp;Rc&lt;T&gt;</code>到<code>&amp;T</code>。</li><li><code>&amp;Box&lt;T&gt;</code>到<code>&amp;T</code>。</li><li><code>&amp;Arc&lt;T&gt;</code>到<code>&amp;T</code>。</li><li><code>&amp;Vec&lt;T&gt;</code>改为<code>&amp;[T]</code>。</li><li><code>&amp;String</code>改为<code>&amp;str</code>。</li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="为什么是生命周期"><a href="#为什么是生命周期" class="headerlink" title="为什么是生命周期?"></a>为什么是生命周期?</h2><p>生命周期是 Rust 对内存安全问题的回答。它允许 Rust 确保内存安全而不需要付出垃圾回收的性能代价。它们是基于各种学术工作的。</p><h2 id="为什么生命周期的语法是这样的？"><a href="#为什么生命周期的语法是这样的？" class="headerlink" title="为什么生命周期的语法是这样的？"></a>为什么生命周期的语法是这样的？</h2><p><code>&#39;a</code>语法来自于 ML 系列编程语言，其中<code>&#39;a</code>用于表示一个通用类型参数。对于 Rust 来说，这种语法必须是明确的、明显的，并且适合在类型声明中与 traits 和 reference 一起使用。其他的语法已经被讨论过了，但是还没有其他的语法被证明是更好的。</p><h2 id="我如何将一个借来的东西返回到我从函数中创建的东西？"><a href="#我如何将一个借来的东西返回到我从函数中创建的东西？" class="headerlink" title="我如何将一个借来的东西返回到我从函数中创建的东西？"></a>我如何将一个借来的东西返回到我从函数中创建的东西？</h2><p>你需要确保借来的东西会超过函数的寿命。这可以通过将输出寿命与一些输入寿命绑定来实现，比如说。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Pool</span> = TypedArena&lt;Thing&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的生命周期只是为了说明问题而明确写的；它可以通过后面描述的删除规则省略。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_borrowed</span>&lt;<span class="symbol">&#x27;a</span>&gt;(pool: &amp;<span class="symbol">&#x27;a</span> Pool,</span><br><span class="line">                       x: <span class="type">i32</span>,</span><br><span class="line">                       y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> Thing &#123;</span><br><span class="line">    pool.<span class="title function_ invoke__">alloc</span>(Thing &#123; x: x, y: y &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是通过返回一个自有类型如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>来完全消除引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">happy_birthday</span>(name: &amp;<span class="type">str</span>, age: <span class="type">i64</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span> (<span class="string">&quot;Hello &#123;&#125;! You&#x27;re &#123;&#125; years old!&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法比较简单，但往往会导致不必要的分配。</p><h2 id="为什么有些引用有寿命，如-amp-39-a-T，而有些则没有，如-amp-T？"><a href="#为什么有些引用有寿命，如-amp-39-a-T，而有些则没有，如-amp-T？" class="headerlink" title="为什么有些引用有寿命，如&amp;&#39;a T，而有些则没有，如&amp;T？"></a>为什么有些引用有寿命，如<code>&amp;&#39;a T</code>，而有些则没有，如<code>&amp;T</code>？</h2><p>事实上, <em>所有</em>引用类型都有一个寿命, 但大多数时候你不必明确写出<br>它是明确的。规则如下。</p><ol><li><p>在一个函数体中，你永远不需要明确地写出生命周期；正确的值应该总是被推断出来的。</p></li><li><p>在一个函数的<em>签名</em>中（例如，在其参数的类型或其返回类型中），你<em>可能</em>会需要写一个生命周期。这里的生命周期使用一个简单的默认方案，称为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">“lifetime elision”</a>。它由以下三条规则组成：</p><ul><li>在一个函数的参数中，每一个被省略的生命周期都成为一个独立的生命周期参数。</li><li>如果正好只有一个输入生命周期，无论是否被省略，该生命周期都被分配给所有返回值中被省略的生命周期。</li><li>如果有多个输入生命周期，但其中一个是 &amp;self 或 &amp;mut self，那么 self 的生命周期将被分配给所有被忽略的返回生命周期。</li></ul></li><li><p>最后，在“结构”或“枚举”的定义中，所有的生命周期必须被明确地声明。</p></li></ol><p>如果这些规则导致了编译错误，Rust 编译器将提供一个错误信息，指出所造成的错误，并根据推理过程的哪一步造成的错误，提出一个潜在的解决方案。</p><h2 id="Rust如何保证“没有空指针”和“没有悬空指针”"><a href="#Rust如何保证“没有空指针”和“没有悬空指针”" class="headerlink" title="Rust如何保证“没有空指针”和“没有悬空指针”?"></a>Rust如何保证“没有空指针”和“没有悬空指针”?</h2><p>构造一个<code>&amp;Foo</code>或<code>&amp;mut Foo</code>类型的值的唯一方法是指定一个引用所指向的<code>Foo</code>类型的现有值。引用在给定的代码区域内（引用的生命周期）“借用”原始值，在借用期间，被借用的值不能被移动或销毁。</p><h2 id="我如何用“null”来表达一个值的缺失"><a href="#我如何用“null”来表达一个值的缺失" class="headerlink" title="我如何用“null”来表达一个值的缺失?"></a>我如何用“null”来表达一个值的缺失?</h2><p>你可以用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>类型来做，它可以是<code>Some(T)</code>或<code>None</code>。<code>Some(T)</code>表示其中包含一个<code>T</code>类型的值，而<code>None</code>表示没有值。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是“单态化”"><a href="#什么是“单态化”" class="headerlink" title="什么是“单态化”?"></a>什么是“单态化”?</h2><p>单态化是将泛型函数（或结构）的每一次使用都基于调用该函数（或使用该结构）的参数类型用特定的实例进行单态化。</p><p>在单态化过程中，泛型函数的一个新副本被翻译为该函数实例化的每一组独特类型。这与 C++ 使用的策略相同。它的结果是为每个调用点专门设计的快速代码，并且是静态调度的，其代价是用许多不同类型实例化的函数会导致“代码膨胀”，即多个函数实例会导致比用其他翻译策略创建的二进制文件更大。</p><p>接受 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">Trait Object</a> 而不是类型参数的函数不进行单态化。相反，特质对象上的方法在运行时被动态地分配。</p><h2 id="一个函数和一个没有捕获任何变量的闭包之间有什么区别？"><a href="#一个函数和一个没有捕获任何变量的闭包之间有什么区别？" class="headerlink" title="一个函数和一个没有捕获任何变量的闭包之间有什么区别？"></a>一个函数和一个没有捕获任何变量的闭包之间有什么区别？</h2><p>函数和闭包在操作上是等价的，但由于它们的实现方式不同，所以有不同的运行时表示。</p><p>函数是语言的内置基元，而闭包本质上是三种特征之一的语法糖。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>。当你创建一个闭包时，Rust 编译器会自动创建一个结构，实现这三个结构的相应特性，并将捕获的环境变量作为成员，并使该结构可以作为一个函数被调用。裸露的函数不能捕获环境。</p><p>这些特征之间的最大区别是它们如何接受“self”参数。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>使用<code>&amp;self</code>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>使用<code>&amp;mut self</code>，而<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>使用<code>self</code>。</p><p>即使一个闭包没有捕获任何环境变量，它在运行时也被表示为两个指针，与其他闭包相同。</p><h2 id="什么是高阶类型，为什么我需要它们，以及为什么-Rust-没有它们？"><a href="#什么是高阶类型，为什么我需要它们，以及为什么-Rust-没有它们？" class="headerlink" title="什么是高阶类型，为什么我需要它们，以及为什么 Rust 没有它们？"></a>什么是高阶类型，为什么我需要它们，以及为什么 Rust 没有它们？</h2><p>高等类型是指具有未填充参数的类型。类型构造器，如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>，和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>都是高类型类型的例子：每个类型都需要一些额外的类型参数，以便实际表示一个特定的类型，如<code>Vec&lt;u32&gt;</code>。对高类型的支持意味着这些“不完整”的类型可以在任何可以使用“完整”类型的地方使用，包括作为函数的泛型。</p><p>任何完整的类型，像<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.bool.html"><code>bool</code></a>或<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>都属于<code>*</code>类型（这个符号来自类型理论领域）。一个有一个参数的类型，像<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>是属于<code>* -&gt; *</code>，意思是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>接收一个完整的类型，像<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>，并返回一个完整类型<code>Vec&lt;i32&gt;</code>。一个有三个参数的类型，如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap&lt;K, V, S&gt;</code></a>是一种<code>* -&gt; * -&gt; * -&gt; *</code>，并接收三个完整的类型（如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>，和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html"><code>RandomState</code></a>），产生一个新的完整类型<code>HashMap&lt;i32, String, RandomState&gt;</code>。</p><p>除了这些例子之外，类型构造函数还可以接受<em>生命周期</em>参数，我们将其表示为<code>Lt</code>。例如，<code>slice::Iter</code>的种类是<code>Lt -&gt; * -&gt; *</code>，因为它必须像<code>Iter&lt;&#39;a, u32&gt;</code>一样被实例化。</p><p>由于缺乏对高阶类型的支持，因此很难编写某些类型的通用代码。对于像迭代器这样的概念的抽象来说，这尤其成问题，因为迭代器通常至少要在一个生命周期内进行参数化。这反过来又阻碍了对 Rust 的集合进行抽象的 traits 的创建。</p><p>另一个常见的例子是像 functors 或 monads 这样的概念，它们都是类型构造函数，而不是单一类型。</p><p>Rust 目前并不支持高类型的类型，因为与我们想做的其他改进相比，这并不是一个优先事项。由于该设计是一个重大的、跨领域的变化，我们也想谨慎地对待它。但是目前缺乏支持并没有什么内在的原因。</p><h2 id="通用类型中像-lt-T-Foo-gt-这样的命名类型参数是什么意思"><a href="#通用类型中像-lt-T-Foo-gt-这样的命名类型参数是什么意思" class="headerlink" title="通用类型中像&lt;T=Foo&gt;这样的命名类型参数是什么意思?"></a>通用类型中像<code>&lt;T=Foo&gt;</code>这样的命名类型参数是什么意思?</h2><p>这些被称为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types">关联类型</a>，它们允许表达不能用<code>where</code>子句表达的特征边界。例如，一个泛型约束<code>X: Bar&lt;T=Foo&gt;</code>意味着”<code>X</code>必须实现 trait <code>Bar</code>，在<code>Bar</code>的实现中，<code>X</code>必须选择<code>Foo</code>作为<code>Bar</code>的关联类型<code>T</code>“。这种约束不能通过<code>where</code>子句来表达的例子包括像<code>Box&lt;Bar&lt;T=Foo&gt;&gt;</code>这样的 trait object。</p><p>关联类型的存在是因为泛型经常涉及类型家族，其中一个类型决定了一个家族中的所有其他类型。例如，一个图的 trait 可能将图本身作为其<code>Self</code>类型，并有节点和边的关联类型。每个图的类型唯一地决定了相关的类型。使用关联类型使这些类型族的工作更加简洁，并且在许多情况下提供更好的类型推理。</p><h2 id="我可以重载运算符吗-哪些操作符，如何操作？"><a href="#我可以重载运算符吗-哪些操作符，如何操作？" class="headerlink" title="我可以重载运算符吗? 哪些操作符，如何操作？"></a>我可以重载运算符吗? 哪些操作符，如何操作？</h2><p>你可以使用它们的关联特性为各种运算符提供自定义的实现。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a>代表<code>+</code>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a>代表<code>*</code>，等等。它看起来像这样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add。</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Foo;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Foo) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Adding!&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下操作符可以被重载。</p><table><thead><tr><th align="left">Operation</th><th align="left">Trait</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td></tr><tr><td align="left"><code>+=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html"><code>AddAssign</code></a></td></tr><tr><td align="left"><code>binary -</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td></tr><tr><td align="left"><code>-=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html"><code>SubAssign</code></a></td></tr><tr><td align="left"><code>*</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td></tr><tr><td align="left"><code>*=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html"><code>MulAssign</code></a></td></tr><tr><td align="left"><code>/</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td></tr><tr><td align="left"><code>/=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html"><code>DivAssign</code></a></td></tr><tr><td align="left"><code>unary -</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Neg.html"><code>Neg</code></a></td></tr><tr><td align="left"><code>%</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td></tr><tr><td align="left"><code>%=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html"><code>RemAssign</code></a></td></tr><tr><td align="left"><code>&amp;</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html"><code>BitAnd</code></a></td></tr><tr><td align="left"><code>&amp;=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html"><code>BitAndAssign</code></a></td></tr><tr><td align="left"><code>&#124;</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.BitOr.html"><code>BitOr</code></a></td></tr><tr><td align="left"><code>&#124;=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html"><code>BitOrAssign</code></a></td></tr><tr><td align="left"><code>^</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.BitXor.html"><code>BitXor</code></a></td></tr><tr><td align="left"><code>^=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html"><code>BitXorAssign</code></a></td></tr><tr><td align="left"><code>!</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Not.html"><code>Not</code></a></td></tr><tr><td align="left"><code>&lt;&lt;</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Shl.html"><code>Shl</code></a></td></tr><tr><td align="left"><code>&lt;&lt;=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html"><code>ShlAssign</code></a></td></tr><tr><td align="left"><code>&gt;&gt;</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Shr.html"><code>Shr</code></a></td></tr><tr><td align="left"><code>&gt;&gt;=</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html"><code>ShrAssign</code></a></td></tr><tr><td align="left"><code>*</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a></td></tr><tr><td align="left"><code>mut *</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a></td></tr><tr><td align="left"><code>[]</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a></td></tr><tr><td align="left"><code>mut []</code></td><td align="left"><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a></td></tr></tbody></table><h2 id="为什么要在Eq-x2F-PartialEq和Ord-x2F-PartialOrd之间划分？"><a href="#为什么要在Eq-x2F-PartialEq和Ord-x2F-PartialOrd之间划分？" class="headerlink" title="为什么要在Eq&#x2F;PartialEq和Ord&#x2F;PartialOrd之间划分？"></a>为什么要在<code>Eq</code>&#x2F;<code>PartialEq</code>和<code>Ord</code>&#x2F;<code>PartialOrd</code>之间划分？</h2><p>在 Rust 中，有一些类型的值只有部分排序，或者只有部分相等。部分排序的意思是，在给定的类型中可能存在既不小于也不大于对方的值。部分平等意味着可能有给定类型的值不等于自己。</p><p>浮点类型（<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>）是每种类型的很好的例子。任何浮点类型都可以有<code>NaN</code>（意思是“不是一个数字”）的值。<code>NaN</code>不等于自己（<code>NaN == NaN</code>是 false），也不小于或大于任何其他浮点值。因此，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>和[<code>f64</code>]都实现了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>，但没有实现<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>和&#96;&#96;Eq&#96;]<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a>。</p><p>正如在<a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E8%83%BD%E6%AF%94%E8%BE%83%E6%B5%AE%E7%82%B9%E6%95%B0%E6%88%96%E7%94%A8%E5%AE%83%E4%BB%AC%E4%BD%9C%E4%B8%BAHashMap%E6%88%96BTreeMap%E7%9A%84%E9%94%AE">先前关于 floats 的问题</a>中解释的那样，这些区别很重要，因为有些集合依赖于总排序&#x2F;equality，以便给出正确的结果。</p><h1 id="输入-x2F-输出"><a href="#输入-x2F-输出" class="headerlink" title="输入&#x2F;输出"></a>输入&#x2F;输出</h1><h2 id="如何将一个文件读成一个“字符串”"><a href="#如何将一个文件读成一个“字符串”" class="headerlink" title="如何将一个文件读成一个“字符串”?"></a>如何将一个文件读成一个“字符串”?</h2><p>使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string()</code></a>方法, 这个方法是在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/index.html"><code>std::io</code></a>中的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a>特性上定义。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file</span>(path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = File::<span class="title function_ invoke__">open</span>(path)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s);  <span class="comment">// `s` contains the contents of &quot;foo.txt&quot;</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">read_file</span>(<span class="string">&quot;foo.txt&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got file contents!&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Getting file contents failed with error: &#123;&#125;&quot;</span>, err)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何有效地读取文件输入"><a href="#如何有效地读取文件输入" class="headerlink" title="如何有效地读取文件输入?"></a>如何有效地读取文件输入?</h2><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a>类型实现了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a>特性，它有多种函数用于读写数据，包括<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read"><code>read()</code></a>, <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_end"><code>read_to_end()</code></a>, <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#method.bytes"><code>bytes()</code></a>, <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#method.chars"><code>chars()</code></a>, 和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#method.take"><code>take()</code></a> 。这些函数中的每一个都从一个给定的文件中读取一定量的输入。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read"><code>read()</code></a> 在一次调用中读取底层系统所能提供的输入量。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_end"><code>read_to_end()</code></a> 将整个缓冲区读入一个向量，需要多少空间就分配多少。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#method.bytes"><code>bytes()</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#method.chars"><code>chars()</code></a>分别允许你对文件的字节和字符进行迭代。最后，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/trait.Read.html#method.take"><code>take()</code></a>允许你从文件中读取任意数量的字节。总的来说，这些应该允许你有效地读入任何你需要的数据。</p><p>对于缓冲读取，使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a>结构，这有助于减少读取时的系统调用数量。</p><h2 id="我如何在-Rust-中进行异步输入-x2F-输出？"><a href="#我如何在-Rust-中进行异步输入-x2F-输出？" class="headerlink" title="我如何在 Rust 中进行异步输入&#x2F;输出？"></a>我如何在 Rust 中进行异步输入&#x2F;输出？</h2><p>使用 <a target="_blank" rel="noopener" href="https://github.com/tokio-rs/tokio">tokio</a>。</p><h2 id="我如何在-Rust-中获得命令行参数"><a href="#我如何在-Rust-中获得命令行参数" class="headerlink" title="我如何在 Rust 中获得命令行参数?"></a>我如何在 Rust 中获得命令行参数?</h2><p>最简单的方法是使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/env/struct.Args.html"><code>Args</code></a>，它提供了一个输入参数的迭代器。</p><p>如果你正在寻找更强大的库，在 crates.io 上有<a target="_blank" rel="noopener" href="https://crates.io/keywords/argument">一些选项</a>。</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="为什么-Rust-没有异常？"><a href="#为什么-Rust-没有异常？" class="headerlink" title="为什么 Rust 没有异常？"></a>为什么 Rust 没有异常？</h2><p>异常使控制流的理解复杂化，它们在类型系统之外表达有效性&#x2F;无效性，而且它们与多线程代码（Rust 的主要焦点）的互操作性很差。</p><p>Rust 更倾向于采用基于类型的错误处理方法，这在书中有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">详细介绍</a>。这与 Rust 的控制流、并发性和其他一切都更加吻合。</p><h2 id="到处都有-96-unwrap-’是怎么回事"><a href="#到处都有-96-unwrap-’是怎么回事" class="headerlink" title="到处都有&#96;unwrap()’是怎么回事?"></a>到处都有&#96;unwrap()’是怎么回事?</h2><p><code>unwrap()</code>是一个提取<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>或<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>里面的值的函数，如果没有值就会 panic。</p><p><code>unwrap()</code>不应该是你处理预期出现的错误的默认方式，例如用户输入不正确。在生产代码中，它应该被视为一个断言，即该值是非空的，如果违反，将使程序崩溃。</p><p>它对快速原型也很有用，在那里你还不想处理错误，或者在博客文章中，错误处理会分散对重点的注意力。</p><h2 id="当我试图运行使用try-宏的示例代码时，为什么我得到一个错误"><a href="#当我试图运行使用try-宏的示例代码时，为什么我得到一个错误" class="headerlink" title="当我试图运行使用try!宏的示例代码时，为什么我得到一个错误?"></a>当我试图运行使用<code>try!</code>宏的示例代码时，为什么我得到一个错误?</h2><p>这可能是函数的返回类型的问题。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.try!.html"><code>try!</code></a>宏要么从<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>中提取数值，要么提前返回，错误是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>携带的。这意味着<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.try!.html"><code>try</code></a>只对返回<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>本身的函数有效，其中<code>Err</code>构造的类型实现了<code>From::from(err)</code>。特别是，这意味着<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.try!.html"><code>try!</code></a>宏不能在<code>main</code>函数中工作。</p><h2 id="有没有比到处都是“Result”更简单的方法来做错误处理？"><a href="#有没有比到处都是“Result”更简单的方法来做错误处理？" class="headerlink" title="有没有比到处都是“Result”更简单的方法来做错误处理？"></a>有没有比到处都是“Result”更简单的方法来做错误处理？</h2><p>如果你正在寻找一种方法来避免在其他人的代码中处理<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>，总是有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap"><code>unwrap()</code></a>，但这可能不是你想要的。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>是一个指标，表明某些计算可能会或可能不会成功完成。要求你明确地处理这些失败是 Rust 鼓励健壮性的方式之一。Rust 提供了像<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.try!.html"><code>try!</code>宏</a>这样的工具，使处理失败的过程符合人体工程学。</p><p>如果你真的不想处理错误，可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap"><code>unwrap()</code></a>，但要知道，这样做意味着代码在失败时 panic，这通常会导致关闭进程。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="我可以在没有“不安全”块的情况下跨线程使用静态值吗？"><a href="#我可以在没有“不安全”块的情况下跨线程使用静态值吗？" class="headerlink" title="我可以在没有“不安全”块的情况下跨线程使用静态值吗？"></a>我可以在没有“不安全”块的情况下跨线程使用静态值吗？</h2><p>如果是同步的，修改是安全的。修改一个静态的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>（通过<a target="_blank" rel="noopener" href="https://crates.io/crates/lazy_static/">lazy-static</a> crate 懒惰地初始化）不需要一个<code>unsafe</code>块，修改一个静态的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html"><code>AtomicUsize</code></a>（可以不用 lazy_static 初始化）也是如此。</p><p>更一般地说，如果一个类型实现了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>，并且没有实现<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>，它<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable">可以在<code>static</code>中使用</a>。</p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><h2 id="我可以写一个宏来生成标识符吗"><a href="#我可以写一个宏来生成标识符吗" class="headerlink" title="我可以写一个宏来生成标识符吗?"></a>我可以写一个宏来生成标识符吗?</h2><p>目前不能。Rust 的宏是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hygienic_macro">“卫生宏”</a>，它有意避免捕捉或创建可能与其他标识符发生意外碰撞的标识符。它们的功能与通常与 C 预处理器相关的宏的风格明显不同。宏调用只能出现在被明确支持的地方：项目、方法声明、语句、表达式和模式。这里，“方法声明”指的是可以放置方法的空白处。它们不能被用来完成部分方法声明。按照同样的逻辑，它们也不能用来完成一个部分变量声明。</p><h1 id="Debugging-and-Tooling"><a href="#Debugging-and-Tooling" class="headerlink" title="Debugging and Tooling"></a>Debugging and Tooling</h1><h2 id="我如何调试-Rust-程序？"><a href="#我如何调试-Rust-程序？" class="headerlink" title="我如何调试 Rust 程序？"></a>我如何调试 Rust 程序？</h2><p>Rust 程序可以使用 <a target="_blank" rel="noopener" href="https://sourceware.org/gdb/current/onlinedocs/gdb/">gdb</a> 或 <a target="_blank" rel="noopener" href="http://lldb.llvm.org/tutorial.html">lldb</a> 进行调试，与 C 和 C++ 相同。事实上，每一个 Rust 的安装都带有 rust-gdb 和 rust-lldb 中的一个或两个（取决于平台支持）。这些是对 gdb 和 lldb 的封装，并启用了 Rust pretty-printing。</p><h2 id="rustc说标准库代码中发生了-panic。我如何定位我的代码中的错误？"><a href="#rustc说标准库代码中发生了-panic。我如何定位我的代码中的错误？" class="headerlink" title="rustc说标准库代码中发生了 panic。我如何定位我的代码中的错误？"></a><code>rustc</code>说标准库代码中发生了 panic。我如何定位我的代码中的错误？</h2><p>这个错误通常是由客户端代码中<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap"><code>unwrap()</code>ing</a>一个<code>None</code>或<code>Err</code>引起的。通过设置环境变量<code>RUST_BACKTRACE=1</code>来启用回溯，有助于获得更多信息。在调试模式下编译（默认为“cargo build”）也有帮助。使用调试器，如提供的<code>rust-gdb</code>或<code>rust-lldb</code>也很有帮助。</p><h2 id="我应该使用什么-IDE？"><a href="#我应该使用什么-IDE？" class="headerlink" title="我应该使用什么 IDE？"></a>我应该使用什么 IDE？</h2><p>Rust 的开发环境有很多选择，所有这些都在非官方的 <a target="_blank" rel="noopener" href="https://areweideyet.com/">IDE 支持页面</a>上有详细说明。</p><h1 id="Low-Level"><a href="#Low-Level" class="headerlink" title="Low-Level"></a>Low-Level</h1><h2 id="我怎样才能memcpy字节"><a href="#我怎样才能memcpy字节" class="headerlink" title="我怎样才能memcpy字节?"></a>我怎样才能<code>memcpy</code>字节?</h2><p>如果你想安全地克隆一个现有的分片，你可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.slice.html#method.clone_from_slice"><code>clone_from_slice</code></a>。</p><p>要复制可能重叠的字节，使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>copy</code></a>。要复制不重叠的字节，使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ptr/fn.copy_nonoverlapping.html"><code>copy_nonoverlapping</code></a>。这两个函数都是“不安全”的，因为它们都可以被用来破坏语言的安全保证。在使用它们时要注意。</p><h2 id="没有标准库，Rust-能合理地运行吗？"><a href="#没有标准库，Rust-能合理地运行吗？" class="headerlink" title="没有标准库，Rust 能合理地运行吗？"></a>没有标准库，Rust 能合理地运行吗？</h2><p>当然可以。Rust 程序可以使用<code>#![no_std]</code>属性设置为不加载标准库。设置了这个属性后，你可以继续使用 Rust 核心库，它只是平台无关的原语。因此，它不包括 IO、并发性、堆分配等。</p><h2 id="我可以用-Rust-写一个操作系统吗？"><a href="#我可以用-Rust-写一个操作系统吗？" class="headerlink" title="我可以用 Rust 写一个操作系统吗？"></a>我可以用 Rust 写一个操作系统吗？</h2><p>是的！事实上，有<a target="_blank" rel="noopener" href="http://wiki.osdev.org/Rust">几个正在进行的项目就是这样</a>。</p><h2 id="我如何在文件或其他字节流中以大数或小数格式读写数字类型如i32或f64"><a href="#我如何在文件或其他字节流中以大数或小数格式读写数字类型如i32或f64" class="headerlink" title="我如何在文件或其他字节流中以大数或小数格式读写数字类型如i32或f64?"></a>我如何在文件或其他字节流中以大数或小数格式读写数字类型如<code>i32</code>或<code>f64</code>?</h2><p>你应该看看 <a target="_blank" rel="noopener" href="https://docs.rs/byteorder">byteorder crate</a>，它提供了相应的实用程序。</p><h2 id="Rust-是否保证一个特定的数据布局？"><a href="#Rust-是否保证一个特定的数据布局？" class="headerlink" title="Rust 是否保证一个特定的数据布局？"></a>Rust 是否保证一个特定的数据布局？</h2><p>默认情况下不是。在一般情况下，<code>enum</code>和<code>struct</code>的布局是未定义的。这允许编译器进行潜在的优化，比如为判别式重新使用填充物，压缩嵌套的<code>enum</code>的变体，重新排序字段以移除填充物，等等。不携带数据的<code>enum</code>（“C-like”）有资格拥有一个定义的表示。这种<code>枚举</code>很容易区分，因为它们只是一个没有数据的名字列表。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">snum CLike &#123;</span><br><span class="line">    A,</span><br><span class="line">    B = <span class="number">32</span>,</span><br><span class="line">    C = <span class="number">34</span>,</span><br><span class="line">    D</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>＃[repr(C)]</code>属性可以应用于这些“enum”，使它们在同等的 C 代码中具有相同的表示。这允许在 FFI 代码中使用 Rust 的“enum”，而在大多数情况下也使用 C 的“enum”。该属性也可以应用于<code>struct</code>，以获得与<code>C struct</code>相同的布局。</p><h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><h2 id="在-Rust-中表达特定平台行为的习惯性方法是什么？"><a href="#在-Rust-中表达特定平台行为的习惯性方法是什么？" class="headerlink" title="在 Rust 中表达特定平台行为的习惯性方法是什么？"></a>在 Rust 中表达特定平台行为的习惯性方法是什么？</h2><p>平台特定行为可以用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">条件编译属性</a>来表达，如<code>target_os</code>, <code>target_family</code>, <code>target_endian</code>，等等。</p><h2 id="Rust-可以用于-Android-x2F-iOS-编程吗？"><a href="#Rust-可以用于-Android-x2F-iOS-编程吗？" class="headerlink" title="Rust 可以用于 Android&#x2F;iOS 编程吗？"></a>Rust 可以用于 Android&#x2F;iOS 编程吗？</h2><p>是的，它可以! 在 <a target="_blank" rel="noopener" href="https://github.com/tomaka/android-rs-glue">Android</a>和 <a target="_blank" rel="noopener" href="https://www.bignerdranch.com/blog/building-an-ios-app-in-rust-part-1/">iOS</a> 中都已经有使用 Rust 的例子。它确实需要一些工作来设置，但 Rust 在这两个平台上的功能都很好。</p><h2 id="我可以在网络浏览器中运行我的-Rust-程序吗？"><a href="#我可以在网络浏览器中运行我的-Rust-程序吗？" class="headerlink" title="我可以在网络浏览器中运行我的 Rust 程序吗？"></a>我可以在网络浏览器中运行我的 Rust 程序吗？</h2><p>有可能。Rust 对<a target="_blank" rel="noopener" href="http://asmjs.org/">asm.js</a>和<a target="_blank" rel="noopener" href="http://webassembly.org/">WebAssembly</a>都有<a target="_blank" rel="noopener" href="https://davidmcneil.gitbooks.io/the-rusty-web/">实验性支持</a>。</p><h2 id="我如何在-Rust-中进行交叉编译？"><a href="#我如何在-Rust-中进行交叉编译？" class="headerlink" title="我如何在 Rust 中进行交叉编译？"></a>我如何在 Rust 中进行交叉编译？</h2><p>在 Rust 中可以进行交叉编译，但需要<a target="_blank" rel="noopener" href="https://github.com/japaric/rust-cross/blob/master/README.md">一点工作</a>来设置。每个 Rust 编译器都是一个交叉编译器，但是库需要针对目标平台进行交叉编译。</p><p>Rust 确实为每个支持的平台分发了标准库的副本，这些副本包含在分发页面上找到的每个构建目录的<code>rust-std-*</code>文件中，但目前还没有自动安装的方法。</p><h1 id="mod-和-crate"><a href="#mod-和-crate" class="headerlink" title="mod 和 crate"></a>mod 和 crate</h1><h2 id="mod-和-crate-之间的关系是什么？"><a href="#mod-和-crate-之间的关系是什么？" class="headerlink" title="mod 和 crate 之间的关系是什么？"></a>mod 和 crate 之间的关系是什么？</h2><ul><li>crate 是一个编译单元，它是 Rust 编译器可以操作的最小的代码量。</li><li>mod 是 crate 内的一个（可能是嵌套的）代码组织单元。</li><li>一个 crate 包含一个隐含的、未命名的顶层 mod。</li><li>递归定义可以跨越 mod，但不能跨越 crate。</li></ul><h2 id="为什么-Rust-编译器找不到我正在使用的这个库"><a href="#为什么-Rust-编译器找不到我正在使用的这个库" class="headerlink" title="为什么 Rust 编译器找不到我正在使用的这个库?"></a>为什么 Rust 编译器找不到我正在<code>使用</code>的这个库?</h2><p>有很多可能的答案，但一个常见的错误是没有意识到<code>use</code>声明是相对于 crate root 的。试着改写你的声明，使用它们在你的项目根文件中定义的路径，看看是否能解决这个问题。</p><p>还有“self”和“super”，它们分别将“use”路径区分为相对于当前 mod 或父 mod。</p><p>关于<code>use</code>库的完整信息，请阅读 Rust 书中的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">“Packages, Crates, and Modules”</a>一章。</p><h2 id="为什么我必须在-crate-的顶层用mod声明-mod-文件，而不是直接use它们？"><a href="#为什么我必须在-crate-的顶层用mod声明-mod-文件，而不是直接use它们？" class="headerlink" title="为什么我必须在 crate 的顶层用mod声明 mod 文件，而不是直接use它们？"></a>为什么我必须在 crate 的顶层用<code>mod</code>声明 mod 文件，而不是直接<code>use</code>它们？</h2><p>在 Rust 中，有两种方法来声明模块，内联或在另一个文件中。下面是各自的一个例子。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main.rs</span></span><br><span class="line"><span class="keyword">mod</span> hello &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">f</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    hello::<span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main.rs</span></span><br><span class="line"><span class="keyword">mod</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    hello::<span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In hello.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">f</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一个例子中，模块被定义在它所使用的同一文件中。在第二个例子中，主文件中的模块声明告诉编译器寻找<code>hello.rs</code>或<code>hello/mod.rs</code>，并加载该文件。</p><p>注意<code>mod</code>和<code>use</code>之间的区别：<code>mod</code>声明一个模块的存在，而<code>use</code>引用一个在其他地方声明的模块，将其内容纳入当前模块的范围。</p><h2 id="我如何配置-Cargo-使用代理？"><a href="#我如何配置-Cargo-使用代理？" class="headerlink" title="我如何配置 Cargo 使用代理？"></a>我如何配置 Cargo 使用代理？</h2><p>参考 <a target="_blank" rel="noopener" href="https://rsproxy.cn/">https://rsproxy.cn/</a>。</p><h2 id="为什么我已经“use”了-crate，但编译器还是找不到方法的实现？"><a href="#为什么我已经“use”了-crate，但编译器还是找不到方法的实现？" class="headerlink" title="为什么我已经“use”了 crate，但编译器还是找不到方法的实现？"></a>为什么我已经“use”了 crate，但编译器还是找不到方法的实现？</h2><p>对于定义在 trait 上的方法，你必须明确导入 trait 声明。这意味着仅仅导入一个结构实现 trait 的模块是不够的，你还必须导入 trait 本身。</p><h2 id="为什么编译器不能为我推断出use声明？"><a href="#为什么编译器不能为我推断出use声明？" class="headerlink" title="为什么编译器不能为我推断出use声明？"></a>为什么编译器不能为我推断出<code>use</code>声明？</h2><p>它可能可以，但你也不希望它这样做。虽然在很多情况下，编译器有可能通过简单地寻找给定标识符的定义位置来确定导入的正确模块，但在一般情况下可能不是这样的。<code>rustc</code>中任何用于选择竞争性选项的决策规则，在某些情况下可能会引起惊讶和混乱，Rust 更倾向于明确说明名称的来源。</p><p>例如，编译器可以说，在标识符定义相互竞争的情况下，会选择最早导入的模块的定义。所以如果模块<code>foo</code>和模块<code>bar</code>都定义了标识符<code>baz</code>，但是<code>foo</code>是第一个注册的模块，编译器会插入<code>use foo::baz;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> foo;</span><br><span class="line"><span class="keyword">mod</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use foo::baz  // to be inserted by the compiler.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="title function_ invoke__">baz</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你知道这种情况会发生，也许它可以节省少量的按键，但它也大大增加了当你真正想把<code>baz()</code>变成<code>bar::baz()</code>时出现令人惊讶的错误信息的可能性，而且它通过使函数调用的意义依赖于模块声明而降低了代码的可读性。这些都是我们不愿意做的折衷。</p><p>然而，IDE 可以帮助管理声明，这将给你带来两方面的好处：机器协助拉入名字，但明确声明这些名字的来源。</p><h2 id="我如何进行动态-Rust-库加载？"><a href="#我如何进行动态-Rust-库加载？" class="headerlink" title="我如何进行动态 Rust 库加载？"></a>我如何进行动态 Rust 库加载？</h2><p>用 <a target="_blank" rel="noopener" href="https://crates.io/crates/libloading">libloading</a> 导入 Rust 中的动态库，它提供了一个跨平台的动态链接系统。</p><h2 id="为什么-crates-io-没有命名空间？"><a href="#为什么-crates-io-没有命名空间？" class="headerlink" title="为什么 crates.io 没有命名空间？"></a>为什么 crates.io 没有命名空间？</h2><p>引用 crates.io 设计的<a target="_blank" rel="noopener" href="https://internals.rust-lang.org/t/crates-io-package-policies/1041">官方解释</a>：</p><blockquote><p>在使用 crates.io 的第一个月里，很多人问我们是否有可能引入<a target="_blank" rel="noopener" href="https://github.com/rust-lang/crates.io/issues/58">命名空间</a>。</p><p>虽然 namespace 允许多个作者使用单一的、通用的名称，但它们增加了包在 Rust 代码中的引用和人类对包的交流的复杂性。乍一看，它们允许多个作者使用“http”这样的名字，但这仅仅意味着人们需要将这些包称为“wycats’http”或“reem’http”，与“wycats-http”或“reem-http”这样的包名相比没有什么好处。</p><p>当我们研究没有命名空间的软件包生态系统时，我们发现人们倾向于使用更有创意的名字（如<code>nokogiri</code>而不是<code>tenderlove&#39;s libxml2</code>）。这些有创意的名字往往简短易记，部分原因是缺乏任何层次结构。它们使人们更容易简洁明了地交流软件包。他们创造了令人兴奋的品牌。我们已经看到了一些 10,000+ 软件包生态系统的成功，如 NPM 和 RubyGems，它们的社区在一个单一的命名空间内蓬勃发展。</p><p>简而言之，我们认为如果 Piston 选择<code>bvssvni/game-engine</code>这样的名字（允许其他用户选择<code>wycats/game-engine</code>）而不是简单的<code>piston</code>，那么 Cargo 的生态系统就不会好转。</p><p>因为命名空间在很多方面严格来说都比较复杂，而且如果将来有必要的话，还可以兼容添加，所以我们要坚持使用单一的共享命名空间。</p></blockquote><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><h2 id="我怎样才能发出-HTTP-请求"><a href="#我怎样才能发出-HTTP-请求" class="headerlink" title="我怎样才能发出 HTTP 请求?"></a>我怎样才能发出 HTTP 请求?</h2><p>标准库不包括 HTTP 的实现，所以你要使用一个外部的 crate。<br><a target="_blank" rel="noopener" href="http://docs.rs/reqwest">reqwest</a> 是最简单的。它建立在<a target="_blank" rel="noopener" href="https://github.com/hyperium/hyper">hyper</a>上，用 Rust 编写，但也有<a target="_blank" rel="noopener" href="https://crates.io/keywords/http">一些其他的</a>。<a target="_blank" rel="noopener" href="https://docs.rs/curl">curl</a> crate 被广泛使用，它提供了与 curl 库的绑定。</p><h2 id="我如何用-Rust-编写-GUI-应用程序？"><a href="#我如何用-Rust-编写-GUI-应用程序？" class="headerlink" title="我如何用 Rust 编写 GUI 应用程序？"></a>我如何用 Rust 编写 GUI 应用程序？</h2><p>有多种方法可以在 Rust 中编写 GUI 应用程序。只要看看<a target="_blank" rel="noopener" href="https://github.com/kud1ing/awesome-rust#gui">这个 GUI 框架的列表</a>。</p><h2 id="我怎样才能解析-JSON-x2F-XML"><a href="#我怎样才能解析-JSON-x2F-XML" class="headerlink" title="我怎样才能解析 JSON&#x2F;XML?"></a>我怎样才能解析 JSON&#x2F;XML?</h2><p><a target="_blank" rel="noopener" href="https://serde.rs/">Serde</a>是推荐的 Rust 数据序列化和反序列化的库，可以从许多不同的格式中获取。</p><h2 id="是否有一个标准的-2D-矢量和形状-crate"><a href="#是否有一个标准的-2D-矢量和形状-crate" class="headerlink" title="是否有一个标准的 2D+ 矢量和形状 crate?"></a>是否有一个标准的 2D+ 矢量和形状 crate?</h2><p>还没有! 想写一个吗？</p><h2 id="我如何在-Rust-中编写一个-OpenGL-应用程序"><a href="#我如何在-Rust-中编写一个-OpenGL-应用程序" class="headerlink" title="我如何在 Rust 中编写一个 OpenGL 应用程序?"></a>我如何在 Rust 中编写一个 OpenGL 应用程序?</h2><p><a target="_blank" rel="noopener" href="https://github.com/tomaka/glium">Glium</a> 是 Rust 中 OpenGL 编程的主要库。<a target="_blank" rel="noopener" href="https://github.com/bjz/glfw-rs">GLFW</a> 也是一个可靠的选择。</p><h2 id="我可以用-Rust-写一个视频游戏吗？"><a href="#我可以用-Rust-写一个视频游戏吗？" class="headerlink" title="我可以用 Rust 写一个视频游戏吗？"></a>我可以用 Rust 写一个视频游戏吗？</h2><p>是的，你可以。Rust 的主要游戏编程库是<a target="_blank" rel="noopener" href="http://www.piston.rs/">Piston</a>，而且还有一个 <a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust_gamedev/">Rust 游戏编程的 subreddit</a> 和一个 IRC 频道（<code>#rust-gamedev</code> on <a target="_blank" rel="noopener" href="https://wiki.mozilla.org/IRC">Mozilla IRC</a>）。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Rust是面向对象的吗？"><a href="#Rust是面向对象的吗？" class="headerlink" title="Rust是面向对象的吗？"></a>Rust是面向对象的吗？</h2><p>它是多范式的。很多在 OO 语言中可以做的事情在 Rust 中也可以做，但不是所有的事情，也不总是使用你所习惯的那种抽象方式。</p><h2 id="我如何将面向对象的概念映射到-Rust-中？"><a href="#我如何将面向对象的概念映射到-Rust-中？" class="headerlink" title="我如何将面向对象的概念映射到 Rust 中？"></a>我如何将面向对象的概念映射到 Rust 中？</h2><p>这取决于。有一些方法可以将面向对象的概念，如<a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust/comments/2sryuw/ideaquestion_about_multiple_inheritence/">多重继承</a>翻译成 Rust，但由于 Rust 不是面向对象的，所以翻译的结果可能与它在 OO 语言中的外观有很大不同。</p><h2 id="我如何处理带有可选参数的结构的配置？"><a href="#我如何处理带有可选参数的结构的配置？" class="headerlink" title="我如何处理带有可选参数的结构的配置？"></a>我如何处理带有可选参数的结构的配置？</h2><p>最简单的方法是在你用来构建结构实例的任何函数中使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>类型（通常是<code>new()</code>）。另一种方法是使用构建器模式，在构建所构建的类型之前，只必须调用某些实例化成员变量的函数。</p><h2 id="我如何在-Rust-中做全局变量"><a href="#我如何在-Rust-中做全局变量" class="headerlink" title="我如何在 Rust 中做全局变量?"></a>我如何在 Rust 中做全局变量?</h2><p>Rust 中的全局变量可以使用<code>const</code>声明来实现编译时计算的全局常量，而<code>static</code>可以用来实现可变的全局变量。请注意，修改<code>static mut</code>变量需要使用<code>unsafe</code>，因为它允许数据竞争，而在安全的 Rust 中保证不会发生这种情况。<code>const</code>和<code>static</code>值之间的一个重要区别是，你可以对<code>static</code>值进行引用，但不能对<code>const</code>值进行引用，后者没有指定的内存位置。关于<code>const</code>与<code>static</code>的更多信息，请阅读 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable">Rust 书</a>。</p><h2 id="我如何设置程序化定义的编译时常量？"><a href="#我如何设置程序化定义的编译时常量？" class="headerlink" title="我如何设置程序化定义的编译时常量？"></a>我如何设置程序化定义的编译时常量？</h2><p>Rust 目前对编译时常量的支持有限。你可以使用“const”声明来定义基元（类似于“static”，但是是不可变的，在内存中没有指定的位置），也可以定义“const”函数和固有方法。</p><p>要定义不能通过这些机制定义的程序性常量，可以使用<a target="_blank" rel="noopener" href="https://crates.io/crates/lazy_static"><code>lazy-static</code></a> crate，它通过在第一次使用时自动计算常量来模拟编译时计算。</p><h2 id="我可以运行发生在-main-之前的初始化代码吗？"><a href="#我可以运行发生在-main-之前的初始化代码吗？" class="headerlink" title="我可以运行发生在 main 之前的初始化代码吗？"></a>我可以运行发生在 main 之前的初始化代码吗？</h2><p>Rust 没有“在<code>main</code>之前的生命”的概念。最接近的是通过<a target="_blank" rel="noopener" href="https://crates.io/crates/lazy_static"><code>lazy-static</code></a> crate 来完成，它通过在静态变量第一次使用时懒散地初始化静态变量来模拟“main之前”。</p><h2 id="Rust-允许-globals-使用非结构表达式的值吗？"><a href="#Rust-允许-globals-使用非结构表达式的值吗？" class="headerlink" title="Rust 允许 globals 使用非结构表达式的值吗？"></a>Rust 允许 globals 使用非结构表达式的值吗？</h2><p>不允许。全局变量不能有一个非结构表达式的构造函数，也不能有一个析构函数。静态构造函数是不可取的，因为确保静态初始化顺序的可移植性是很困难的。main 之前的生命通常被认为是一个错误的功能，所以 Rust 不允许它。</p><p>参见 <a target="_blank" rel="noopener" href="http://yosefk.com/c++fqa/ctors.html#fqa-10.12">C++ FQA</a> 中关于“静态初始化顺序惨败”的内容，以及 <a target="_blank" rel="noopener" href="https://ericlippert.com/2013/02/06/static-constructors-part-one/">Eric Lippert 的博客</a>中关于 C# 的挑战，它也有这种特性。</p><p>你可以用 <a target="_blank" rel="noopener" href="https://crates.io/crates/lazy_static/">lazy-static</a> 工具箱来近似非内容表达式的 globals。</p><h1 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h1><h2 id="我怎样才能在-Rust-中实现类似-C-语言的struct-X-static-int-X-的东西呢？"><a href="#我怎样才能在-Rust-中实现类似-C-语言的struct-X-static-int-X-的东西呢？" class="headerlink" title="我怎样才能在 Rust 中实现类似 C 语言的struct X { static int X; };的东西呢？"></a>我怎样才能在 Rust 中实现类似 C 语言的<code>struct X &#123; static int X; &#125;;</code>的东西呢？</h2><p>Rust 没有上面代码片断中所示的<code>静态</code>字段。相反，你可以在一个给定的模块中声明一个<code>静态</code>变量，这个变量对该模块是私有的。</p><h2 id="我如何将-C-风格的枚举转换为整数，反之亦然？"><a href="#我如何将-C-风格的枚举转换为整数，反之亦然？" class="headerlink" title="我如何将 C 风格的枚举转换为整数，反之亦然？"></a>我如何将 C 风格的枚举转换为整数，反之亦然？</h2><p>将 C 风格的枚举转换为整数可以用<code>as</code>表达式来完成，比如<code>e as i64</code>(其中<code>e</code>是某个枚举)。</p><p>另一个方向的转换可以用<code>match</code>语句来完成, 它将不同的数字值映射到枚举的不同潜在值上.</p><h2 id="为什么-Rust-程序的二进制大小比-C-程序大"><a href="#为什么-Rust-程序的二进制大小比-C-程序大" class="headerlink" title="为什么 Rust 程序的二进制大小比 C 程序大?"></a>为什么 Rust 程序的二进制大小比 C 程序大?</h2><p>有几个因素导致 Rust 程序默认比功能相当的 C 程序有较大的二进制大小。一般来说，Rust 更倾向于对现实世界的程序性能进行优化，而不是对小程序的大小进行优化。</p><h3 id="单态化"><a href="#单态化" class="headerlink" title="单态化"></a>单态化</h3><p>Rust 对泛型进行了单态化处理，这意味着在程序中每使用一个具体类型，就会生成一个新的泛型函数或类型。这类似于 C++ 中模板的工作方式。例如，在下面的程序中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>&lt;T&gt;(t: T) &#123;</span><br><span class="line">    <span class="comment">// ... do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(<span class="number">10</span>);       <span class="comment">// i32</span></span><br><span class="line">    <span class="title function_ invoke__">foo</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// &amp;str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个不同版本的<code>foo</code>将出现在最终的二进制文件中，一个专门用于<code>i32</code>输入，一个专门用于<code>&amp;str</code>输入。这使得通用函数的静态调度更加有效，但代价是一个更大的二进制文件。</p><h3 id="调试符号"><a href="#调试符号" class="headerlink" title="调试符号"></a>调试符号</h3><p>Rust 程序在编译时保留了一些调试符号，即使是在 release 模式下编译。这些符号用于提供 panic 时的 backtrace，可以用<code>strip</code>或其他调试符号移除工具移除。值得注意的是，用 Cargo 在 release 模式下编译，相当于用 rustc 设置优化级别 3。另一个优化级别（称为<code>s</code>或<code>z</code>）<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/pull/32386">已被添加</a>，它告诉编译器为大小而不是性能进行优化。</p><h3 id="链接时优化"><a href="#链接时优化" class="headerlink" title="链接时优化"></a>链接时优化</h3><p>Rust 默认不做链接时优化，但可以被指示这样做。这增加了 Rust 编译器可能做的优化量，并对二进制的大小有小的影响。与之前提到的尺寸优化模式相结合，这种影响可能更大。</p><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>Rust 标准库包括 libbacktrace 和 libunwind，这在某些程序中可能是不可取的。因此，使用<code>#![no_std]</code>可以带来更小的二进制文件，但通常也会对你正在编写的那种 Rust 代码造成实质性的改变。请注意，在没有标准库的情况下使用 Rust，通常在功能上更接近于同等的 C 代码。</p><p>举个例子，下面的 C 程序读入一个名字，并对有这个名字的人说“你好”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name?\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> input[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s!\n&quot;</span>, input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Rust重写这个，你可能会得到如下的东西。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;&#125;!&quot;</span>, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序在编译后与 C 程序相比，会有更大的二进制，使用更多的内存。但是这个程序并不完全等同于上面的 C 代码。等价的 Rust 代码反而会是这样的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(lang_items)]</span></span><br><span class="line"><span class="meta">#![feature(libc)]</span></span><br><span class="line"><span class="meta">#![feature(no_std)]</span></span><br><span class="line"><span class="meta">#![feature(start)]</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> libc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">printf</span>(fmt: *<span class="keyword">const</span> <span class="type">u8</span>, ...) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">scanf</span>(fmt: *<span class="keyword">const</span> <span class="type">u8</span>, ...) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[start]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">start</span>(_argc: <span class="type">isize</span>, _argv: *<span class="keyword">const</span> *<span class="keyword">const</span> <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">printf</span>(<span class="string">b&quot;What&#x27;s your name?\n\0&quot;</span>.<span class="title function_ invoke__">as_ptr</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = [<span class="number">0u8</span>; <span class="number">100</span>];</span><br><span class="line">        <span class="title function_ invoke__">scanf</span>(<span class="string">b&quot;%s\0&quot;</span>.<span class="title function_ invoke__">as_ptr</span>(), &amp;<span class="keyword">mut</span> input);</span><br><span class="line">        <span class="title function_ invoke__">printf</span>(<span class="string">b&quot;Hello %s!\n\0&quot;</span>.<span class="title function_ invoke__">as_ptr</span>(), &amp;input);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[lang=<span class="string">&quot;eh_personality&quot;</span>]</span> <span class="keyword">extern</span> <span class="keyword">fn</span> <span class="title function_">eh_personality</span>() &#123;&#125;</span><br><span class="line"><span class="meta">#[lang=<span class="string">&quot;panic_fmt&quot;</span>]</span> <span class="keyword">fn</span> <span class="title function_">panic_fmt</span>() <span class="punctuation">-&gt;</span> ! &#123; <span class="keyword">loop</span> &#123;&#125; &#125;</span><br><span class="line"><span class="meta">#[lang=<span class="string">&quot;stack_exhausted&quot;</span>]</span> <span class="keyword">extern</span> <span class="keyword">fn</span> <span class="title function_">stack_exhausted</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这确实应该在内存使用方面与 C 语言大致相同，但代价是更多的程序员复杂性，以及缺乏通常由 Rust 提供的静态保证（在这里通过使用<code>unsafe</code>来避免）。</p><h2 id="为什么-Rust-不像-C-那样有一个稳定的-ABI，为什么我必须用-extern-来注解东西？"><a href="#为什么-Rust-不像-C-那样有一个稳定的-ABI，为什么我必须用-extern-来注解东西？" class="headerlink" title="为什么 Rust 不像 C 那样有一个稳定的 ABI，为什么我必须用 extern 来注解东西？"></a>为什么 Rust 不像 C 那样有一个稳定的 ABI，为什么我必须用 extern 来注解东西？</h2><p>对 ABI 的承诺是一个重大的决定，会限制未来潜在的有利的语言变化。鉴于 Rust 在 2015 年 5 月才达到 1.0，现在做出像稳定 ABI 这样大的承诺还为时过早。但这并不意味着未来不会发生。(尽管 C++ 已经成功地运行了很多年而没有指定一个稳定的 ABI)。</p><p><code>extern</code>关键字允许 Rust 使用特定的 ABI，例如定义明确的 C ABI，以便与其他语言互操作。</p><h2 id="Rust-代码可以调用-C-代码吗？"><a href="#Rust-代码可以调用-C-代码吗？" class="headerlink" title="Rust 代码可以调用 C 代码吗？"></a>Rust 代码可以调用 C 代码吗？</h2><p>可以。从 Rust 中调用 C 代码的设计与从 C++ 中调用 C 代码一样高效。</p><h2 id="C-代码可以调用-Rust-代码吗"><a href="#C-代码可以调用-Rust-代码吗" class="headerlink" title="C 代码可以调用 Rust 代码吗?"></a>C 代码可以调用 Rust 代码吗?</h2><p>是的，Rust 代码必须通过“extern”声明公开，这使得它与 C-ABI 兼容。这样的函数可以作为一个函数指针传递给 C 代码，或者，如果赋予<code>#[no_mangle]</code>属性以禁用符号纠缠，可以直接从 C 代码中调用。</p><h2 id="我已经写了完美的-C-代码。Rust-能给我什么？"><a href="#我已经写了完美的-C-代码。Rust-能给我什么？" class="headerlink" title="我已经写了完美的 C++ 代码。Rust 能给我什么？"></a>我已经写了完美的 C++ 代码。Rust 能给我什么？</h2><p>现代 C++ 包含了许多使编写安全和正确的代码不容易出错的特性，但它并不完美，而且仍然很容易引入不安全因素。这是 C++ 的核心开发人员正在努力克服的问题，但是 C++ 受限于悠久的历史，它比他们现在试图实现的很多想法都要早。</p><p>Rust 从第一天起就被设计成一种安全的系统编程语言，这意味着它不会受到历史上的设计决定的限制，而这些决定使 C++ 的安全问题变得如此复杂。在 C++ 中，安全是通过谨慎的个人纪律实现的，而且很容易出错。在 Rust 中，安全是默认的。它让你有能力在一个包括不如你完美的人在内的团队中工作，而不必花时间反复检查他们的代码是否存在安全漏洞。</p><h2 id="我如何在-Rust-中实现相当于-C-模板的专业化？"><a href="#我如何在-Rust-中实现相当于-C-模板的专业化？" class="headerlink" title="我如何在 Rust 中实现相当于 C++ 模板的专业化？"></a>我如何在 Rust 中实现相当于 C++ 模板的专业化？</h2><p>Rust 目前还没有与模板专业化完全对等的东西，但它<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/31844">正在研究中</a>，希望能很快加入。然而，类似的效果可以通过<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">关联类型</a>实现。</p><h2 id="Rust-的所有权系统与-C-的移动语义有什么关系？"><a href="#Rust-的所有权系统与-C-的移动语义有什么关系？" class="headerlink" title="Rust 的所有权系统与 C++ 的移动语义有什么关系？"></a>Rust 的所有权系统与 C++ 的移动语义有什么关系？</h2><p>底层的概念是相似的，但这两个系统在实践中的工作方式是非常不同的。在这两个系统中，“move”一个值都是一种为了转移其底层资源的所有权的方式。例如，移动一个字符串会转移字符串的缓冲区，而不是复制它。</p><p>在 Rust 中，所有权转移是默认行为。例如，如果我编写了一个以“String”为参数的函数，这个函数将对其调用者提供的<code>String</code>值拥有所有权。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">process</span>(s: <span class="type">String</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">caller</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">process</span>(s); <span class="comment">// Transfers ownership of `s` to `process`</span></span><br><span class="line">    <span class="title function_ invoke__">process</span>(s); <span class="comment">// Error! ownership already transferred.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你在上面的片段中看到的，在函数<code>caller</code>中，对<code>process</code>的第一次调用转移了变量<code>s</code>的所有权。编译器会跟踪所有权，所以第二次调用<code>process</code>会导致一个错误，因为将同一个值的所有权转让两次是非法的。如果一个值有一个未完成的引用，Rust 也会阻止你移动这个值。</p><p>C++ 采取了一种不同的方法。在 C++ 中，默认的做法是复制一个值（更确切地说，是调用复制构造函数）。然而，被调用者可以使用一个“rvalue reference”来声明他们的参数，例如<code>string&amp;&amp;</code>，以表明他们将获得该参数所拥有的一些资源的所有权（在这个例子中，字符串的内部缓冲区）。然后调用者必须传递一个临时表达式或使用<code>std::move</code>进行明确的移动。大致相当于上面的函数<code>process</code>的粗略等价物是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(string&amp;&amp; s)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">caller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello, world!&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(s));</span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ 编译器没有义务去跟踪移动。例如，上面的代码在编译时没有任何警告或错误，至少在使用默认的设置的情况下，上述代码在编译时没有任何警告或错误。此外，在C++中，字符串<code>s</code>本身的所有权（如果不是它的内部缓冲区的话）仍然属于<code>caller</code>，所以<code>s</code>的析构函数会在<code>caller</code>返回时运行，即使它已经被移动了（相反，在 Rust 中，被移动的值只被其新主人丢弃）。</p><h2 id="我怎样才能从-Rust-与-C-互操作，或者从-C-与-Rust-互操作？"><a href="#我怎样才能从-Rust-与-C-互操作，或者从-C-与-Rust-互操作？" class="headerlink" title="我怎样才能从 Rust 与 C++ 互操作，或者从 C++ 与 Rust 互操作？"></a>我怎样才能从 Rust 与 C++ 互操作，或者从 C++ 与 Rust 互操作？</h2><p>Rust 和 C++ 可以通过 C 语言进行互操作。Rust 和 C++ 都为 C 语言提供了一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code">外来函数接口</a>，并可以用它来进行相互之间的通信。如果编写 C 语言绑定太过繁琐，你可以使用<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust-bindgen">rust-bindgen</a>来帮助自动生成可行的 C 语言绑定。</p><h2 id="Rust-有-C-风格的构造函数吗？"><a href="#Rust-有-C-风格的构造函数吗？" class="headerlink" title="Rust 有 C++ 风格的构造函数吗？"></a>Rust 有 C++ 风格的构造函数吗？</h2><p>不，函数的作用与构造函数相同，不会增加语言的复杂性。在 Rust 中，相当于构造函数的通常名称是<code>new()</code>，尽管这只是一个惯例而不是语言规则。<code>new()</code>函数实际上就像其他函数一样。它的一个例子是这样的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    a: <span class="type">i32</span>,</span><br><span class="line">    b: <span class="type">f64</span>,</span><br><span class="line">    c: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Foo &#123;</span><br><span class="line">        Foo &#123;</span><br><span class="line">            a: <span class="number">0</span>,</span><br><span class="line">            b: <span class="number">0.0</span>,</span><br><span class="line">            c: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rust-有复制构造函数吗？"><a href="#Rust-有复制构造函数吗？" class="headerlink" title="Rust 有复制构造函数吗？"></a>Rust 有复制构造函数吗？</h2><p>不完全是。实现了<code>Copy</code>的类型会做一个标准的类似于 C 语言的“浅拷贝”，不需要额外的工作（类似于 C++ 中的 trivially copyable 类型）。不可能实现需要自定义复制行为的<code>Copy</code>类型。相反，在 Rust 中，“复制构造器”是通过实现<code>Clone</code>特性，并明确调用<code>clone</code>方法来创建的。将用户定义的复制操作符显性化，使开发者更容易识别潜在的昂贵操作。</p><h2 id="Rust-有移动构造函数吗？"><a href="#Rust-有移动构造函数吗？" class="headerlink" title="Rust 有移动构造函数吗？"></a>Rust 有移动构造函数吗？</h2><p>没有。所有类型的值都是通过<code>memcpy</code>移动的。这使得编写通用的不安全代码变得更加简单，因为赋值、传递和返回都是已知的，不会产生像解绑（unwinding）那样的副作用。</p><h2 id="Go-和-Rust-有什么相似之处，又有什么不同？"><a href="#Go-和-Rust-有什么相似之处，又有什么不同？" class="headerlink" title="Go 和 Rust 有什么相似之处，又有什么不同？"></a>Go 和 Rust 有什么相似之处，又有什么不同？</h2><p>Rust 和 Go 的设计目标有很大不同。以下的差异并不是唯一的差异（这些差异太多，无法一一列举），但却是其中几个比较重要的差异：</p><ul><li>Rust 比 Go 层级更低。例如，Rust 不需要垃圾收集器，而 Go 需要。一般来说，Rust 提供的控制水平与 C 或 C++ 相当。</li><li>Rust 的重点是确保安全和效率，同时提供高层次的能力，而 Go 的重点是成为一种小而简单的语言，可以快速编译并与各种工具很好地配合。</li><li>Rust 对泛型有很强的支持，而 Go （目前）却没有。</li><li>Rust 受到函数式编程世界的强烈影响，包括从 Haskell 的 typeclasses 中提取的类型系统。Go 有一个更简单的类型系统，使用接口进行基本的泛型编程。</li></ul><h2 id="Rust-traits-与-Haskell-typeclasses-相比如何？"><a href="#Rust-traits-与-Haskell-typeclasses-相比如何？" class="headerlink" title="Rust traits 与 Haskell typeclasses 相比如何？"></a>Rust traits 与 Haskell typeclasses 相比如何？</h2><p>Rust traits 类似于 Haskell 的 typeclasses，但目前还没有那么强大，因为 Rust 不能表达更高类型的类型。Rust 的关联类型等同于 Haskell 类型族。</p><p>Haskell typeclasses 和 Rust traits 之间的一些具体区别包括：</p><ul><li>Rust traits 有一个隐含的第一个参数，叫做<code>Self</code>。Rust 中的<code>trait Bar</code>对应于 Haskell 中的<code>class Bar self</code>，而 Rust 中的<code>trait Bar&lt;Foo&gt;</code>对应于 Haskell 中的<code>class Bar foo self</code>。</li><li>Rust 中的“Supertraits”或“superclass constraints”被写成<code>trait Sub: Super</code>，而 Haskell 中的为<code>class Super self =&gt; Sub self</code>。</li><li>Rust 禁止无主实例，导致 Rust 中的一致性规则与 Haskell 不同。</li><li>Rust 的<code>impl</code>解析在决定两个<code>impl</code>是否重叠或在潜在的<code>impl</code>之间进行选择时，会考虑相关的<code>where</code>条款和特质约束条件。Haskell 只考虑<code>instance</code>声明中的约束，不考虑其他地方提供的任何约束。</li><li>Rust 的 traits 的一个子集（<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">“对象安全”</a>的 traits）可以通过 trait 对象用于动态调度。同样的功能在 Haskell 中通过 GHC 的“ExistentialQuantification”可用。</li></ul><h1 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h1><h2 id="为什么-Stack-Overflow-上有这么多-Rust-的答案是错误的？"><a href="#为什么-Stack-Overflow-上有这么多-Rust-的答案是错误的？" class="headerlink" title="为什么 Stack Overflow 上有这么多 Rust 的答案是错误的？"></a>为什么 Stack Overflow 上有这么多 Rust 的答案是错误的？</h2><p>Rust 语言已经存在了很多年，在 2015 年 5 月才达到 1.0 版本。在这之前的时间里，语言发生了很大的变化，而 Stack Overflow 的一些答案是在语言的旧版本时给出的。</p><p>随着时间的推移，越来越多的答案将提供给当前的版本，从而改善这个问题，因为过时的答案的比例减少了。</p><h2 id="我在哪里报告-Rust-文档中的问题？"><a href="#我在哪里报告-Rust-文档中的问题？" class="headerlink" title="我在哪里报告 Rust 文档中的问题？"></a>我在哪里报告 Rust 文档中的问题？</h2><p>你可以在 Rust 编译器<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues">issue tracker</a>上报告 Rust 文档中的问题。请务必先阅读<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#writing-documentation">贡献指南</a>。</p><h2 id="我如何查看我的项目所依赖的库的-Rustdoc-文档？"><a href="#我如何查看我的项目所依赖的库的-Rustdoc-文档？" class="headerlink" title="我如何查看我的项目所依赖的库的 Rustdoc 文档？"></a>我如何查看我的项目所依赖的库的 Rustdoc 文档？</h2><p>当你使用<code>cargo doc</code>为你自己的项目生成文档时，它也会为活动的依赖版本生成文档。这些文档会被放到你的项目的<code>target/doc</code>目录下。使用<code>cargo doc --open</code>来打开这些文档，或者自己打开<code>target/doc/index.html</code>。</p></div><footer class="post-footer"><div class="reward-container"><div>请博主喝杯咖啡~</div> <button> 赞赏</button><div class="post-reward"><div> <img src="https://static.purewhite.io/wechat_pay.jpeg" alt="Pure White 微信"> <span>微信</span></div><div> <img src="https://static.purewhite.io/alipay.jpeg" alt="Pure White 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Pure White</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.purewhite.io/2021/09/01/rust-faq/" title="【译】Rust 常见的问题">https://www.purewhite.io/2021/09/01/rust-faq/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"> <span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://static.purewhite.io/wechat_channel.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-tags"> <a href="/tags/rust/" rel="tag"># rust</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/08/11/rust-considered-unsafe-undefined/" rel="prev" title="Rust 认为什么是“未定义”以及什么不是“不安全”？"><i class="fa fa-chevron-left"></i> Rust 认为什么是“未定义”以及什么不是“不安全”？</a></div><div class="post-nav-item"> <a href="/2021/09/23/rust-nomicon-translate/" rel="next" title="The Rustonomicon 的中文翻译">The Rustonomicon 的中文翻译<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">沪ICP备15051443号-3</a> <img src="https://static.purewhite.io/images/2019-10-30-%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31010602004105" rel="noopener" target="_blank">沪公网安备 31010602004105号</a></div><div class="copyright"> &copy; 2017 – <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Pure White</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span title="站点总字数">92k</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">5:34</span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/PureWhiteWu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.17.1/algoliasearch-lite.umd.js" integrity="sha256-F7emIId74fYoGrHzsnu3iClRHIbBMhMCbxDoA1cfMAY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.56.1/instantsearch.production.min.js" integrity="sha256-lz9C+x8+6w2rh56x5TrH5iYmE4Js2FiJS5h0tuMz7hQ=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.2.0/wavedrom.min.js","integrity":"sha256-cOqJCt2rKQA4GNjlL0tODFHnWd0CRLKLFqYhO6TCtAE="}}</script><script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.2.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script><script src="/js/third-party/tags/wavedrom.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"GnBUFiou8SXNzMY8SKVSPw6z-9Nh9j0Va","app_key":"SHesuNBbuyni9gG2gJlHAd6E","server_url":"https://leancloud.purewhite.io","security":true}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"ignores":null,"url":"https://www.purewhite.io/2021/09/01/rust-faq/"}</script><script src="/js/third-party/quicklink.js"></script><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"blog-zr0zqnlt9p","count":true,"i18n":{"disqus":"disqus"}}</script><script src="/js/third-party/comments/disqus.js"></script></body></html>